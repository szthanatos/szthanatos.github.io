<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kryptonite Lab</title>
    <link>https://szthanatos.github.io/</link>
      <atom:link href="https://szthanatos.github.io/index.xml" rel="self" type="application/rss+xml" />
    <description>Kryptonite Lab</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh-Hans</language><copyright>© 2021 szthanatos</copyright><lastBuildDate>Mon, 28 Dec 2020 19:03:14 +0800</lastBuildDate>
    <image>
      <url>https://szthanatos.github.io/media/icon_hu638af3a55c65206eddec4e3c4c13a753_187410_512x512_fill_lanczos_center_2.png</url>
      <title>Kryptonite Lab</title>
      <link>https://szthanatos.github.io/</link>
    </image>
    
    <item>
      <title>Docker -01- 基本概念</title>
      <link>https://szthanatos.github.io/topic/docker/basis/</link>
      <pubDate>Wed, 05 Dec 2018 22:17:22 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/docker/basis/</guid>
      <description>&lt;h2 id=&#34;docker-简介&#34;&gt;Docker 简介&lt;/h2&gt;
&lt;h3 id=&#34;什么是-docker&#34;&gt;什么是 Docker&lt;/h3&gt;
&lt;p&gt;Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 &lt;a href=&#34;https://github.com/moby/moby&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt; 上进行维护，后来还加入了 Linux 基金会，并成立推动 &lt;a href=&#34;https://www.opencontainers.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开放容器联盟（OCI）&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Docker 最初是在 Ubuntu 12.04 上以 &lt;a href=&#34;https://golang.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Go 语言&lt;/a&gt; 进行开发实现的, Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持 (换句话说不支持 CentOS6.5 以下)。&lt;/p&gt;
&lt;p&gt;Docker 是一种 &lt;strong&gt;容器化技术&lt;/strong&gt; ，类似虚拟机的概念，但不同的是传统虚拟机是在虚拟硬件的基础上，完整模拟一整个操作系统，而 Docker 是以单个应用（容器）为单位进行虚拟。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://szthanatos.github.io/media/virtualization.png&#34; alt=&#34;传统虚拟化&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://szthanatos.github.io/media/docker.png&#34; alt=&#34;Docker&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;docker-特点&#34;&gt;Docker 特点&lt;/h3&gt;
&lt;p&gt;Docker 具有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件系统隔离&lt;/strong&gt; ：每个进程容器运行在完全独立的根文件系统里。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源隔离&lt;/strong&gt; ：可以使用 cgroup 为每个进程容器分配不同的系统资源，例如 CPU 和内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络隔离&lt;/strong&gt; ：每个进程容器运行在自己的网络命名空间里，拥有自己的虚拟接口和 IP 地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写时复制&lt;/strong&gt; ：采用写时复制方式创建根文件系统，这让部署变得极其快捷，并且节省内存和硬盘空间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日志记录&lt;/strong&gt; ：Docker 将会收集和记录每个进程容器的标准流（stdout/stderr/stdin），用于实时检索或批量检索。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;变更管理&lt;/strong&gt; ：容器文件系统的变更可以提交到新的映像中，并可重复使用以创建更多的容器。无需使用模板或手动配置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;交互式 Shell&lt;/strong&gt; ：Docker 可以分配一个虚拟终端并关联到任何容器的标准输入上，例如运行一个一次性交互 shell。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么要使用-docker&#34;&gt;为什么要使用 Docker&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;特性&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;容器&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;虚拟机&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;启动&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;秒级&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;分钟级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;硬盘使用&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;一般为 &lt;code&gt;MB&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;一般为 &lt;code&gt;GB&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;性能&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;接近原生&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;弱于原生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;系统支持量&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单机支持上千个容器&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;一般几十个&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;更高效的利用系统资源&lt;/strong&gt; ：由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更快速的启动时间&lt;/strong&gt; ：Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致的运行环境&lt;/strong&gt; ： Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 &lt;em&gt;「这段代码在我机器上没问题啊」&lt;/em&gt; 这类问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持续交付和部署&lt;/strong&gt; ：对 &lt;code&gt;DevOps&lt;/code&gt; 人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 &lt;a href=&#34;###Dockerfile&#34;&gt;Dockerfile&lt;/a&gt; 来进行镜像构建，并结合 &lt;code&gt;持续集成 (Continuous Integration)&lt;/code&gt; 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 &lt;code&gt;持续部署 (Continuous Delivery/Deployment)&lt;/code&gt; 系统进行自动部署。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更轻松的迁移&lt;/strong&gt; ：由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;Docker 包括三个基本概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;镜像（&lt;code&gt;Image&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;容器（&lt;code&gt;Container&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;仓库（&lt;code&gt;Repository&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理解了这三个概念，就理解了 Docker 的整个生命周期。&lt;/p&gt;
&lt;h3 id=&#34;镜像&#34;&gt;镜像&lt;/h3&gt;
&lt;p&gt;操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 &lt;code&gt;root&lt;/code&gt; 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 &lt;code&gt;root&lt;/code&gt; 文件系统。比如官方镜像 &lt;code&gt;ubuntu:16.04&lt;/code&gt; 就包含了完整的一套 Ubuntu 16.04 最小系统的 &lt;code&gt;root&lt;/code&gt; 文件系统。&lt;/p&gt;
&lt;p&gt;Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 &lt;strong&gt;镜像不包含任何动态数据，其内容在构建之后也不会被改变。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。&lt;/strong&gt; 比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。&lt;/p&gt;
&lt;p&gt;分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。&lt;/p&gt;
&lt;h3 id=&#34;容器&#34;&gt;容器&lt;/h3&gt;
&lt;p&gt;镜像（&lt;code&gt;Image&lt;/code&gt;）和容器（&lt;code&gt;Container&lt;/code&gt;）的关系，就像是面向对象程序设计中的 &lt;code&gt;类&lt;/code&gt; 和 &lt;code&gt;实例&lt;/code&gt; 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器的实质是进程&lt;/strong&gt; ，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 &lt;code&gt;命名空间&lt;/code&gt;。因此容器可以拥有自己的 &lt;code&gt;root&lt;/code&gt; 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。&lt;/p&gt;
&lt;p&gt;前面讲过镜像使用的是分层存储，容器也是如此。 &lt;strong&gt;每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，&lt;/strong&gt; 我们可以称这个为容器运行时读写而准备的存储层为 &lt;strong&gt;容器存储层&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此， &lt;strong&gt;任何保存于容器存储层的信息都会随容器删除而丢失&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。 &lt;strong&gt;所有的文件写入操作，都应该使用 [数据卷（Volume）](#### 方式 1：数据卷（推荐）)、或者 [绑定宿主目录](#### 方式 2：挂载主机目录)&lt;/strong&gt; ，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。&lt;/p&gt;
&lt;p&gt;数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。&lt;/p&gt;
&lt;h3 id=&#34;仓库&#34;&gt;仓库&lt;/h3&gt;
&lt;p&gt;如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker 提供注册服务器 (&lt;code&gt;Docker Registry&lt;/code&gt;) 来实现这样的服务。&lt;/p&gt;
&lt;p&gt;一个 &lt;code&gt;Docker Registry&lt;/code&gt; 中可以包含多个 &lt;strong&gt;仓库&lt;/strong&gt; （&lt;code&gt;Repository&lt;/code&gt;）；每个仓库可以包含多个 &lt;strong&gt;标签&lt;/strong&gt; （&lt;code&gt;Tag&lt;/code&gt;）；每个标签对应一个镜像。&lt;/p&gt;
&lt;p&gt;通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;code&gt;&amp;lt;仓库名&amp;gt;:&amp;lt; 标签 &amp;gt;&lt;/code&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 &lt;code&gt;latest&lt;/code&gt; 作为默认标签。&lt;/p&gt;
&lt;p&gt;以 &lt;a href=&#34;https://store.docker.com/images/ubuntu&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ubuntu 镜像&lt;/a&gt; 为例，&lt;code&gt;ubuntu&lt;/code&gt; 是仓库的名字，其内包含有不同的版本标签，如，&lt;code&gt;14.04&lt;/code&gt;, &lt;code&gt;16.04&lt;/code&gt;。我们可以通过 &lt;code&gt;ubuntu:14.04&lt;/code&gt;，或者 &lt;code&gt;ubuntu:16.04&lt;/code&gt; 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 &lt;code&gt;ubuntu&lt;/code&gt;，那将视为 &lt;code&gt;ubuntu:latest&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;仓库名经常以 &lt;em&gt;两段式路径&lt;/em&gt; 形式出现，比如 &lt;code&gt;jwilder/nginx-proxy&lt;/code&gt;，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。&lt;/p&gt;
&lt;p&gt;类似 git 和 GitHub，官方提供 &lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Hub&lt;/a&gt;，作为默认的 Registry。用户也可以在本地搭建私有 Docker Registry。Docker 官方提供了 &lt;a href=&#34;https://store.docker.com/images/registry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Registry&lt;/a&gt; 镜像，可以直接使用做为私有 Registry 服务。&lt;/p&gt;
&lt;h3 id=&#34;生命周期&#34;&gt;生命周期&lt;/h3&gt;
&lt;p&gt;结合上面的概念，这里有一张图比较好的概括了整个 Docker 工作的生命周期（以及主要命令）。
&lt;img src=&#34;https://szthanatos.github.io/media/period.png&#34; alt=&#34;生命周期&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装配置&#34;&gt;安装配置&lt;/h2&gt;
&lt;p&gt;这里仅以 CentOS 安装 Docker CE 举例说明。详见 &lt;a href=&#34;https://docs.docker.com/engine/installation/linux/docker-ce/centos/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker 官方 CentOS 安装文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;准备工作&#34;&gt;准备工作&lt;/h3&gt;
&lt;h4 id=&#34;系统要求&#34;&gt;系统要求&lt;/h4&gt;
&lt;p&gt;Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 &lt;code&gt;overlay2&lt;/code&gt; 存储层驱动）无法使用，并且部分功能可能不太稳定。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;警告：切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;卸载旧版本&#34;&gt;卸载旧版本&lt;/h4&gt;
&lt;p&gt;旧版本的 Docker 称为 &lt;code&gt;docker&lt;/code&gt; 或者 &lt;code&gt;docker-engine&lt;/code&gt;，使用以下命令卸载旧版本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo yum remove docker \
                docker-client \
                docker-client-latest \
                docker-common \
                docker-latest \
                docker-latest-logrotate \
                docker-logrotate \
                docker-selinux \
                docker-engine-selinux \
                docker-engine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用脚本安装非生产环境&#34;&gt;使用脚本安装（非生产环境）&lt;/h3&gt;
&lt;p&gt;对于个人测试，可以使用这个脚本自动化安装 Docker：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -fsSL get.docker.com -o get-docker.sh
sh get-docker.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，需要注意， &lt;strong&gt;这个脚本可能扰乱你的系统配置、安装及大量的（你可能用不到的）依赖，并且只能安装最新（可能未经充分测试的）版本的 Docker&lt;/strong&gt; ， 所以不推荐在生产环境中使用。&lt;/p&gt;
&lt;h3 id=&#34;使用-yum-安装&#34;&gt;使用 yum 安装&lt;/h3&gt;
&lt;p&gt;安装依赖包：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo yum install -y yum-utils \
                    device-mapper-persistent-data \
                    lvm2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加 &lt;code&gt;yum&lt;/code&gt; 软件源：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 中国科学技术大学开源软件镜像源
sudo yum-config-manager \
    --add-repo \
    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo


# 官方源
# sudo yum-config-manager \
#     --add-repo \
#     https://download.docker.com/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新 &lt;code&gt;yum&lt;/code&gt; 软件源缓存，并安装 &lt;code&gt;docker-ce&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo yum makecache fast
sudo yum install docker-ce
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;离线安装&#34;&gt;离线安装&lt;/h3&gt;
&lt;p&gt;以 docker-ce-18.03.1 为例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 &lt;code&gt;https://download.docker.com/linux/centos/7/x86_64/stable/Packages/&lt;/code&gt; 这里找到对应 rpm 包&lt;/li&gt;
&lt;li&gt;执行安装命令：&lt;code&gt;rpm -ivh docker-ce-18.03.1.ce-1.el7.centos.x86_64.rpm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;由于安装环境不同，可能会发现缺少一些相关依赖包（eg: libcgroup、libtool-ltdl、container-selinux）前往 &lt;code&gt;https://pkgs.org/&lt;/code&gt; 或 &lt;code&gt;https://buildlogs.centos.org/&lt;/code&gt; 下载对应依赖包，依次安装即可&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;启动-docker-ce&#34;&gt;启动 Docker CE&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo systemctl enable docker
sudo systemctl start docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;建立-docker-用户组&#34;&gt;建立 Docker 用户组&lt;/h3&gt;
&lt;p&gt;默认情况下，docker 命令需要 &lt;code&gt;root&lt;/code&gt; 权限，为了避免每次输入命令都要加 &lt;code&gt;sudo&lt;/code&gt;，可以将用户加入 &lt;code&gt;docker&lt;/code&gt; 用户组：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo groupadd docker
sudo usermod -aG docker $USER
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;退出当前终端并重新登录，进行如下测试。&lt;/p&gt;
&lt;h3 id=&#34;测试-docker-是否安装正确&#34;&gt;测试 Docker 是否安装正确&lt;/h3&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run hello-world
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Docker 会从官方仓库下载 hello-world 镜像并启动，如果一切正常的话会看到类似如下提示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Unable to find image &#39;hello-world:latest&#39; locally
latest: Pulling from library/hello-world
ca4f61b1923c: Pull complete
Digest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905c
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &amp;quot;hello-world&amp;quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://cloud.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/engine/userguide/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;镜像加速&#34;&gt;镜像加速&lt;/h3&gt;
&lt;p&gt;鉴于国内网络问题，建议使用 Docker 中国或者其他国内镜像源。&lt;/p&gt;
&lt;p&gt;修改（或新增）&lt;code&gt;/etc/docker/daemon.json&lt;/code&gt; 文件，添加:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;{
  &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://registry.docker-cn.com&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后重启 Docker 使配置生效。&lt;/p&gt;
&lt;h3 id=&#34;常用-docker-操作&#34;&gt;常用 Docker 操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 查看 docker 版本
docker version
# 显示 docker 系统的信息
docker info
# 日志信息
docker logs
# 故障检查
service docker status
# 启动关闭 docker
sudo service docker start|stop
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用镜像&#34;&gt;使用镜像&lt;/h2&gt;
&lt;h3 id=&#34;基本操作&#34;&gt;基本操作&lt;/h3&gt;
&lt;p&gt;以 redis 为例，我们从 &lt;a href=&#34;https://hub.docker.com/explore/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Hub&lt;/a&gt; 上获取官方镜像到本地：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://szthanatos.github.io/media/hub-redis.jpg&#34; alt=&#34;Docker hub redis&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker pull redis
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;ps1：&lt;/em&gt; 由于 redis 是官方源（Official），否则应该写完整的两段式仓库名 &lt;code&gt;&amp;lt;用户名&amp;gt;/&amp;lt; 软件名 &amp;gt;&lt;/code&gt;，例如 bitnami/redis。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ps2：&lt;/em&gt; 此处没有指定镜像版本，默认会拉取 redis:lastest 镜像，指定版本应该写成例如：redis:5.0-rc5&lt;/p&gt;
&lt;p&gt;查看已经下载的镜像：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker image ls

# 会有类似如下显示
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
redis                latest              5f515359c7f8        5 days ago          183 MB
......
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更细节的显示可以使用 &lt;code&gt;docker image ls --format &amp;quot;{{.ID}}: {{.Repository}}&amp;quot;&lt;/code&gt; 直接列出镜像 ID 和仓库名,&lt;/p&gt;
&lt;p&gt;或者使用 &lt;code&gt;docker image ls --format &amp;quot;table {{.ID}}\t{{.Repository}}\t{{.Tag}}&amp;quot;&lt;/code&gt;
以表格等距显示.&lt;/p&gt;
&lt;p&gt;如果要删除某个镜像的话，可以使用 &lt;code&gt;docker image rm {IMAGE ID}|{REPOSITORY}&lt;/code&gt; 命令，不要过先确保没有容器在使用这个镜像。&lt;/p&gt;
&lt;h3 id=&#34;dockerfile&#34;&gt;Dockerfile&lt;/h3&gt;
&lt;p&gt;除了引用制作好的镜像，我们也可以基于现有镜像定制新的镜像。定制所用的脚本文件就是 Dockerfile。&lt;/p&gt;
&lt;p&gt;Dockerfile 是一个文本文件，其内包含了一条条的 &lt;strong&gt;指令 (Instruction)&lt;/strong&gt; ，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。&lt;/p&gt;
&lt;p&gt;我们新建一个空白文件，命名为 &lt;code&gt;dockerfile&lt;/code&gt;，再文件中写入如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM redis
RUN mkdir redis
WORKDIR redis
COPY ./redis.conf /etc/
CMD [&amp;quot;redis-server&amp;quot;, &amp;quot;/etc/redis.conf&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们依次解释上面每一行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;FROM&lt;/strong&gt; 就是指定 &lt;strong&gt;基础镜像&lt;/strong&gt; , 一个 &lt;code&gt;Dockerfile&lt;/code&gt; 中 &lt;code&gt;FROM&lt;/code&gt; 是必备的指令，并且必须是第一条指令。如果不以任何镜像为基础，那应该用 &lt;code&gt;FROM scratch&lt;/code&gt; 作为起始指令。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RUN&lt;/strong&gt; 是 Dockerfile 的核心指令，用于执行一条命令，由于 Dockerfile 每一条指令都会新建一层，所以应该尽量将执行的内容写在一行（多行内容可以通过在末尾加 &lt;code&gt;\&lt;/code&gt; 以表示未结束），它有两种写法：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;shell&lt;/strong&gt; 格式：&lt;code&gt;RUN &amp;lt;命令&amp;gt;&lt;/code&gt;，就像直接在命令行中输入的命令一样。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;exec&lt;/strong&gt; 格式：&lt;code&gt;RUN [&amp;quot;可执行文件&amp;quot;, &amp;quot;参数 1&amp;quot;, &amp;quot;参数 2&amp;quot;]&lt;/code&gt;，这更像是函数调用中的格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WORKDIR&lt;/strong&gt; 表示指定当前工作目录，相当于 &lt;code&gt;cd&lt;/code&gt; 命令。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;COPY&lt;/strong&gt; 即复制文件到容器中，在这里是把 redis.conf 文件复制到容器的 &lt;code&gt;/etc&lt;/code&gt; 目录下。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CMD&lt;/strong&gt; 是启动程序的命令，写法和 &lt;code&gt;RUN&lt;/code&gt; 相同，一般推荐使用 &lt;code&gt;exec&lt;/code&gt; 格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用 Docker 指令列表如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;用法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;FROM&lt;/td&gt;
&lt;td&gt;指定基础镜像&lt;/td&gt;
&lt;td&gt;&lt;code&gt;FROM &amp;lt;基础镜像&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RUN&lt;/td&gt;
&lt;td&gt;执行指令&lt;/td&gt;
&lt;td&gt;&lt;code&gt;RUN [&amp;quot;可执行文件&amp;quot;, &amp;quot;参数 1&amp;quot;, &amp;quot;参数 2&amp;quot;]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;COPY&lt;/td&gt;
&lt;td&gt;复制文件&lt;/td&gt;
&lt;td&gt;&lt;code&gt;COPY [&amp;quot;&amp;lt; 源路径 1&amp;gt;&amp;quot;,... &amp;quot;&amp;lt; 目标路径 &amp;gt;&amp;quot;]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ADD&lt;/td&gt;
&lt;td&gt;更高级的复制文件&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ADD &amp;quot;&amp;lt;压缩文件&amp;gt;&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CMD&lt;/td&gt;
&lt;td&gt;容器启动命令&lt;/td&gt;
&lt;td&gt;&lt;code&gt;CMD [&amp;quot;可执行文件&amp;quot;, &amp;quot;参数 1&amp;quot;, &amp;quot;参数 2&amp;quot;...]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ENTRYPOINT&lt;/td&gt;
&lt;td&gt;入口点&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ENTRYPOINT [&amp;quot;可执行文件&amp;quot;, &amp;quot;参数 1&amp;quot;, &amp;quot;参数 2&amp;quot;]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ENV&lt;/td&gt;
&lt;td&gt;设置环境变量&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ENV &amp;lt;key1&amp;gt;=&amp;lt;value1&amp;gt; &amp;lt;key2&amp;gt;=&amp;lt;value2&amp;gt;...&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ARG&lt;/td&gt;
&lt;td&gt;构建参数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ARG &amp;lt;参数名&amp;gt;[=&amp;lt; 默认值 &amp;gt;]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VOLUME&lt;/td&gt;
&lt;td&gt;定义匿名卷&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VOLUME [&amp;quot;&amp;lt; 路径 1&amp;gt;&amp;quot;, &amp;quot;&amp;lt; 路径 2&amp;gt;&amp;quot;...]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXPOSE&lt;/td&gt;
&lt;td&gt;暴露端口&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EXPOSE &amp;lt;端口 1&amp;gt; [&amp;lt; 端口 2&amp;gt;...]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WORKDIR&lt;/td&gt;
&lt;td&gt;指定工作目录&lt;/td&gt;
&lt;td&gt;&lt;code&gt;WORKDIR &amp;lt;工作目录路径&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;USER&lt;/td&gt;
&lt;td&gt;指定当前用户&lt;/td&gt;
&lt;td&gt;&lt;code&gt;USER &amp;lt;用户名&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HEALTHCHECK&lt;/td&gt;
&lt;td&gt;健康检查&lt;/td&gt;
&lt;td&gt;`HEALTHCHECK NONE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ONBUILD&lt;/td&gt;
&lt;td&gt;构建下级镜像&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ONBUILD &amp;lt;其它指令&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MAINTAINER&lt;/td&gt;
&lt;td&gt;指定作者&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ONBUILD &amp;lt;作者&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;更多指令及用法请参照 &lt;a href=&#34;https://docs.docker.com/engine/reference/builder&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如上，我们完成了一个使用自己配置文件的 redis 镜像的准备工作，之后依据这个 Dockerfile 进行构建：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker build -t redis_test:v0.1 .

# 会有类似如下输出：
Sending build context to Docker daemon 2.048 kB
Step 1 : FROM redis
...
...
Removing intermediate container 9cdc27646c7b
Successfully built 44aa4490ce2c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker build&lt;/code&gt; 的用法为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker build [选项] &amp;lt; 上下文路径 / URL/-&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，可以使用 &lt;code&gt;docker push&lt;/code&gt; 将你自己构建的镜像上传到仓库中，详细用法见 &lt;a href=&#34;https://docs.docker.com/engine/reference/commandline/push/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档 push&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;容器操作&#34;&gt;容器操作&lt;/h2&gt;
&lt;h3 id=&#34;容器启停&#34;&gt;容器启停&lt;/h3&gt;
&lt;p&gt;我们可以用这样的方式从之前的镜像启动一个容器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -d --name some-redis redis
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt; 的用法为 &lt;code&gt;docker run [选项] 镜像 [命令] [参数...]&lt;/code&gt;，其中：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--name&lt;/code&gt; 指定容器的名称， &lt;code&gt;-d&lt;/code&gt; 指定后台运行，其他常用参数包括 &lt;code&gt;-i&lt;/code&gt; 交互式操作，&lt;code&gt;-t&lt;/code&gt; 使用终端（&lt;code&gt;it&lt;/code&gt; 一般同时使用），&lt;code&gt;--rm&lt;/code&gt; 容器退出后随之将其删除，完整参数列表可以通过 &lt;code&gt;--help&lt;/code&gt; 或者 &lt;a href=&#34;https://docs.docker.com/engine/reference/commandline/run/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在线文档 docker run&lt;/a&gt; 查看&lt;/p&gt;
&lt;p&gt;由于我们是在后台运行，使用 &lt;code&gt;docker container ls&lt;/code&gt; 来查看容器相关情况，如果要查看停止的进程，后面需要增加参数 &lt;code&gt;-a&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker container ls

# 会看到类似如下内容
CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES
77b2dc01fe0f  redis:v2  redis-server redis.conf &#39;while tr  2 minutes ago  Up 1 minute        agitated_wright
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;docker container stop&lt;/code&gt; 来结束容器的运行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker container stop 77b2dc01fe0f
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类似的，使用 &lt;code&gt;docker container start | restart | stop&lt;/code&gt; 可以控制容器的启停，
使用 &lt;code&gt;docker container rm&lt;/code&gt; 来删除指定容器。&lt;/p&gt;
&lt;h3 id=&#34;数据管理&#34;&gt;数据管理&lt;/h3&gt;
&lt;p&gt;之前提到过，随着容器的销毁，容器内的数据也会一同丢失。为了保存数据，Docker 提供了两种方式（还有一种 tmpfs mountsb 不常用到）：&lt;/p&gt;
&lt;h4 id=&#34;方式-1数据卷推荐&#34;&gt;方式 1：数据卷（推荐）&lt;/h4&gt;
&lt;p&gt;数据卷 &lt;code&gt;volume&lt;/code&gt; 是一个可供一个或多个容器使用的特殊目录，它不依赖于 Unix 文件系统，也拥有独立于容器的生命周期。&lt;/p&gt;
&lt;p&gt;创建一个数据卷:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker volume create my-vol
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看数据卷及具体信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 查看所有的数据卷
docker volume ls

# 会看到类似如下内容
local               my-vol

# -----------------------------------

# 查看具体卷的信息
docker volume inspect my-vol

# 会看到类似如下内容
[
    {
        &amp;quot;Driver&amp;quot;: &amp;quot;local&amp;quot;,
        &amp;quot;Labels&amp;quot;: {},
        &amp;quot;Mountpoint&amp;quot;: &amp;quot;/var/lib/docker/volumes/my-vol/_data&amp;quot;,
        &amp;quot;Name&amp;quot;: &amp;quot;my-vol&amp;quot;,
        &amp;quot;Options&amp;quot;: {},
        &amp;quot;Scope&amp;quot;: &amp;quot;local&amp;quot;
    }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在用 docker run 的时候，增加 &lt;code&gt;--mount&lt;/code&gt; 参数来使用数据卷, 还是以启动 redis 为例，这里我们启动 redis 并且开启 aof 持久化：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -d \
    --name redis \
    --mount source=my-vol,target=/data \
    # -v my-vol:/data \
    redis \
    redis-server --appendonly yes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里 redis 产生的数据（&lt;code&gt;/data&lt;/code&gt; 目录下）被挂载到数据卷 &lt;code&gt;my-vol&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;我们也可以使用 &lt;code&gt;-v&lt;/code&gt; 或者 &lt;code&gt;--volume&lt;/code&gt; 语法，但是 &lt;a href=&#34;https://docs.docker.com/storage/volumes/#choose-the--v-or---mount-flag&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方建议&lt;/a&gt; 尽量使用 &lt;code&gt;--mount&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;同样使用 &lt;code&gt;inspect&lt;/code&gt; 语法，我们可以查看 redis 容器的信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker inspect redis

# 会看到类似如下内容
&amp;quot;Mounts&amp;quot;: [
    {
        &amp;quot;Type&amp;quot;: &amp;quot;volume&amp;quot;,
        &amp;quot;Name&amp;quot;: &amp;quot;my-vol&amp;quot;,
        &amp;quot;Source&amp;quot;: &amp;quot;/var/lib/docker/volumes/my-vol/_data&amp;quot;,
        &amp;quot;Destination&amp;quot;: &amp;quot;/data&amp;quot;,
        &amp;quot;Driver&amp;quot;: &amp;quot;local&amp;quot;,
        &amp;quot;Mode&amp;quot;: &amp;quot;&amp;quot;,
        &amp;quot;RW&amp;quot;: true,
        &amp;quot;Propagation&amp;quot;: &amp;quot;&amp;quot;
    }
],
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;方式-2绑定主机目录&#34;&gt;方式 2：绑定主机目录&lt;/h4&gt;
&lt;p&gt;我们也可以直接将容器的数据挂载 &lt;code&gt;bind mount&lt;/code&gt; 到宿主机的目录或文件 （而非由 Docker 创建的数据卷）, 以当前目录 &lt;code&gt;$(pwd)&lt;/code&gt; 为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -d \
    --name redis \
    --mount type=bind,source=&amp;quot;$(pwd)&amp;quot;/target,target=/data \
    redis \
    redis-server --appendonly yes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;挂载单独文件的方法类似。&lt;/p&gt;
&lt;p&gt;需要注意，本地目录必须存在，否则会报错。&lt;/p&gt;
&lt;h4 id=&#34;区别&#34;&gt;区别&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://szthanatos.github.io/media/types-of-mounts-volume.png&#34; alt=&#34;types of mounts volume&#34;&gt;&lt;/p&gt;
&lt;p&gt;Volumes 是由 Docker 创建和管理，存储在宿主机固定位置（在 linux 上是 / var/lib/docker/volumes/）。 &lt;strong&gt;非 Docker 应用程序不能改动这一位置的数据。&lt;/strong&gt; 一个数据卷可以同时被挂载到几个容器中。即使没有正在运行的容器使用这个数据卷，它依然不会清除。可以通过 &lt;code&gt;docker volume prune&lt;/code&gt; 清除不再使用的数据卷。&lt;/p&gt;
&lt;p&gt;Bind mounts 的数据可以存放在宿主机的任何地方。 &lt;strong&gt;非 Docker 应用程序可以改变这些数据。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;使用网络&#34;&gt;使用网络&lt;/h3&gt;
&lt;h4 id=&#34;端口映射&#34;&gt;端口映射&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt; 的时候使用 &lt;code&gt;-P&lt;/code&gt;(&amp;ndash;publish-all) 参数，随机映射一个 49000~49900 的端口到内部容器开放的网络端口。&lt;/p&gt;
&lt;p&gt;或者使用 &lt;code&gt;-p ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort&lt;/code&gt;(&amp;ndash;publish) 来指定具体端口映射：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -d \
    --name some-redis \
    -p 6379:6379 \
    -p 127.0.0.1::16379/udp
    -p 127.0.0.1:80:80
    redis
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们分别将容器的 6379 端口映射到宿主机 &lt;strong&gt;任意 ip 的 6379 端口&lt;/strong&gt; ，容器的 16379 udp 端口映射到宿主机的 &lt;strong&gt;任意端口&lt;/strong&gt; ，容器的 80 端口映射到宿主机 &lt;strong&gt;对应的 80 端口&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;docker port&lt;/code&gt; 可以查看对应容器的全部端口映射。&lt;/p&gt;
&lt;h4 id=&#34;容器互联&#34;&gt;容器互联&lt;/h4&gt;
&lt;p&gt;简单的容器互联可以通过 &lt;code&gt;--link&lt;/code&gt; 实现，但是 &lt;strong&gt;官方未来可能会删除这个参数&lt;/strong&gt; ，所以不展开。&lt;/p&gt;
&lt;p&gt;最新的方式是搭建 docker 网络实现容器互联，先创建一个新的 Docker 网络：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker network create -d bridge my-net
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的 &lt;code&gt;-d&lt;/code&gt; 参数指定网络类型，常用的只有 bridge，其他的可能会在 Swarm 用到, 如果不知道 Swarm 是什么就不用在意。&lt;/p&gt;
&lt;p&gt;以 redis 客户端 / 服务端为例，分别在启动的时候将之加入 &lt;code&gt;my-net&lt;/code&gt; 网络：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -d \
    --name redis-server \
    --network my-net \
    redis

docker run -it \
    --rm \
    --name redis-client \
    --network my-net \
    redis redis-cli -h redis-server

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到成功进入 redis-cli 客户端，我们可以尝试 &lt;code&gt;info&lt;/code&gt;/&lt;code&gt;keys *&lt;/code&gt; 或者其他命令查看 redis 服务端运行情况。&lt;/p&gt;
&lt;h2 id=&#34;延申&#34;&gt;延申&lt;/h2&gt;
&lt;h3 id=&#34;容器编排&#34;&gt;容器编排&lt;/h3&gt;
&lt;p&gt;面临一组容器配合使用的情况，例如一个包括负载均衡——网站后台——数据库的 Web 系统，我们可以使用 Docker 提供的 &lt;a href=&#34;https://github.com/docker/compose&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Compose&lt;/a&gt; 完成统一配置管理。它将提供相同功能的容器定义为服务 &lt;code&gt;service&lt;/code&gt;——以方便复用；将完整的容器组合组成项目 &lt;code&gt;project&lt;/code&gt; 以方便统一管理。所有的配置通过一个 yml 文件即可实现。&lt;/p&gt;
&lt;h3 id=&#34;nvidia-docker&#34;&gt;Nvidia Docker&lt;/h3&gt;
&lt;p&gt;对使用 GPU 的容器，Docker 提供 &lt;a href=&#34;https://github.com/NVIDIA/nvidia-docker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nvidia Docker&lt;/a&gt; 以发挥 GPU 的运算性能。&lt;/p&gt;
&lt;p&gt;基本要求如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GNU/Linux x86_64 with kernel version &amp;gt; 3.10&lt;/li&gt;
&lt;li&gt;Docker &amp;gt;= 1.12&lt;/li&gt;
&lt;li&gt;NVIDIA GPU with Architecture &amp;gt; Fermi (2.1)&lt;/li&gt;
&lt;li&gt;NVIDIA drivers ~= 361.93 (untested on older versions)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细安装使用见 &lt;a href=&#34;https://github.com/NVIDIA/nvidia-docker/wiki/Installation-%28version-2.0%29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方项目 Wiki&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker -02- 进阶生态</title>
      <link>https://szthanatos.github.io/topic/docker/ecology/</link>
      <pubDate>Thu, 06 Dec 2018 10:06:06 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/docker/ecology/</guid>
      <description></description>
    </item>
    
    <item>
      <title>开启 WSL2 安装 Ubuntu</title>
      <link>https://szthanatos.github.io/topic/wsl2/coding_with_wsl2_01/</link>
      <pubDate>Sat, 22 Aug 2020 11:37:05 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/wsl2/coding_with_wsl2_01/</guid>
      <description>&lt;h2 id=&#34;什么是-wsl&#34;&gt;什么是 WSL&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;适用于 Linux 的 Windows 子系统可让开发人员按原样运行 GNU/Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生传统虚拟机或双启动设置开销。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而现在出的 WSL2 是基于 Hyper-V 虚拟机的&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;什么是-wsl-2&#34;&gt;什么是 WSL 2&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;WSL 2 是适用于 Linux 的 Windows 子系统体系结构的一个新版本，它支持适用于 Linux 的 Windows 子系统在 Windows 上运行 ELF64 Linux 二进制文件。 它的主要目标是提高文件系统性能，以及添加完全的系统调用兼容性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/szthanatos/image-host/master/wsl1-vs-wsl2.png?token=AAZJE7LDWNNOLQZEFZE54BC7ID77W&#34; alt=&#34;wsl1 vs wsl2&#34;&gt;&lt;/p&gt;
&lt;p&gt;wsl1 其实感觉速度更快，和 windows 共享网络，而且没有文件系统的限制。&lt;/p&gt;
&lt;p&gt;然而 wsl1 不是完整 Linux 内核，不支持 Docker。如果你只是要一个 Linux 环境可以考虑使用 wsl1 。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;h3 id=&#34;启用-windows-subsystem-linux&#34;&gt;启用 Windows-Subsystem-Linux&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;控制面板&lt;/code&gt;-&lt;code&gt;程序&lt;/code&gt;-  &lt;code&gt;启用或关闭 Windows 功能&lt;/code&gt; 中勾选 &lt;code&gt;适用于 Linux 的 Windows 子系统&lt;/code&gt; 以及 &lt;code&gt;虚拟机平台&lt;/code&gt;(wsl2 需要)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/szthanatos/image-host/master/enable-wsl2.png&#34; alt=&#34;启用 wsl2&#34;&gt;&lt;/p&gt;
&lt;p&gt;或者通过命令行（管理员身份）执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;# 适用于 Linux 的 Windows 子系统
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart

# 虚拟机平台
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成后需要重启电脑。&lt;/p&gt;
&lt;h3 id=&#34;更新内核&#34;&gt;更新内核&lt;/h3&gt;
&lt;p&gt;目前版本的 Win10 需要手动更新 WSL2 内核，前往 &lt;a href=&#34;https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;下载适用于 x64 计算机的最新 WSL2 Linux 内核&lt;/a&gt; 下载 msi 文件手动更新。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ARM 平台前往 &lt;a href=&#34;https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_arm64.msi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;下载适用于 ARM64 计算机的最新 WSL2 Linux 内核&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;设置-wsl-默认版本&#34;&gt;设置 wsl 默认版本&lt;/h3&gt;
&lt;p&gt;通过命令行（管理员身份）执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;wsl --set-default-version 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;让未来的 Linux 都默认以 WSL2 形式安装。&lt;/p&gt;
&lt;p&gt;现有 WSL 虚拟机也可以通过：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;# 获取现有 wsl 版本信息
wsl --list --verbose

# 将现有发行版转化为制定版本
wsl --set-version &amp;lt;distribution name&amp;gt; &amp;lt;versionNumber&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;升级到 WSL2 。&lt;/p&gt;
&lt;h3 id=&#34;安装-linux-系统&#34;&gt;安装 Linux 系统&lt;/h3&gt;
&lt;p&gt;打开 &lt;a href=&#34;https://aka.ms/wslstore&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Microsoft Store&lt;/a&gt;，搜索 wsl 即可获取可用 Linux 发行版。&lt;/p&gt;
&lt;p&gt;现在支持的发行版有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu 16.04 LTS&lt;/li&gt;
&lt;li&gt;Ubuntu 18.04 LTS&lt;/li&gt;
&lt;li&gt;Ubuntu 20.04 LTS&lt;/li&gt;
&lt;li&gt;openSUSE Leap 15.1&lt;/li&gt;
&lt;li&gt;SUSE Linux Enterprise Server 12 SP5&lt;/li&gt;
&lt;li&gt;SUSE Linux Enterprise Server 15 SP1&lt;/li&gt;
&lt;li&gt;Kali Linux&lt;/li&gt;
&lt;li&gt;Debian GNU/Linux&lt;/li&gt;
&lt;li&gt;Fedora Remix for WSL&lt;/li&gt;
&lt;li&gt;Pengwin&lt;/li&gt;
&lt;li&gt;Pengwin Enterprise&lt;/li&gt;
&lt;li&gt;Alpine WSL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下载完成后，点击图标进入，首次使用会需要几分钟执行安装。&lt;/p&gt;
&lt;p&gt;完成安装后，设置 Ubuntu 用户名（非 root）及密码，正式开启 Ubuntu 系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://docs.microsoft.com/zh-cn/windows/wsl/media/ubuntuinstall.png&#34; alt=&#34;安装&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;移动安装位置可选&#34;&gt;移动安装位置（可选）&lt;/h2&gt;
&lt;p&gt;目前 WSL 不支持设置安装路径，使用一段时间后体积会膨胀到 10G+ ，可以通过开源工具 &lt;a href=&#34;https://github.com/DDoSolitary/LxRunOffline&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LxRunOffline&lt;/a&gt; 实现将 Linux 安装到任意位置，或者将现有 Linux 子系统移动到任意位置。&lt;/p&gt;
&lt;h3 id=&#34;安装-lxrunoffline&#34;&gt;安装 LxRunOffline&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://scoop.sh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Scoop&lt;/a&gt; 是一个 Window 命令行包管理器，可以提供类似 apt/yum 的体验。&lt;/p&gt;
&lt;p&gt;通过 Scoop 安装 LxRunOffline 方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;# 在 Powershell 中执行
set-executionpolicy remotesigned -scope currentuser
iex (new-object net.webclient).downloadstring(&#39;https://get.scoop.sh&#39;)
scoop bucket add extras
scoop install lxrunoffline
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者你可以直接下载安装二进制文件，之后运行 &lt;code&gt;regsvr32 LxRunOfflineShellExt.dll&lt;/code&gt; 完成。&lt;/p&gt;
&lt;h3 id=&#34;移动&#34;&gt;移动&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;# 在 Powershell 中执行
# 查看所有已安装的发行版
lxrunoffline gd

# 移动已存在发行版， 路径格式类似于 D:\wsl\Ubuntu-18.04
LxRunOffline m -n &amp;lt;发行版名称&amp;gt; -d &amp;lt; 路径 &amp;gt;

# 等待一段时间完成移动，查看发行版当前位置
LxRunOffline di -n &amp;lt;发行版名称&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;常用操作&#34;&gt;常用操作&lt;/h2&gt;
&lt;h3 id=&#34;wsl-命令&#34;&gt;wsl 命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;wsl --shutdown&lt;/code&gt;  立即终止所有正在运行的分发和 WSL 2 轻型工具虚拟机&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wsl -t &amp;lt;分发版&amp;gt;&lt;/code&gt; 终止指定的发行版&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wsl -l -v&lt;/code&gt; 列出分发版及其版本信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wsl --export &amp;lt;分发版&amp;gt; &amp;lt; 文件名 &amp;gt;&lt;/code&gt;  将分发导出到 tar 文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wsl --import &amp;lt;分发版&amp;gt; &amp;lt; 安装位置 &amp;gt; &amp;lt; 文件名 &amp;gt; [选项]&lt;/code&gt;  将指定的 tar 文件作为新分发进行导入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，导入导出发行版会导致无法从 Microsoft 应用管理中管理或更新。&lt;/p&gt;
&lt;h3 id=&#34;网络&#34;&gt;网络&lt;/h3&gt;
&lt;p&gt;WSL2 相当于独立虚拟机，而 WSL1 是和 Windows 复用同一个网络的。&lt;/p&gt;
&lt;p&gt;然后和一般宿主机虚拟机略微相反，从 Windows 可以通过 &lt;code&gt;localhost&lt;/code&gt; 访问 WSL 上的服务，反之则不行。&lt;/p&gt;
&lt;p&gt;想要访问 Windows 上的服务，可以使用命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ip route | grep default | awk &#39;{print $3}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者查询 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 中的 &lt;code&gt;nameserver&lt;/code&gt; 获取到 Windows 宿主机的 ip，&lt;/p&gt;
&lt;p&gt;然后通过 ip 访问。&lt;/p&gt;
&lt;h3 id=&#34;文件系统&#34;&gt;文件系统&lt;/h3&gt;
&lt;p&gt;WSL1 的时候，文件目录位于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu: &lt;code&gt;%localappdata%\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ubuntu18.04: &lt;code&gt;%localappdata%\Packages\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\LocalState\rootfs&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;WSL2 可以直接通过 &lt;code&gt;\\wsl$&lt;/code&gt; 在文件管理器中查看到网络位置上的 WSL 虚拟机，Ubuntu 就是 &lt;code&gt;\\wsl$\Ubuntu&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;或者你可以从 WSL2 中直接打开当前目录，直接在终端里调用 &lt;code&gt;explorer.exe .&lt;/code&gt; 就行了，非常 cool~&lt;/p&gt;
&lt;p&gt;Windows 的磁盘在 WSL 中都表示为 &lt;code&gt;/mnt/c|d|e...&lt;/code&gt;，可以看，但是操作还是尽量拷贝到 WSL 目录下，因为性能损失巨大。&lt;/p&gt;
&lt;h2 id=&#34;gpu&#34;&gt;GPU&lt;/h2&gt;
&lt;p&gt;差不多能用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/windows/win32/direct3d12/gpu-cuda-in-wsl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 WSL 2 中启用 NVIDIA CUDA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.nvidia.com/cuda/wsl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CUDA on Windows Subsystem for Linux (WSL) - Public Preview&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考文档&#34;&gt;参考文档&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-cn/windows/wsl/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WSL 文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-cn/windows/wsl/wsl2-faq&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WSL 2 常见问题解答&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Kafka -01- 安装配置</title>
      <link>https://szthanatos.github.io/topic/kafka/install/</link>
      <pubDate>Thu, 06 Dec 2018 10:09:46 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/kafka/install/</guid>
      <description>&lt;h2 id=&#34;环境说明&#34;&gt;环境说明&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;当前版本&lt;/th&gt;
&lt;th&gt;发布日期&lt;/th&gt;
&lt;th&gt;下载地址&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2.0&lt;/td&gt;
&lt;td&gt;2018-07-30&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.apache.org/dyn/closer.cgi?path=/kafka/2.0.0/kafka_2.11-2.0.0.tgz&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方 2.0.0 镜像&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;安装步骤&#34;&gt;安装步骤&lt;/h2&gt;
&lt;p&gt;_** 注意：** 文中以 &lt;code&gt;{}&lt;/code&gt; 包裹起来的内容需要自己替换，并非直接使用_&lt;/p&gt;
&lt;h3 id=&#34;0-环境准备&#34;&gt;0. 环境准备&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;基础环境&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Java&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Java 版本应该在 8(jdk1.8) 或以上，以更好的支持 G1 回收&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;硬件参数&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;CPU: 英特尔至强 E5-2650 v4 &lt;em&gt;2 (共计 24 核) &lt;br&gt;Mem: DDR4 内存 - 32GB&lt;/em&gt; 8 &lt;br&gt;Sto: 2000GB * 8 raid 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;文件路径&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;/home/tools/kafka_2.11-2.0.0/&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;数据存放位置&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;/home/sdb/kafka-logs,/home/sdc/kafka-logs, &lt;br&gt;/home/sdd/kafka-logs,/home/sde/kafka-logs, &lt;br&gt;/home/sdf/kafka-logs,/home/sdg/kafka-logs, &lt;br&gt;/home/sdh/kafka-logs,/home/sdi/kafka-logs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;zookeeper 集群位置&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;10.10.20.83:2181,10.10.20.84:2181,10.10.20.85:2181&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;1-下载安装&#34;&gt;1. 下载安装&lt;/h3&gt;
&lt;p&gt;下载最新版本 Kafka，解压到指定目录，无需其他操作即完成安装。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tar -xzf kafka_2.11-2.0.0.tgz -C /home/tools
cd kafka_2.11-2.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-配置集群参数&#34;&gt;2. 配置集群参数&lt;/h3&gt;
&lt;p&gt;修改 &lt;code&gt;config/server.properties&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;基本参数如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# broker 唯一 id，值为不重复正整数
broker.id={n: int}

# 服务监听地址
listeners=PLAINTEXT://{your.host}:9092

# 日志存放位置列表，以逗号隔开
log.dirs={data.storage.list}

# zookeeper 地址列表，以逗号隔开
zookeeper.connect={zookeeper.server.list}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优化参数配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 消息处理线程数，建议数量为 cpu 核数加 1
num.network.threads=25

# 磁盘 IO 的线程数, 建议为 cpu 核数 2 倍，最大不超过 3 倍
num.io.threads=48

# 拉取线程数，影响 follower 的 I/O 并发度，单位时间内 leader 持有更多请求，相应负载会增大
num.replica.fetchers=2

# 分区数量配置，根据业务情况修改
num.partitions=16

# 消息日志备份数，默认是 1
default.replication.factor=2

# 刷盘 (写入文件到磁盘) 间隔消息数，建议设为 10000
log.flush.interval.messages=10000

# 刷盘间隔毫秒数，建议 1 秒 (1000)
log.flush.interval.ms=1000

# 日志保留小时数
log.retention.hours=48

# 段文件大小，过小会产生很多小文件降低性能，过大会影响快速回收磁盘空间以及 Kafka 重启后的载入速度
og.segment.bytes=1073741824

# 最大字节数，默认 1M，可以调到 5M 以上
replica.fetch.max.bytes=5242880

# 可接受数据大小，受限于 java int 类型的取值范围, 超出后会报 OOM 异常
socket.request.max.bytes=2147483600

# 日志传输时候的压缩格式，可选择 lz4, snappy, gzip, 不压缩。建议打开压缩，可以提高传输性能
compression.type=snappy

# 是否允许通过管理工具删除 topic，默认是 false
delete.topic.enable=true

# 是否允许程序自动创建 Topic
auto.create.topics.enable=false
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-配置日志参数&#34;&gt;3. 配置日志参数&lt;/h3&gt;
&lt;p&gt;修改 &lt;code&gt;config/log4j.properties&lt;/code&gt; 的 jog4j 参数，提高 Kafka 操作日志（和数据日志区分）的日志级别，以降低日志输出相关资源占用。具体可更改配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Kafka2.0 默认只有 controller 是 TRACE 级别，可以改为 INFO，其他 INFO 级别可以适当提升为 WARN

# zookeeper 日志级别，
log4j.logger.org.I0Itec.zkclient.ZkClient=INFO
log4j.logger.org.apache.zookeeper=INFO

# 主日志级别
log4j.logger.kafka=INFO
log4j.logger.org.apache.kafka=INFO

# request 日志级别，只有当需要调试时才有必要输出
log4j.logger.kafka.request.logger=WARN, requestAppender
log4j.additivity.kafka.request.logger=false

# 需要调试时解除以下三行注释，并将 RequestChannel$ 设为 TRACE
# log4j.logger.kafka.network.Processor=TRACE, requestAppender
# log4j.logger.kafka.server.KafkaApis=TRACE, requestAppender
# log4j.additivity.kafka.server.KafkaApis=false
log4j.logger.kafka.network.RequestChannel$=WARN, requestAppender
log4j.additivity.kafka.network.RequestChannel$=false

# controller 日志级别，默认为 TRACE
log4j.logger.kafka.controller=INFO, controllerAppender
log4j.additivity.kafka.controller=false

# 日志清理的日志级别
log4j.logger.kafka.log.LogCleaner=INFO, cleanerAppender
log4j.additivity.kafka.log.LogCleaner=false

log4j.logger.state.change.logger=TRACE, stateChangeAppender
log4j.additivity.state.change.logger=false

# 登陆认证的日志级别
log4j.logger.kafka.authorizer.logger=INFO, authorizerAppender
log4j.additivity.kafka.authorizer.logger=false
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-配置-jvm-参数&#34;&gt;4. 配置 JVM 参数&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Warning&lt;/strong&gt;：谨慎调试&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;bin/kafka-server-start.sh&lt;/code&gt; 文件中调整参数如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 在 base_dir 之后配置参数
base_dir=$(dirname $0)

export KAFKA_HEAP_OPTS=&amp;quot;-Xms6g -Xmx6g -XX:MetaspaceSize=96m -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:G1HeapRegionSize=16M -XX:MinMetaspaceFreeRatio=50 -XX:MaxMetaspaceFreeRatio=80&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;ps：&lt;/strong&gt; 虽然看起来很激进，但是以上配置参照的是 LinkIn 高峰时期最繁忙的集群:&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;60 brokers
50k partitions (replication factor 2)
800k messages/sec in
300 MB/sec inbound, 1 GB/sec+ outbound
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;ps2：&lt;/strong&gt; 这个配置的集群实现了 90% 的 GC 中断时间不超过 21 毫秒，每秒钟新生代 GC 次数不超过一次&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;ps3：&lt;/strong&gt; 上述环境的 Java 版本为 JDK 1.8 u5&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;5-配置-linux-参数&#34;&gt;5. 配置 Linux 参数&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Warning&lt;/strong&gt;：谨慎调试&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 调整系统所有进程一共可以打开的最大文件数：
echo &#39;fs.file-max = 1024000&#39; &amp;gt;&amp;gt; /etc/sysctl.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以及 &lt;code&gt;/etc/security/limits.conf&lt;/code&gt; 末尾增加：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 设置当前 user 以及由它启动的进程的资源限制
{user}      soft    nofile      1024000
{user}      hard    nofile      1024000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;增大 socket buffer size，以提高吞吐性能&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo 212992 &amp;gt;&amp;gt; /proc/sys/net/core/wmem_max
echo 212992 &amp;gt;&amp;gt; /proc/sys/net/core/rmem_max
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;kafka20-官方安装指南&#34;&gt;Kafka2.0 官方安装指南&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://kafka.apache.org/documentation/#quickstart&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quick Start&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 Windows-Terminal 作为终端</title>
      <link>https://szthanatos.github.io/topic/wsl2/coding_with_wsl2_02/</link>
      <pubDate>Sat, 22 Aug 2020 16:41:01 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/wsl2/coding_with_wsl2_02/</guid>
      <description>&lt;p&gt;介绍就两个字，&lt;strong&gt;颜值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/szthanatos/image-host/master/windows-terminal.PNG&#34; alt=&#34;颜值&#34;&gt;&lt;/p&gt;
&lt;p&gt;安装方式同样是 &lt;a href=&#34;https://aka.ms/wslstore&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Microsoft Store&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;默认可以使用 &lt;code&gt;win+r&lt;/code&gt; 输入 &lt;code&gt;wt&lt;/code&gt; 呼出。&lt;/p&gt;
&lt;p&gt;个人使用配置如下，版本号 &lt;code&gt;1.1.2233.0&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    // 默认打开 Ubuntu
    &amp;quot;defaultProfile&amp;quot;: &amp;quot;{2c4de342-38b7-51cf-b940-2309a097f518}&amp;quot;,

    &amp;quot;copyOnSelect&amp;quot;: false,
    &amp;quot;copyFormatting&amp;quot;: false,
    &amp;quot;theme&amp;quot;: &amp;quot;dark&amp;quot;,

    &amp;quot;profiles&amp;quot;: {
        &amp;quot;defaults&amp;quot;: {
            // 开启毛玻璃 (模糊) 效果
            &amp;quot;useAcrylic&amp;quot;: true,
            // 模糊系数 0(透明)-&amp;gt;1(不透明)
            &amp;quot;acrylicOpacity&amp;quot;: 0.75,
            // zsh Powerlevel10k 所用到的字体，详见 shell 配置章节
            &amp;quot;fontFace&amp;quot;: &amp;quot;MesloLGS NF&amp;quot;,
            // 必须显式设置字体大小，不然初次显示会不正常
            &amp;quot;fontSize&amp;quot;: 12,
            // 光标形状
            &amp;quot;cursorShape&amp;quot;:&amp;quot;filledBox&amp;quot;
        },
        &amp;quot;list&amp;quot;: [
            // ...
            {
                // 自己写的一个配色文件
                &amp;quot;colorScheme&amp;quot;: &amp;quot;Sz-dark-material&amp;quot;,
                &amp;quot;guid&amp;quot;: &amp;quot;{2c4de342-38b7-51cf-b940-2309a097f518}&amp;quot;,
                &amp;quot;hidden&amp;quot;: false,
                &amp;quot;name&amp;quot;: &amp;quot;Ubuntu&amp;quot;,
                &amp;quot;source&amp;quot;: &amp;quot;Windows.Terminal.Wsl&amp;quot;,
                // 将起始位置改为用户根目录
                &amp;quot;startingDirectory&amp;quot;: &amp;quot;//wsl$/Ubuntu/home/sz/&amp;quot;
            },
            // ...
        ]
    },
    &amp;quot;schemes&amp;quot;: [
        {
            // 仿 Solarized Dark 的一个配色
            &amp;quot;background&amp;quot;: &amp;quot;#002B36&amp;quot;,
            &amp;quot;black&amp;quot;: &amp;quot;#2C3E50&amp;quot;,
            &amp;quot;blue&amp;quot;: &amp;quot;#396FE2&amp;quot;,
            &amp;quot;brightBlack&amp;quot;: &amp;quot;#34495E&amp;quot;,
            &amp;quot;brightBlue&amp;quot;: &amp;quot;#82AAFF&amp;quot;,
            &amp;quot;brightCyan&amp;quot;: &amp;quot;#89DDFF&amp;quot;,
            &amp;quot;brightGreen&amp;quot;: &amp;quot;#C3E88D&amp;quot;,
            &amp;quot;brightPurple&amp;quot;: &amp;quot;#C792EA&amp;quot;,
            &amp;quot;brightRed&amp;quot;: &amp;quot;#FF5370&amp;quot;,
            &amp;quot;brightWhite&amp;quot;: &amp;quot;#FFFFFF&amp;quot;,
            &amp;quot;brightYellow&amp;quot;: &amp;quot;#FFCB6B&amp;quot;,
            &amp;quot;cyan&amp;quot;: &amp;quot;#2DDAFD&amp;quot;,
            &amp;quot;foreground&amp;quot;: &amp;quot;#ECEFF1&amp;quot;,
            &amp;quot;green&amp;quot;: &amp;quot;#9ECE58&amp;quot;,
            &amp;quot;name&amp;quot;: &amp;quot;Sz-material&amp;quot;,
            &amp;quot;purple&amp;quot;: &amp;quot;#BB80B3&amp;quot;,
            &amp;quot;red&amp;quot;: &amp;quot;#E54B4B&amp;quot;,
            &amp;quot;white&amp;quot;: &amp;quot;#D0D0D0&amp;quot;,
            &amp;quot;yellow&amp;quot;: &amp;quot;#FAED70&amp;quot;
        },
        {
            // Solarized + Campbell
            &amp;quot;background&amp;quot;: &amp;quot;#0C0C0C&amp;quot;,
            &amp;quot;black&amp;quot;: &amp;quot;#2C3E50&amp;quot;,
            &amp;quot;blue&amp;quot;: &amp;quot;#396FE2&amp;quot;,
            &amp;quot;brightBlack&amp;quot;: &amp;quot;#767676&amp;quot;,
            &amp;quot;brightBlue&amp;quot;: &amp;quot;#82AAFF&amp;quot;,
            &amp;quot;brightCyan&amp;quot;: &amp;quot;#89DDFF&amp;quot;,
            &amp;quot;brightGreen&amp;quot;: &amp;quot;#C3E88D&amp;quot;,
            &amp;quot;brightPurple&amp;quot;: &amp;quot;#C792EA&amp;quot;,
            &amp;quot;brightRed&amp;quot;: &amp;quot;#FF5370&amp;quot;,
            &amp;quot;brightWhite&amp;quot;: &amp;quot;#FFFFFF&amp;quot;,
            &amp;quot;brightYellow&amp;quot;: &amp;quot;#FFCB6B&amp;quot;,
            &amp;quot;cyan&amp;quot;: &amp;quot;#2DDAFD&amp;quot;,
            &amp;quot;foreground&amp;quot;: &amp;quot;#ECEFF1&amp;quot;,
            &amp;quot;green&amp;quot;: &amp;quot;#9ECE58&amp;quot;,
            &amp;quot;name&amp;quot;: &amp;quot;Sz-dark-material&amp;quot;,
            &amp;quot;purple&amp;quot;: &amp;quot;#BB80B3&amp;quot;,
            &amp;quot;red&amp;quot;: &amp;quot;#E54B4B&amp;quot;,
            &amp;quot;white&amp;quot;: &amp;quot;#D0D0D0&amp;quot;,
            &amp;quot;yellow&amp;quot;: &amp;quot;#FAED70&amp;quot;
        }
    ],
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他设置详见 &lt;a href=&#34;https://docs.microsoft.com/zh-cn/windows/terminal/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kafka -02- 滚动升级</title>
      <link>https://szthanatos.github.io/topic/kafka/update/</link>
      <pubDate>Sun, 09 Dec 2018 15:19:52 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/kafka/update/</guid>
      <description>&lt;h2 id=&#34;环境说明&#34;&gt;环境说明&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;版本号&lt;/th&gt;
&lt;th&gt;发布日期&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;当前版本&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0.11.0.1&lt;/td&gt;
&lt;td&gt;2017-09-14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;最新版本&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;2.0&lt;/td&gt;
&lt;td&gt;2018-07-30&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;配置文件路径：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/home/tools/kafka_2.12-0.11.0.1/config/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;目标需求：&lt;/strong&gt; 在 Kafka 集群不停机不停止服务的情况下进行升级改造。&lt;/p&gt;
&lt;h2 id=&#34;可能存在的风险&#34;&gt;可能存在的风险&lt;/h2&gt;
&lt;h3 id=&#34;轻微警报&#34;&gt;轻微警报&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;consumer 可能出现偏移量提交失败而造成重复消费&lt;/li&gt;
&lt;li&gt;broker 提示&amp;rsquo;NotLeaderForPartitionException&amp;rsquo;异常&lt;/li&gt;
&lt;li&gt;由于节点下线，可能造成临时性能问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;严重警报&#34;&gt;严重警报&lt;/h3&gt;
&lt;p&gt;严格按照步骤升级，暂未捕捉到严重问题相关信息&lt;/p&gt;
&lt;h2 id=&#34;升级步骤滚动升级&#34;&gt;升级步骤（滚动升级）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;限定通讯协议版本：&lt;/p&gt;
&lt;p&gt;配置 broker 上的 server.properties 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;inter.broker.protocol.version = 0.11.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;依次更新代码并重启 borker：&lt;/p&gt;
&lt;p&gt;一次关闭一个 broker，更新源码，重启&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新通讯协议版本：&lt;/p&gt;
&lt;p&gt;完成所有 broker 节点的源码更新后, 升级协议（方法同上）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;inter.broker.protocol.version = 2.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再次依次重启 broker：&lt;/p&gt;
&lt;p&gt;同上，一次重启一个&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;ps：&lt;/em&gt;&lt;/strong&gt; 如果修改过消息格式版本 (log.message.format.version)，则需要在上面步骤中，同步配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;log.message.format.version = 当前版本 / 要升级的版本
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;替代方案离线升级&#34;&gt;替代方案（离线升级）&lt;/h2&gt;
&lt;p&gt;关闭所有 broker，更新代码并重新启动。默认情况下，自动以新协议开始。&lt;/p&gt;
&lt;h2 id=&#34;kafka20-官方升级指南&#34;&gt;Kafka2.0 官方升级指南&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://kafka.apache.org/documentation/#upgrade&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;upgrade&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Redis 集群相关命令</title>
      <link>https://szthanatos.github.io/topic/redis/02-usage/cluster_command/</link>
      <pubDate>Thu, 30 Aug 2018 21:26:18 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/redis/02-usage/cluster_command/</guid>
      <description>&lt;h2 id=&#34;集群信息&#34;&gt;集群信息&lt;/h2&gt;
&lt;h3 id=&#34;节点信息&#34;&gt;节点信息&lt;/h3&gt;
&lt;p&gt;集群节点相关信息可以通过 &lt;code&gt;cluster nodes&lt;/code&gt; 命令获取：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;127.0.0.1:6379&amp;gt; cluster nodes
5022fa41642195d74200fd512c08653dc12609e7 172.17.0.2:6380@16380 master - 0 1552814467000 2 connected 5461-10922
730d05ee4da3147d0885c6d47437465c94409f74 172.17.0.2:6383@16383 slave 25a2a1d8c96e9473d4cb3c8b0077d3b7b07dd5c0 0 1552814468555 5 connected
25a2a1d8c96e9473d4cb3c8b0077d3b7b07dd5c0 172.17.0.2:6379@16379 myself,master - 0 1552814468000 1 connected 0-5460
cf0be45c6a05c0d332b7356a7f57de95b32c3a71 172.17.0.2:6384@16384 slave 5022fa41642195d74200fd512c08653dc12609e7 0 1552814468654 6 connected
55d264b148ce35903928964ac017d682fc803eab 172.17.0.2:6381@16381 master - 0 1552814468000 3 connected 10923-16383
1a60baf4c2254b2e3a37cf6215d42b316ffdccc7 172.17.0.2:6382@16382 slave 55d264b148ce35903928964ac017d682fc803eab 0 1552814468000 4 connected
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，每一行即是一个节点的信息，以第一行为例，每个字段的含义分别是：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;502&amp;hellip;&amp;hellip;9e7&lt;/td&gt;
&lt;td&gt;node_id，节点标识&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;172.17.0.2:6380@16380&lt;/td&gt;
&lt;td&gt;IP 端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;master&lt;/td&gt;
&lt;td&gt;身份，一般就是 &lt;code&gt;myself/master/slave&lt;/code&gt;，其他 &lt;code&gt;fail?/handshake/noaddr/noflags&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;对应主节点的 node_id(如果你是从节点的话，否则就是 &lt;code&gt;-&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt; 表示没有待发送的 &lt;code&gt;ping&lt;/code&gt;，否则是要发送 &lt;code&gt;ping&lt;/code&gt; 的时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1552814467000&lt;/td&gt;
&lt;td&gt;收到上一个 &lt;code&gt;pong&lt;/code&gt; 命令的时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;权重&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;connected&lt;/td&gt;
&lt;td&gt;状态，&lt;code&gt;connected&lt;/code&gt;or&lt;code&gt;disconnected&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5461-10922&lt;/td&gt;
&lt;td&gt;哈希槽，连续的哈希槽用 &lt;code&gt;-&lt;/code&gt; 连接，离散的用 &lt;code&gt;,&lt;/code&gt; 隔开&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;状态信息&#34;&gt;状态信息&lt;/h3&gt;
&lt;p&gt;集群信息通过 &lt;code&gt;cluster info&lt;/code&gt; 获取：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;127.0.0.1:6379&amp;gt; cluster info
# 集群状态
cluster_state:ok
# 已分配的哈希槽数量，不是 16384 就有问题了
cluster_slots_assigned:16384
# 正确的哈希槽数量，如果有哈希槽分配到了离线的节点上就不是这个数字了
cluster_slots_ok:16384
# 临时错误哈希槽数，比如网络波动但节点还是正常的，那就是 pfail，节点确认离线了就是 fail
cluster_slots_pfail:0
cluster_slots_fail:0
# 集群节点数
cluster_known_nodes:6
# 集群规模
cluster_size:3
# 当前最大权重
cluster_current_epoch:6
# 本节点的权重
cluster_my_epoch:1
# 集群建立至今发送 / 接受的 ping/pong/meet 消息数
cluster_stats_messages_ping_sent:1554
cluster_stats_messages_pong_sent:1558
cluster_stats_messages_sent:3112
cluster_stats_messages_ping_received:1553
cluster_stats_messages_pong_received:1554
cluster_stats_messages_meet_received:5
cluster_stats_messages_received:3112
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;集群操作&#34;&gt;集群操作&lt;/h2&gt;
&lt;p&gt;就不挨个详述了，写了个速查表如下，全部命令详见 &lt;a href=&#34;https://redis.io/commands&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;redis 官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;信息&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster info&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回集群基本信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster nodes&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回全部节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;控制&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster count-failure-reports &amp;lt;node_id&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回节点的错误报告数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster failover [FORCE/TAKEOVER]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在从节点上执行，测试故障转移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster set-config-epoch &amp;lt;config-epoch&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;为新节点设置权重&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster saveconfig&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将节点的配置文件保存到硬盘里面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster reset [HARD/SOFT]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;重置没有 key 的当前节点 (所以应该先 flushall)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster readonly&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将从节点置为可读 (默认情况下，指向从节点的连接会被转向主节点)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster readwrite&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将从节点置为读写 (相当于还原为 &lt;code&gt;readonly&lt;/code&gt; 之前的状态)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;节点&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster meet &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将节点加入集群作为主节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster replicate &amp;lt;node_id&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将当前节点作为 &amp;lt; node_id &amp;gt; 的从节点加入集群&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster replicas &amp;lt;node_id&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;redis5.0 开始支持，列出指定主节点的从节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster slaves &amp;lt;node_id&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;不再建议被使用，基本同 replicas&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster replicaof &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;redis5.0 开始支持，将当前节点置为指定节点的从节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster slaveof &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;不再建议被使用，基本同 replicaof&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster forget &amp;lt;node_id&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;从集群中移除 &amp;lt; node_id &amp;gt; 节点（前提是没给他分配哈希槽 / 内容）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;哈希槽&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster addslots &amp;lt;slot&amp;gt;,...&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将一个或多个哈希槽添加到当前节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster delslots  &amp;lt;slot&amp;gt;,...&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;从当前节点移除哈希槽&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster flushslots&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;清空当前节点的哈希槽&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster setslot &amp;lt;slot&amp;gt; node &amp;lt;node_id&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将 &lt;strong&gt;未分配的&lt;/strong&gt; 哈希槽分配给指定节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster setslot &amp;lt;slot&amp;gt; migrating &amp;lt;node_id&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将本节点的哈希槽合并到指定节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster setslot &amp;lt;slot&amp;gt; importing &amp;lt;node_id&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;从指定节点引入哈希槽到本节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster setslot &amp;lt;slot&amp;gt; stable&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;取消哈希槽的移动，&lt;em&gt;主要是修复 &lt;code&gt;redis-trib fix&lt;/code&gt; 引发的问题←_←&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster flushslots&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;清空当前节点的哈希槽&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster flushslots&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;清空当前节点的哈希槽&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;键&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster keyslot &amp;lt;key&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;计算 key 应该被放在哪个槽&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster countkeysinslot &amp;lt;slot&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回哈希槽中 key 的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster getkeysinslot &amp;lt;slot&amp;gt; &amp;lt;count&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;从哈希槽中返回指定数量个 key&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;strong&gt;ps1&lt;/strong&gt;：从 redis5.0 起，&lt;code&gt;slave&lt;/code&gt; 关键字将被 &lt;code&gt;replicate&lt;/code&gt; 取代，相关命令也会逐步被替代
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;ps2&lt;/strong&gt;：&lt;code&gt;readonly&lt;/code&gt; 这个额外说一下，默认情况下，redis 的从节点不处理客户端请求，只负责同步主节点的数据，设置 &lt;code&gt;readonly&lt;/code&gt; 之后，指向从节点的读请求会被执行，这样相当于为主节点分担了读的压力 (也算是 scale 了)，但是还是存在两个限制：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写请求还是会转移给主节点；&lt;/li&gt;
&lt;li&gt;要读的 key 的哈希槽不属于这个节点，请求一样会被转移；&lt;/li&gt;
&lt;/ol&gt;
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 易用性配置</title>
      <link>https://szthanatos.github.io/topic/wsl2/coding_with_wsl2_03/</link>
      <pubDate>Sat, 22 Aug 2020 16:41:03 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/wsl2/coding_with_wsl2_03/</guid>
      <description>&lt;h2 id=&#34;启用-root-用户&#34;&gt;启用 root 用户&lt;/h2&gt;
&lt;p&gt;ubuntu 默认没有 root 密码，使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo passwd root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置 root 密码&lt;/p&gt;
&lt;h2 id=&#34;配置国内镜像源&#34;&gt;配置国内镜像源&lt;/h2&gt;
&lt;p&gt;更换 &lt;code&gt;/etc/apt/sources.list&lt;/code&gt; 为:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse

# 预发布软件源，不建议启用
# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以使用 &lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;清华大学镜像源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意我这里 Ubuntu 版本是 20.04(focal)。&lt;/p&gt;
&lt;p&gt;关于 Ubuntu 源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;按软件自由度区分：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;源&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;main&lt;/td&gt;
&lt;td&gt;完全的自由软件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;restricted&lt;/td&gt;
&lt;td&gt;不完全的自由软件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;universe&lt;/td&gt;
&lt;td&gt;ubuntu 官方不提供支持与补丁，全靠社区支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;muitiverse&lt;/td&gt;
&lt;td&gt;非自由软件，完全不提供支持和补丁&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按使用目的区分：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;源&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;security&lt;/td&gt;
&lt;td&gt;仅修复漏洞，并且尽可能少的改变软件包的行为，低风险&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;update&lt;/td&gt;
&lt;td&gt;修复严重但不影响系统安全运行的漏洞，低风险&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;proposed&lt;/td&gt;
&lt;td&gt;pre-update，仅建议提供测试和反馈的人进行安装&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;backports&lt;/td&gt;
&lt;td&gt;不会由 Ubuntu-security-team 审查和更新 (但是可能对你有用)，存在风险&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;添加第三方源-可选&#34;&gt;添加第三方源 (可选)&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# git
sudo add-apt-repository ppa:git-core/ppa

# python
sudo add-apt-repository ppa:deadsnakes/ppa

# 更新
sudo apt update
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;配置-ssh&#34;&gt;配置 ssh&lt;/h2&gt;
&lt;p&gt;修改 &lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# port 为大于 1024 的任意端口（不能是 22 是因为 WSL 和 win10 共用端口且 win10 的优先级更高，win10 内置 SSH Server For Windows 已经占用 22 端口, 大于 1024 是为了避开其他系统服务）
Port 2333

# 允许使用用户名密码方式访问
PasswordAuthentication yes

# (可选) 允许 root 访问 (任何认证方式 / 只允许 public key 认证方式 / 不允许任何认证方式)
PermitRootLogin yes/without-password/no
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存，执行以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 生成密钥
dpkg-reconfigure openssh-server

# 重启 ssh
sudo service ssh restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成 ssh 配置。&lt;/p&gt;
&lt;p&gt;早期版本需要重装 &lt;code&gt;openssh-server&lt;/code&gt;，但是最近直接使用没发现问题。&lt;/p&gt;
&lt;h2 id=&#34;开机自启后台服务-可选&#34;&gt;开机自启后台服务 (可选)&lt;/h2&gt;
&lt;p&gt;在 Wsl 早期，想要使用 Wsl 上的 Python 解释器或者别的工具需要通过 &lt;code&gt;ssh&lt;/code&gt; 从宿主机连接，而 Wsl 没有 &lt;code&gt;Systemd&lt;/code&gt; 也没法开机自启。&lt;/p&gt;
&lt;p&gt;通过计划任务实现开机启动 Wsl 上的 ssh 服务是一种刚需。&lt;/p&gt;
&lt;p&gt;不过现在 Docker 也好，Pycharm 也好，都直接从软件层面支持 Wsl 了，需要 ssh 的场合不多（雾）。&lt;/p&gt;
&lt;p&gt;不过 * 2，网上存在的教程都告诉你要在 Ubuntu 写个 shell 脚本，再在 Windows 下写个 vb 脚本，再去创建一个计划任务&amp;hellip;.&lt;/p&gt;
&lt;p&gt;直接计划任务一句话搞定不香么？黑人问号. jpg&lt;/p&gt;
&lt;p&gt;还是以 ssh 服务为例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;root 身份编辑 &lt;code&gt;/etc/sudoers&lt;/code&gt; 文件，&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;%sudo   ALL=(ALL:ALL) ALL&lt;/code&gt; 下新增一行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%sudo   ALL=(ALL) NOPASSWD: /usr/sbin/service ssh *&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;避免 sudo 启动 ssh 需要密码的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 windows 搜索栏搜索 &lt;code&gt;计划任务&lt;/code&gt;，或者快速运行窗口输入 &lt;code&gt;taskschd.msc&lt;/code&gt;，打开任务计划程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/szthanatos/image-host/master/task-scheduler.png&#34; alt=&#34;计划任务&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建任务，勾选 &lt;code&gt;隐藏&lt;/code&gt;，配置改为 win10&lt;/p&gt;
&lt;p&gt;触发器选 &lt;code&gt;计算机启动时&lt;/code&gt; 或者 &lt;code&gt;当前用户登录时&lt;/code&gt;，可以配置延迟启动;&lt;/p&gt;
&lt;p&gt;操作是 &lt;code&gt;启动程序&lt;/code&gt;，程序或脚本选 &lt;code&gt;C:\Windows\System32\wsl.exe&lt;/code&gt;，添加参数写 &lt;code&gt;-d Ubuntu -u {Ubuntu 用户名} sudo service ssh start&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;(可选) 条件中取消勾选 &lt;code&gt;只有计算机在使用交流电时才启动此任务&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;(可选) 设置中勾选 &lt;code&gt;允许按需允许任务&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;完成&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其他需要后台启动的服务类似配置。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 Zsh 作为默认 shell</title>
      <link>https://szthanatos.github.io/topic/wsl2/coding_with_wsl2_04/</link>
      <pubDate>Sat, 22 Aug 2020 16:41:05 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/wsl2/coding_with_wsl2_04/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;// TODO 吹一下 zsh&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;安装-zsh&#34;&gt;安装 zsh&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 安装 zsh
sudo apt install zsh -y

# 修改默认 shell 为 zsh
sudo chsh -s /bin/zsh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启 wsl，或者干脆重启电脑生效。&lt;/p&gt;
&lt;h2 id=&#34;安装-oh-my-zsh&#34;&gt;安装 oh-my-zsh&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh -c &amp;quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可能需要代理。&lt;/p&gt;
&lt;h2 id=&#34;安装-zsh-插件&#34;&gt;安装 zsh 插件&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 安装 powerlevel10k 主题
git clone --depth=1 https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10k

# 安装语法高亮 zsh-syntax-highlighting
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting

# 安装自动建议 zsh-autosuggestions
git clone git://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从 win10 下载并安装以下字体，以获得 powerlevel10k 主题更好的显示效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/romkatv/powerlevel10k-media/master/prompt-styles-high-contrast.png&#34; alt=&#34;powerlevel10k&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Regular.ttf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MesloLGS NF Regular.ttf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold.ttf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MesloLGS NF Bold.ttf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Italic.ttf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MesloLGS NF Italic.ttf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold%20Italic.ttf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MesloLGS NF Bold Italic.ttf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置-zsh&#34;&gt;配置 zsh&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;.zshrc&lt;/code&gt; 中编辑以下部分：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# （可选）允许其他用户共用你的配置不弹出警告
ZSH_DISABLE_COMPFIX=&amp;quot;true&amp;quot;

# 默认情况下，zsh 会试图在低优先级运行后台任务，但是 Windows 不允许，所以将以下内容添加到. zshrc 文件开头可以改变 zsh 的行为
case $(uname -a) in
  *Microsoft*) unsetopt BG_NICE ;;
esac

# 启用 powerlevel10k 主题
ZSH_THEME=&amp;quot;powerlevel10k/powerlevel10k&amp;quot;

# 启用插件
plugins=(
  # 按 z+{模糊文件夹名称} 快速跳转
  z
  # git 补全
  git
  # 忘了加 sudo 的时候按两下 esc
  sudo
  # docker 补全
  docker
  docker-compose
  # 按 x 解压任意类型压缩包
  extract
  # 彩色 man 手册
  colored-man-pages
  zsh-autosuggestions
  zsh-syntax-highlighting
)

# 配置终端颜色
export TERM=&amp;quot;xterm-256color&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入 &lt;code&gt;source .zshrc&lt;/code&gt; 让配置生效，&lt;/p&gt;
&lt;p&gt;输入 &lt;code&gt;p10k configure&lt;/code&gt; 配置 Powerlevel10k 主题设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/romkatv/powerlevel10k-media/master/configuration-wizard.gif&#34; alt=&#34;p10k configure&#34;&gt;&lt;/p&gt;
&lt;p&gt;完成后，拷贝 &lt;code&gt;.zshrc&lt;/code&gt; 和 &lt;code&gt;.p10k.zsh&lt;/code&gt; 文件到 root 用户根目录下，让 root 也使用相同配置，当然也可以分别设置。&lt;/p&gt;
&lt;h2 id=&#34;一键启用--停用代理&#34;&gt;一键启用 / 停用代理&lt;/h2&gt;
&lt;p&gt;Linux 下配置代理本来就略麻烦，Wsl2 又是完整的虚拟机，每次重启内部网络都会重新生成&amp;hellip; 换句话说每次 Windows 和 Linux 的内网 IP 都在变化&amp;hellip;&lt;/p&gt;
&lt;p&gt;不过还是能配置好的。&lt;/p&gt;
&lt;p&gt;将以下内容加入到你的 &lt;code&gt;.zshrc&lt;/code&gt; 文件中，将 &lt;code&gt;20809&lt;/code&gt; 改为你的代理的端口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;proxyon() {
  local host_ip=$(cat /etc/resolv.conf |grep &amp;quot;nameserver&amp;quot; |cut -f 2 -d &amp;quot; &amp;quot;)
  export ALL_PROXY=&amp;quot;http://${host_ip}:20809&amp;quot;
  export all_proxy=&amp;quot;http://${host_ip}:20809&amp;quot;
  echo -e &amp;quot;Acquire::http::Proxy \&amp;quot;http://${host_ip}:20809\&amp;quot;;&amp;quot; | sudo tee -a /etc/apt/apt.conf &amp;gt; /dev/null
  echo -e &amp;quot;Acquire::https::Proxy \&amp;quot;http://${host_ip}:20809\&amp;quot;;&amp;quot; | sudo tee -a /etc/apt/apt.conf &amp;gt; /dev/null
  curl ip.sb
}

proxyoff() {
  unset ALL_PROXY
  unset all_proxy
  sudo sed -i -e &#39;/Acquire::http::Proxy/d&#39; /etc/apt/apt.conf
  sudo sed -i -e &#39;/Acquire::https::Proxy/d&#39; /etc/apt/apt.conf
  curl ip.sb
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行 &lt;code&gt;proxy&lt;/code&gt; 即可开启代理，&lt;code&gt;wget&lt;/code&gt;，&lt;code&gt;curl&lt;/code&gt;，&lt;code&gt;git&lt;/code&gt;，&lt;code&gt;apt&lt;/code&gt; 都会走代理。&lt;/p&gt;
&lt;p&gt;执行 &lt;code&gt;unproxy&lt;/code&gt; 关闭。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ohmyz.sh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Oh My ZSH 官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/romkatv/powerlevel10k&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;powerlevel10k 项目主页&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Redis 单机 &amp; 集群安装</title>
      <link>https://szthanatos.github.io/topic/redis/03-operation/install/</link>
      <pubDate>Thu, 30 Aug 2018 16:40:48 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/redis/03-operation/install/</guid>
      <description>&lt;h2 id=&#34;版本&#34;&gt;版本&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;软件&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;th&gt;更新日期&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://download.redis.io/releases/redis-4.0.11.tar.gz&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Redis&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;4.0.11&lt;/td&gt;
&lt;td&gt;2018-08-03&lt;/td&gt;
&lt;td&gt;必装&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cache.ruby-lang.org/pub/ruby/2.5/ruby-2.5.1.tar.gz&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ruby&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2.5.1&lt;/td&gt;
&lt;td&gt;2018-03-28&lt;/td&gt;
&lt;td&gt;可选, 集群执行 rb 脚本的节点安装即可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://rubygems.org/rubygems/rubygems-2.7.7.tgz&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;rubygem&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2.7.7&lt;/td&gt;
&lt;td&gt;2018-05-18&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://rubygems.org/downloads/redis-4.0.2.gem&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gem-redis&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;4.0.2&lt;/td&gt;
&lt;td&gt;2018-08-13&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;以 CentOS 7 为例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从上述链接下载 redis 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装环境依赖 &lt;code&gt;yum install -y gcc gcc-c++ tcl&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tar -xvzf {redis.tar.gz}&lt;/code&gt; 解压&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入 redis 目录，执行 &lt;code&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt; 进行安装&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果 make 出错，通过 make test 检查：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尝试只用单核运行：&lt;code&gt;taskset -c 1 sudo make test&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;更改 &lt;code&gt;tests/integration/replication-psync.tcl&lt;/code&gt; 文件, 把对应报错的那段代码中的 &lt;code&gt;after 100&lt;/code&gt; 改成 &lt;code&gt;after 500&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;完成单节点安装&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;默认配置文件为位于 redis 目录下的 &lt;code&gt;redis.conf&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;最小配置&#34;&gt;最小配置&lt;/h3&gt;
&lt;p&gt;一个最小的 redis.conf 配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 节点监听的端口号
port {your_port}
# 是否以进程守护方式 (后台) 运行
daemonize yes
# 允许访问的 IP 地址，设置为 0.0.0.0 的时候可以从任意 IP 访问 redis，多个 ip 用逗号隔开
bind {your_ip}
# 工作目录，数据存放位置
dir {your_dir}
# 进程文件名称，固定为 redis_监听的端口号. pid
pidfile /var/run/redis_{your_port}.pid
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成以上配置即可启动单节点 redis。&lt;/p&gt;
&lt;h3 id=&#34;集群配置&#34;&gt;集群配置&lt;/h3&gt;
&lt;p&gt;集群需要在 redis.conf 中配置以下部分：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 以集群模式启动
cluster-enabled yes
# 集群配置存放的文件名，一般为 node - 端口号. conf
cluster-config-file nodes-{port}.conf
# 集群超时
cluster-node-timeout 15000
# 是否启用 aof 方式持久化，建议开启
appendonly yes
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;启动&#34;&gt;启动&lt;/h2&gt;
&lt;h3 id=&#34;防火墙&#34;&gt;防火墙&lt;/h3&gt;
&lt;p&gt;redis 需要使用指定端口号以及指定端口号 + 10000 进行通讯，以 6379 端口为例，如果开启了防火墙，需要执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;firewall-cmd --zone=public --add-port=6379/tcp --permanent
firewall-cmd --zone=public --add-port=16379/tcp --permanent
firewall-cmd --reload
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;单结点启动&#34;&gt;单结点启动&lt;/h3&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;redis-server {dir}/redis.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动 redis&lt;/p&gt;
&lt;h3 id=&#34;集群启动&#34;&gt;集群启动&lt;/h3&gt;
&lt;h4 id=&#34;ruby-环境&#34;&gt;ruby 环境&lt;/h4&gt;
&lt;p&gt;redis 集群是通过 Ruby 编写的脚本进行联通的（但不需要在每隔节点都执行），所以集群中起码一个节点，应该具备 ruby 环境、rubygem 包管理软件、rubygem 中的 redis 包。&lt;/p&gt;
&lt;p&gt;ruby 环境搭建过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;yum 安装 ruby 环境及包&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yum -y install ruby ruby-devel rubygems
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 ruby 源，使用国内镜像&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/
# 如果修改失败将 https 换为 http 重试
gem sources --add http://gems.ruby-china.org/ --remove http://rubygems.org/
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查源列表，确保只有 gems.ruby-china.org&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gem sources -l
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装 ruby 的 redis 包：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gem install redis
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;联通集群&#34;&gt;联通集群&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;启动所有节点上的 redis 服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入 redis 安装路径下 src 文件夹，执行集群命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# --replicas 1 表示主从复制比例为 1:1，即一个主节点对应一个从节点
./redis-trib.rb create --replicas 1 {node1_ip:port} {node2_ip:port} ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认会自动分配主从节点，确认的话输入 &lt;code&gt;yes&lt;/code&gt; 完成集群的创建&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;检查集群状态&#34;&gt;检查集群状态&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# -c 表示连接的是集群
redis-cli -c -h {ip} -p {port}
# 查看集群节点
&amp;gt; cluster nodes
# 查看集群信息
&amp;gt; cluster info
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;相关命令&#34;&gt;相关命令&lt;/h2&gt;
&lt;p&gt;除了使用 rb 脚本，其实可以直接在 redis 节点上 &lt;a href=&#34;https://szthanatos.github.io/post/redis/redis_command.md&#34;&gt;通过命令操作集群&lt;/a&gt;，个人更推荐这个做法。&lt;/p&gt;
&lt;p&gt;主要用到的是&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;谨慎使用 rb 脚本对 redis 进行修复，从来没修复成功过&amp;hellip;&lt;/p&gt;
&lt;p&gt;它还会把你的哈希槽按顺序平均分配到所有节点上，本来可能是 A 节点管理 0-6000，B 节点 6001-12000&amp;hellip;fix 完了之后就成了 A 节点：1，3，5，7&amp;hellip; 终端都被坑到无法阅读了。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;附注&#34;&gt;附注&lt;/h2&gt;
&lt;h3 id=&#34;离线安装-redis-环境&#34;&gt;离线安装 redis 环境&lt;/h3&gt;
&lt;p&gt;离线情况需要本地下载如下 rpm 包 (版本号以最新为准):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cpp-4.8.5-16.el7.x86_64.rpm
gcc-4.8.5-16.el7.x86_64.rpm
gcc-c++-4.8.5-16.el7.x86_64.rpm
glibc-2.17-196.el7.i686.rpm
glibc-2.17-196.el7.x86_64.rpm
glibc-common-2.17-196.el7.x86_64.rpm
glibc-devel-2.17-196.el7.x86_64.rpm
glibc-headers-2.17-196.el7.x86_64.rpm
libgcc-4.8.5-16.el7.i686.rpm
libgcc-4.8.5-16.el7.x86_64.rpm
libgomp-4.8.5-16.el7.i686.rpm
libgomp-4.8.5-16.el7.x86_64.rpm
libstdc++-4.8.5-16.el7.i686.rpm
libstdc++-4.8.5-16.el7.x86_64.rpm
libstdc++-devel-4.8.5-16.el7.i686.rpm
libstdc++-devel-4.8.5-16.el7.x86_64.rpm
nspr-4.13.1-1.0.el7_3.x86_64.rpm
nss-softokn-freebl-3.28.3-8.el7_4.i686.rpm
nss-softokn-freebl-3.28.3-8.el7_4.x86_64.rpm
tcl-8.5.13-8.el7.i686.rpm
tcl-8.5.13-8.el7.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;如果-gem-安装-redis-包时提示-ruby-版本太低&#34;&gt;如果 gem 安装 redis 包时，提示 ruby 版本太低&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;卸载 yum 过时的 ruby 环境&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yum remove ruby ruby-devel rubygems
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载 &lt;a href=&#34;https://www.ruby-lang.org/en/downloads/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ruby&lt;/a&gt; 源码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压，编译安装:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tar -zxvf {latest_ruby.tar.gz}
cd {latest_ruby}
./configure
make
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载 &lt;a href=&#34;https://rubygems.org/pages/download&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gem&lt;/a&gt; 源码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压，安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tar -zxvf {latest_rubygem.tgz}
cd {latest_rubygem}
ruby setup.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重新 &lt;code&gt;gem install redis&lt;/code&gt; 或者离线下载 &lt;a href=&#34;https://rubygems.org/downloads/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gem-redis&lt;/a&gt; 的包，本地安装&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>使用 tmux 复用终端</title>
      <link>https://szthanatos.github.io/topic/wsl2/coding_with_wsl2_05/</link>
      <pubDate>Sat, 22 Aug 2020 17:53:59 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/wsl2/coding_with_wsl2_05/</guid>
      <description>&lt;p&gt;Tmux 是一个终端复用软件。比如你开一个 terminal 窗口，相当于和本地的或远程的 Linux 建立了一次会话连接。&lt;/p&gt;
&lt;p&gt;如果你想多做几件事，比如一个窗口运行服务，一个窗口运行客户端，对不起，你得再开一个窗口，再建立一个连接。&lt;/p&gt;
&lt;p&gt;tmux 就是解决这个问题的工具，它可以让你的终端 (Terminal) 给复用 (mux) 了，在一次连接里面做无数多件不同的事情。&lt;/p&gt;
&lt;p&gt;Ubuntu 自带 Tmux，无需额外安装。&lt;/p&gt;
&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/szthanatos/image-host/master/tmux.jpg&#34; alt=&#34;tmux&#34;&gt;&lt;/p&gt;
&lt;p&gt;Tmux 有这么几个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Session：输入 tmux 后就创建了一个会话，一个会话是一组窗体的集合。&lt;/li&gt;
&lt;li&gt;Window：会话中一个可见的窗口，你的屏幕一次只会看到一个窗口的内容。&lt;/li&gt;
&lt;li&gt;Pane: 一个窗口可以分成多个窗格。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 tmux 的过程可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制模式（按下或者按住前缀 (tmux-prefix)，默认 ctrl+b, 下文用※表示），也就是用快捷键执行动作；&lt;/li&gt;
&lt;li&gt;命令模式（输入 tmux 后接命令），执行内部命令，好理解；&lt;/li&gt;
&lt;li&gt;一般模式，就是把窗格内的东西当一般 terminal 用；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;添加配置文件 &lt;code&gt;.tmux.conf&lt;/code&gt;，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;#-- base --#
# (可选) 设置 zsh 为默认 shell
set -g default-shell /bin/zsh

#-- settings --#
# 开启鼠标切换窗格，按住 shift 复制粘贴
set -g mouse on
# 窗口编号从 1 开始计数
set -g base-index 1
# 关掉某个窗口后，编号重排
set -g renumber-windows on
# 窗格编号从 1 开始计数
set -g pane-base-index 1
# PREFIX-Q 显示编号的驻留时长，单位 ms
set -g display-panes-time 5000
# 进入复制模式的时候使用 vi 键位（默认是 EMACS）
setw -g mode-keys vi
# 禁止活动进程修改窗口名
# setw -g allow-rename off
# 禁止自动命名新窗口
setw -g automatic-rename off
# 开启 256 colors 支持
set -g default-terminal &amp;quot;tmux-256color&amp;quot;

#-- bindkeys --#
# 以下 3 行设置 ctrl+x 代替 ctrl+b 的快捷键
set -g prefix C-x
unbind C-b
bind C-x send-prefix

# 设置 tmux-prefix + \ 垂直分割窗格
unbind %
bind \\ split-window -h
# 设置 tmux-prefix + - 水平分割窗格
unbind &#39;&amp;quot;&#39;
bind - split-window -v

# 设置 ctrl+vim 方式切换窗格
bind -n C-h select-pane -L
bind -n C-j select-pane -D
bind -n C-k select-pane -U
bind -n C-l select-pane -R
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了这个配置文件立刻就能生效。&lt;/p&gt;
&lt;h2 id=&#34;常用操作&#34;&gt;常用操作&lt;/h2&gt;
&lt;p&gt;下面用 &lt;code&gt;※&lt;/code&gt; 代表 tmux 前缀，也就是 &lt;code&gt;ctrl+x&lt;/code&gt;，默认是 &lt;code&gt;ctrl+b&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;鼠标&#34;&gt;鼠标&lt;/h3&gt;
&lt;p&gt;tmux 中执行有些正常 terminal 中的鼠标操作需要按住 &lt;code&gt;shift&lt;/code&gt;，多试试。&lt;/p&gt;
&lt;p&gt;窗格的分割线可以直接用鼠标拖动。&lt;/p&gt;
&lt;h3 id=&#34;命令&#34;&gt;命令&lt;/h3&gt;
&lt;h4 id=&#34;会话&#34;&gt;会话&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tmux&lt;/code&gt; 新建无名称会话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tmux new -s demo&lt;/code&gt; 新建名称为 demo 的会话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tmux detach&lt;/code&gt; 断开当前会话，既※ + d&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tmux a&lt;/code&gt; 默认进入第一个会话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tmux a -t demo&lt;/code&gt; 进入到名称为 demo 的会话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tmux list-session&lt;/code&gt; 查看所有会话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tmux ls&lt;/code&gt; 同上，简写&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;结束&#34;&gt;结束&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tmux kill-server&lt;/code&gt; 关闭服务器，所有的会话都将关闭&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tmux kill-session -t demo&lt;/code&gt; 关闭 demo 会话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tmux kill-window&lt;/code&gt; 关闭窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tmux kill-pane&lt;/code&gt; 关闭窗格&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;控制&#34;&gt;控制&lt;/h3&gt;
&lt;h4 id=&#34;会话-session&#34;&gt;会话 (Session)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;※ + d&lt;/code&gt; 休眠&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + s&lt;/code&gt; 以菜单方式显示和选择会话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + L&lt;/code&gt; 切换回上一次的会话&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;窗口-windows&#34;&gt;窗口 (Windows)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;※ + c&lt;/code&gt; 创建新窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + n&lt;/code&gt; 选择下一个窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + p&lt;/code&gt; 选择前一个窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + l&lt;/code&gt; 最近一次活跃窗口之间进行切换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + 0~9&lt;/code&gt; 选择几号窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + ,&lt;/code&gt; 重命名窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + .&lt;/code&gt; 更改窗口的编号，但只能更改成未使用的编号，所以要交换窗口的话，得更改多次进行交换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + &amp;amp;&lt;/code&gt; 关闭窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + w&lt;/code&gt; 以菜单方式显示及选择窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + f&lt;/code&gt; 在所有窗口中查找内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;窗格-pane&#34;&gt;窗格 (Pane)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;※ + z&lt;/code&gt; 最大化 / 还原当前窗格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + &amp;quot;&lt;/code&gt; 模向分隔窗格，替换为了 -&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + %&lt;/code&gt; 纵向分隔窗格，替换为了 \&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + o&lt;/code&gt; 跳到下一个分隔窗格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + x&lt;/code&gt; 关闭窗格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + ;&lt;/code&gt; 切换到最后一个使用的窗格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + 上下键&lt;/code&gt; 上一个及下一个分隔窗格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;※ + 空格键&lt;/code&gt; 切换窗格布局&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tmux-插件&#34;&gt;tmux 插件&lt;/h2&gt;
&lt;p&gt;之前还用过一段时间 Tmux 的插件，后来发现需要长期停留在 Tmux 的时候很少，所以后面没用了，&lt;/p&gt;
&lt;p&gt;配置文件还是放出来留给有缘人：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# plugins
# tmux plugin manager 插件管理
set -g @plugin &#39;tmux-plugins/tpm&#39;
set -g @plugin &#39;tmux-plugins/tmux-sensible&#39;
# 保存布局插件，tmux-prefix + ctrl+s/tmux-prefix + ctrl+r 保存 / 恢复
set -g @plugin &#39;tmux-plugins/tmux-resurrect&#39;
# 自动保存插件
set -g @plugin &#39;tmux-plugins/tmux-continuum&#39;

# tmux-resurrect 配置
# 恢复 shell 的历史记录, 只有无前台任务运行的窗格 才能被保存
set -g @resurrect-save-bash-history &#39;on&#39;
# 恢复窗格内容, 目前使用该功能时，请确保 tmux 的 default-command 没有包含 &amp;amp;&amp;amp; 或者 || 操作符，
# 否则将导致 bug。（查看 default-command 的值，请使用命令 tmux show -g default-command。）
set -g @resurrect-capture-pane-contents &#39;on&#39;
# 恢复 vim 会话
set -g @resurrect-strategy-vim &#39;session&#39;

# set -g @resurrect-save &#39;S&#39;
# set -g @resurrect-restore &#39;R&#39;

# tmux-continuum 配置
# 开启自动恢复
set -g @continuum-restore &#39;on&#39;
# 设置备份间隔（分钟，0 为不自动备份）
set -g @continuum-save-interval &#39;240&#39;
# 状态栏查看备份状态
# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)
set -g status-right &#39;Continuum status: #{continuum_status}&#39;

run &#39;/etc/.tmux/plugins/tpm/tpm&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tpm 通过 git 安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/tmux-plugins/tpm  /etc/.tmux/plugins/tpm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装 tpm 后需要重新读取配置文件生效：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入 tmux，输入 &lt;code&gt;※ + :&lt;/code&gt; 进入命令模式；&lt;/li&gt;
&lt;li&gt;再输入 &lt;code&gt;source-file ~/.tmux.conf&lt;/code&gt; 手动刷新配置文件；&lt;/li&gt;
&lt;li&gt;最后输入 &lt;code&gt;※ + shift + u&lt;/code&gt; 进入 tpm 插件升级页面进行升级。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>直接使用 Ubuntu Python 作为开发环境</title>
      <link>https://szthanatos.github.io/topic/wsl2/coding_with_wsl2_06/</link>
      <pubDate>Sat, 22 Aug 2020 18:06:35 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/wsl2/coding_with_wsl2_06/</guid>
      <description>&lt;p&gt;在前面的部分已经配置好了 Python 的死蛇源，所以现在已经可以使用 Ubuntu 作为 Python 基础环境了。&lt;/p&gt;
&lt;h2 id=&#34;基本配置&#34;&gt;基本配置&lt;/h2&gt;
&lt;p&gt;安装最新版本 Python：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt install python3.x
sudo apt install python3.x-distutils
sudo apt install python3-pip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改 pypi 源，使用清华大学的镜像：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install pip -U
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pycharm-连接&#34;&gt;Pycharm 连接&lt;/h2&gt;
&lt;p&gt;Pycharm 2019.1.X+ 版本已经支持直接连接 wsl 的 python 环境，无需通过 ssh&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/szthanatos/image-host/master/pycharm-wsl.png&#34; alt=&#34;pycharm 添加 wsl 解释器&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>优化指南 - 设计</title>
      <link>https://szthanatos.github.io/topic/redis/04-advanced/improve-01/</link>
      <pubDate>Mon, 18 Mar 2019 15:04:35 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/redis/04-advanced/improve-01/</guid>
      <description>&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;
&lt;p&gt;不同数据类型对应的操作的时间复杂度也不一样，选择合适的数据类型可以降低很多时间成本：&lt;/p&gt;
&lt;h3 id=&#34;string&#34;&gt;String&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SET&lt;/code&gt; key value [EX seconds] [PX milliseconds] [NX|XX]&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SETNX&lt;/code&gt; key value&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SETEX&lt;/code&gt; key seconds value&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;PSETEX&lt;/code&gt; key milliseconds value&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GET&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GETSET&lt;/code&gt; key value&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;STRLEN&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;APPEND&lt;/code&gt; key value&lt;/td&gt;
&lt;td&gt;平均 O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SETRANGE&lt;/code&gt; key offset value&lt;/td&gt;
&lt;td&gt;短字符串平均 O(1)/ 长字符串 O(N)，N 为 &lt;code&gt;value&lt;/code&gt; 长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GETRANGE&lt;/code&gt; key start end&lt;/td&gt;
&lt;td&gt;O(N)，N 为返回值长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;INCR&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;INCRBY&lt;/code&gt; key increment&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;INCRBYFLOAT&lt;/code&gt; key increment&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DECR&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DECRBY&lt;/code&gt; key decrement&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MSET&lt;/code&gt; key value [key value …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MSETNX&lt;/code&gt; key value [key value …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MGET&lt;/code&gt; key [key …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;list&#34;&gt;List&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LPUSH&lt;/code&gt; key value [value …]&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LPUSHX&lt;/code&gt; key value&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RPUSH&lt;/code&gt; key value [value …]&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RPUSHX&lt;/code&gt; key value&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LPOP&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RPOP&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RPOPLPUSH&lt;/code&gt; source destination&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LREM&lt;/code&gt; key count value&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LLEN&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LINDEX&lt;/code&gt; key index&lt;/td&gt;
&lt;td&gt;O(N)，N 为到达下标 &lt;code&gt;index&lt;/code&gt; 过程中经过的元素数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LINSERT&lt;/code&gt; key BEFORE|AFTER pivot value&lt;/td&gt;
&lt;td&gt;O(N)，N 为寻找 &lt;code&gt;pivot&lt;/code&gt; 过程中经过的元素数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LSET&lt;/code&gt; key index value&lt;/td&gt;
&lt;td&gt;头尾元素 O(1)，其他 O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LRANGE&lt;/code&gt; key start stop&lt;/td&gt;
&lt;td&gt;O(S+N)，S 为偏移量 start ， N 为指定区间内元素的数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LTRIM&lt;/code&gt; key start stop&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BLPOP&lt;/code&gt; key [key …] timeout&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BRPOP&lt;/code&gt; key [key …] timeout&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BRPOPLPUSH&lt;/code&gt; source destination timeout&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;hash&#34;&gt;Hash&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HSET&lt;/code&gt; hash field value&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HSETNX&lt;/code&gt; hash field value&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HGET&lt;/code&gt; hash field&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HEXISTS&lt;/code&gt; hash field&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HDEL&lt;/code&gt; key field [field …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HLEN&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HSTRLEN&lt;/code&gt; key field&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HINCRBY&lt;/code&gt; key field increment&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HINCRBYFLOAT&lt;/code&gt; key field increment&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HMSET&lt;/code&gt; key field value [field value …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HMGET&lt;/code&gt; key field [field …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HKEYS&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HVALS&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HGETALL&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HSCAN&lt;/code&gt; key cursor [MATCH pattern] [COUNT count]&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;set&#34;&gt;Set&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SADD&lt;/code&gt; key member [member …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SISMEMBER&lt;/code&gt; key member&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SPOP&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SRANDMEMBER&lt;/code&gt; key [count]&lt;/td&gt;
&lt;td&gt;无 conut 时 O(1)，有 conut 时 O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SREM&lt;/code&gt; key member [member …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SMOVE&lt;/code&gt; source destination member&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SCARD&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SMEMBERS&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SSCAN&lt;/code&gt; key cursor [MATCH pattern] [COUNT count]&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SINTER&lt;/code&gt; key [key …]&lt;/td&gt;
&lt;td&gt;O(N*M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SINTERSTORE&lt;/code&gt; destination key [key …]&lt;/td&gt;
&lt;td&gt;O(N*M)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SUNION&lt;/code&gt; key [key …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SUNIONSTORE&lt;/code&gt; destination key [key …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SDIFF&lt;/code&gt; key [key …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SDIFFSTORE&lt;/code&gt; destination key [key …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;zset&#34;&gt;ZSet&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZADD&lt;/code&gt; key score member [[score member] [score member] …]&lt;/td&gt;
&lt;td&gt;O(M*log(N))，N 是有序集的基数， M 为成功添加的新成员的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZSCORE&lt;/code&gt; key member&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZINCRBY&lt;/code&gt; key increment member&lt;/td&gt;
&lt;td&gt;O(log(N))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZCARD&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZCOUNT&lt;/code&gt; key min max&lt;/td&gt;
&lt;td&gt;O(log(N))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZRANGE&lt;/code&gt; key start stop [WITHSCORES]&lt;/td&gt;
&lt;td&gt;O(log(N)+M)，N 为有序集的基数，而 M 为结果集的基数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZREVRANGE&lt;/code&gt; key start stop [WITHSCORES]&lt;/td&gt;
&lt;td&gt;O(log(N)+M)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZRANGEBYSCORE&lt;/code&gt; key min max [WITHSCORES] [LIMIT offset count]&lt;/td&gt;
&lt;td&gt;O(log(N)+M)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZREVRANGEBYSCORE&lt;/code&gt; key max min [WITHSCORES] [LIMIT offset count]&lt;/td&gt;
&lt;td&gt;O(log(N)+M)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZRANK&lt;/code&gt; key member&lt;/td&gt;
&lt;td&gt;O(log(N))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZREVRANK&lt;/code&gt; key member&lt;/td&gt;
&lt;td&gt;O(log(N))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZREM&lt;/code&gt; key member [member …]&lt;/td&gt;
&lt;td&gt;O(M*log(N))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZREMRANGEBYRANK&lt;/code&gt; key start stop&lt;/td&gt;
&lt;td&gt;O(log(N)+M)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZREMRANGEBYSCORE&lt;/code&gt; key min max&lt;/td&gt;
&lt;td&gt;O(log(N)+M)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZRANGEBYLEX&lt;/code&gt; key min max [LIMIT offset count]&lt;/td&gt;
&lt;td&gt;O(log(N)+M)，N 为有序集合的元素数量， 而 M 则是命令返回的元素数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZLEXCOUNT&lt;/code&gt; key min max&lt;/td&gt;
&lt;td&gt;O(log(N))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZREMRANGEBYLEX&lt;/code&gt; key min max&lt;/td&gt;
&lt;td&gt;O(log(N)+M)，N 为有序集合的元素数量， 而 M 则为被移除的元素数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZSCAN&lt;/code&gt; key cursor [MATCH pattern] [COUNT count]&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZUNIONSTORE&lt;/code&gt; destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]&lt;/td&gt;
&lt;td&gt;O(N)+O(M log(M))，N 为给定有序集基数的总和， M 为结果集的基数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZINTERSTORE&lt;/code&gt; destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]&lt;/td&gt;
&lt;td&gt;O(N&lt;em&gt;K)+O(M&lt;/em&gt;log(M))， N 为给定 key 中基数最小的有序集， K 为给定有序集的数量， M 为结果集的基数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;模拟类型&#34;&gt;模拟类型&lt;/h3&gt;
&lt;p&gt;除了直接使用 redis 数据类型，其他的一些常见数据结构也可以用固定操作模拟出来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;堆栈&lt;/strong&gt;：lpush + lpop = Stack&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;队列&lt;/strong&gt;：lpush + rpop = Queue&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有限集合&lt;/strong&gt;：lpush + ltrim = Capped Collection&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;：lpush + brpop = Message Queue&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;负载&#34;&gt;负载&lt;/h2&gt;
&lt;p&gt;redis 基本的逻辑存储单位是键 (Key) 对象，键底层的编码方式会随着键的类型 / 大小而改变：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;编码方式 (C 语言实现)&lt;/th&gt;
&lt;th&gt;情况&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;String&lt;/code&gt; 类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int(long 类型整数)&lt;/td&gt;
&lt;td&gt;long 能存下的整数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;embstr(embstr 类型的简单动态字符串 SDS)&lt;/td&gt;
&lt;td&gt;&amp;lt;=32 字节的字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;raw(简单动态字符串 SDS)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;List&lt;/code&gt; 类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ziplist(压缩列表)&lt;/td&gt;
&lt;td&gt;列表内元素不超过 512 个并且所有元素长度都小于 64 字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;linkedlist(双端链表)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;Hash&lt;/code&gt; 类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ziplist&lt;/td&gt;
&lt;td&gt;哈希内不超过 512 个键值对并且所有键值对的键和值的长度都小于 64 字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hashtable(字典)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;Set&lt;/code&gt; 类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;intset(整数集合)&lt;/td&gt;
&lt;td&gt;集合内元素不超过 512 个并且所有元素都是整数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hashtable&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;ZSet&lt;/code&gt; 类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ziplist&lt;/td&gt;
&lt;td&gt;有序集合内元素不超过 128 个并且所有元素的长度都小于 64 字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;skiplist(跳跃表和字典)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;所以简单的来说，String 长度小于 32 字节，其他复合类型元素个数不超过 512 个 (ZSet 不超过 128 个) 并且元素小于 64 字节或者是整数 (Set) 的时候，是 redis 认为的一个 key 的合理值，超过这个范围 redis 也是允许的，但是关注点就放在存储而不是性能上了。&lt;/p&gt;
&lt;p&gt;大键会拖累存储性能。尤其是在时间复杂度不是 O(1)的操作上，性能损失是线性 (eg: &lt;code&gt;LREM&lt;/code&gt;) 甚至指数 (eg: &lt;code&gt;ZINTERSTORE&lt;/code&gt;) 上升的。&lt;/p&gt;
&lt;p&gt;过小 (零碎) 的键也不合适，它是对性能的一种浪费，比如要存放 &lt;code&gt;用户: 用户信息&lt;/code&gt;，直接将每个用户存为一个 &lt;code&gt;String&lt;/code&gt;，相比用 &lt;code&gt;Hash&lt;/code&gt; 把所有用户存储在一个键上，想要实现 &lt;code&gt;hgetall&lt;/code&gt; 这样的操作既复杂，效率也更低。&lt;/p&gt;
&lt;h3 id=&#34;集群倾斜--热点问题&#34;&gt;集群倾斜 &amp;amp; 热点问题&lt;/h3&gt;
&lt;p&gt;在集群中，redis 是划分出 16384 个哈希槽，然后将哈希槽平均 (也可以手动指定) 分配到集群节点上。键会通过 &lt;code&gt;crc16&lt;/code&gt; 算法计算并将结果对 16384 取余，由此将键映射到编号为 0~16383 的哈希槽中。&lt;/p&gt;
&lt;p&gt;大键会造成集群倾斜，也就是大键所在节点的内存可能被占满了，而其他节点还空着。极端情况下如果一个键所占空间超过了节点分配的内存，那这个集群可能会永远 &lt;code&gt;fail&lt;/code&gt; 下去——虽然有大量内存空着，但是没有一个节点能放下这个键了。&lt;/p&gt;
&lt;p&gt;大键越多，分布越不均匀，在集群中就越容易出现热点问题 (另一种角度的倾斜)，简单来说，就是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于数据都集中在一个键&lt;/li&gt;
&lt;li&gt;→ 对数据的操作都集中在一个键&lt;/li&gt;
&lt;li&gt;→ 键位于某个哈希槽&lt;/li&gt;
&lt;li&gt;→ 哈希槽所在的节点读写压力非常大&lt;/li&gt;
&lt;li&gt;→ 集群其他节点都在划水&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设是 3 个 master 的集群，本来的处理能力可能是 100000 q/s * 3，这样的情况下实际发挥出来的就只有 100000 q/s 了。&lt;/p&gt;
&lt;p&gt;针对大键 &amp;amp; 倾斜问题可以有以下措施：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将可能的大键进行拆分，比如将一个大 List 拆成 List0~List9；&lt;/li&gt;
&lt;li&gt;在集群配置中开启 &lt;code&gt;readonly&lt;/code&gt; 以降低主节点读压力 (详见 &lt;a href=&#34;cluster_command.md&#34;&gt;《Redis 集群相关命令》&lt;/a&gt;)；&lt;/li&gt;
&lt;li&gt;根据实际情况，修改 redis 变更编码类型的阈值，比如设定 &lt;code&gt;list-max-ziplist-entries=1024&lt;/code&gt; 让元素在 1024 以内的列表都用 ziplist 编码；&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;redis5 中提供新的数据结构 &lt;code&gt;Stream&lt;/code&gt;，直接实现了 Kafka 那种支持多播的消息队列&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>优化指南 - 使用</title>
      <link>https://szthanatos.github.io/topic/redis/04-advanced/improve-02/</link>
      <pubDate>Mon, 18 Mar 2019 15:04:35 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/redis/04-advanced/improve-02/</guid>
      <description>&lt;h2 id=&#34;操作&#34;&gt;操作&lt;/h2&gt;
&lt;h3 id=&#34;批量操作&#34;&gt;批量操作&lt;/h3&gt;
&lt;p&gt;传统数据库也存在批量操作效率高于单次操作的情况，但是 redis 由于执行效率更高，批量操作带来的提升也更夸张。举个不是很恰当的例子，还是按 redis 每秒能处理 10k 请求来算——&lt;/p&gt;
&lt;p&gt;假设客户端和服务端不在同一机器，网络通信存在额外 1ms 延时：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1000 次 get&lt;/td&gt;
&lt;td&gt;1000 &lt;em&gt;1 + 1000&lt;/em&gt; 0.01 = 1010  (ms)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10 次 100 个键值对的 mget&lt;/td&gt;
&lt;td&gt;10 &lt;em&gt;(1&lt;/em&gt; 1 + 100 * 0.01) = 20 (ms)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1 次 1000 个键值对的 mget&lt;/td&gt;
&lt;td&gt;1 &lt;em&gt;1 + 1000&lt;/em&gt; 0.01 = 11 (ms)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果一条条去执行，这时 redis 每秒只能处理 1000 / 1.01 ≈ 990 次请求，只发挥了实际计算力的 0.99%。&lt;/p&gt;
&lt;h4 id=&#34;multi-action-vs-pipeline-vs-transaction&#34;&gt;Multi-action vs Pipeline vs Transaction&lt;/h4&gt;
&lt;p&gt;批量操作有 3 种实现方式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Multi-action&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是 m 开头的命令，比如 &lt;code&gt;mget&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;效率是最高的，因为它只需要解析一条命令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只能做一件事&lt;/li&gt;
&lt;li&gt;一次操作的 key 太多的话会导致 redis 实例的响应能力等比下降&lt;/li&gt;
&lt;li&gt;不具有原子性，存在部分成功部分失败的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Pipeline&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;管道式的操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以处理多类数据&lt;/li&gt;
&lt;li&gt;可以将大量命令分解为多个包依次发送执行&lt;/li&gt;
&lt;li&gt;使用灵活&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不保证事务，其他客户端发送的命令可能在 pipeline 执行期间被执行&lt;/li&gt;
&lt;li&gt;不具有原子性，存在部分成功部分失败的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Transaction&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性，要么全执行要么不执行&lt;/li&gt;
&lt;li&gt;乐观锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令会被分批发送给服务端，最后统一执行，性能是最低的 (但还是远高于执行 n 次命令)&lt;/li&gt;
&lt;li&gt;随着竞争激烈程度的上升，乐观锁会导致性能相应下降&lt;/li&gt;
&lt;li&gt;在集群中，只有同属于一个哈希槽的键才能使用事务，多数客户端支持的不好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，因为 Pipeline 是基于 redis 自定义的 RESP 协议实现的，而 Transaction 是命令实现，所以给了我们组合使用的机会。相比直接使用事务会快上一点点，没有太大区别。&lt;/p&gt;
&lt;p&gt;总的来说，实现批量执行的核心肯定是 Pipeline，请尽可能的使用。&lt;/p&gt;
&lt;p&gt;放上一组官方测试结果以供参考：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Intel(R) Xeon(R) CPU E5520 @ 2.27GHz (with pipelining)
$ ./redis-benchmark -r 1000000 -n 2000000 -t get,set,lpush,lpop -P 16 -q
&amp;gt; SET: 552028.75 requests per second
&amp;gt; GET: 707463.75 requests per second
&amp;gt; LPUSH: 767459.75 requests per second
&amp;gt; LPOP: 770119.38 requests per second

# Intel(R) Xeon(R) CPU E5520 @ 2.27GHz (without pipelining)
$ ./redis-benchmark -r 1000000 -n 2000000 -t get,set,lpush,lpop -q
&amp;gt; SET: 122556.53 requests per second
&amp;gt; GET: 123601.76 requests per second
&amp;gt; LPUSH: 136752.14 requests per second
&amp;gt; LPOP: 132424.03 requests per second
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;减少阻塞&#34;&gt;减少阻塞&lt;/h3&gt;
&lt;p&gt;另一方面，针对每条命令，由于 redis 是单进程单线程的模式，命令是依次执行的，想象一下星巴克排队，只要有一个客人堵在那，后面的不管买多买少都只能排着&amp;hellip;&lt;/p&gt;
&lt;p&gt;可能造成阻塞的命令包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;del&lt;/code&gt;，这个删除是在前台阻塞式的删除，在 redis4.0 以后应该使用 &lt;code&gt;unlink&lt;/code&gt; 后台非阻塞的标记删除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keys&lt;/code&gt;、&lt;code&gt;hgetall&lt;/code&gt;、&lt;code&gt;smembers&lt;/code&gt;，这类返回所有结果的命令都会占用大量资源，都应该用 &lt;code&gt;scan&lt;/code&gt;、&lt;code&gt;hscan&lt;/code&gt;、&lt;code&gt;sscan&lt;/code&gt; 等命令替换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sinter&lt;/code&gt;/&lt;code&gt;sunion&lt;/code&gt;/&lt;code&gt;sdiff&lt;/code&gt; 的结果如果会重复使用的话，用 &lt;code&gt;sinterstore&lt;/code&gt;/&lt;code&gt;sunionstore&lt;/code&gt;/&lt;code&gt;sdiffstore&lt;/code&gt; 将结果保存起来&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sort&lt;/code&gt;，可以先取到本地再排序&lt;/li&gt;
&lt;li&gt;能用 &lt;code&gt;mget&lt;/code&gt;/&lt;code&gt;mhset&lt;/code&gt; 的情况下就不要用 &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;总之，所有时间复杂度大于 O(log n) 的操作都应该考虑有没有更低占用的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了命令本身，造成阻塞的原因还有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 饱和：cpu 占用率 100% 了&lt;/li&gt;
&lt;li&gt;CPU 竞争：和其他服务竞争资源&lt;/li&gt;
&lt;li&gt;持久化带来的 IO 阻塞
&lt;ul&gt;
&lt;li&gt;fork 阻塞：rdb/aof 文件重写的时候 fork 出的子进程长时间不能完成，导致的主进程阻塞&lt;/li&gt;
&lt;li&gt;AOF 阻塞：数据变动剧烈的时候 fsync 持续写硬盘导致的&lt;/li&gt;
&lt;li&gt;HugePage 阻塞：如果 linux 内核里启用了 &lt;code&gt;transparent_hugepage&lt;/code&gt;，会对内存和延迟带来很大影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存交换：物理内存不够用了，部分数据被写到 Linux 的虚拟内存，也就是 swap，但是内存和磁盘的读写速度起码差了 5 个量级&lt;/li&gt;
&lt;li&gt;网络问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些就需要在使用过程中不断监测和发现了。&lt;/p&gt;
&lt;h2 id=&#34;策略&#34;&gt;策略&lt;/h2&gt;
&lt;h3 id=&#34;过期回收&#34;&gt;过期回收&lt;/h3&gt;
&lt;p&gt;随着时间增长，碎片化的无用 key 的数量也会持续上升，直到最终你的内存被垃圾 Key 占满。
所以一个好习惯是给不需要持久存储 (redis 本身就不是用来持久化的) 的 Key 都加上过期时间。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;注释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EXPIRE &amp;lt;KEY&amp;gt; &amp;lt;TTL&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将键的生存时间设为 ttl 秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;PEXPIRE &amp;lt;KEY&amp;gt; &amp;lt;TTL&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将键的生存时间设为 ttl 毫秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EXPIREAT &amp;lt;KEY&amp;gt; &amp;lt;timestamp&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将键的过期时间设为 timestamp 所指定的秒数时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;PEXPIREAT &amp;lt;KEY&amp;gt; &amp;lt;timestamp&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将键的过期时间设为 timestamp 所指定的毫秒数时间戳.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;但是需要注意，过期键的内存空间默认并不会被立即回收。redis 的内存回收策略主要是这两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;被动删除&lt;/strong&gt;，读 / 写过期键时触发删除；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主动删除&lt;/strong&gt;，每隔 100ms 检查 20 个带过期时间的键，如果有超过四分之一的键过期，则重复上面步骤；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，设置 &lt;code&gt;maxmemory&lt;/code&gt; 最大内存，可以在达到内存阈值的时候触发强制删除机制 (配置项 &lt;code&gt;maxmemory-policy&lt;/code&gt;)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;noeviction&lt;/strong&gt;，禁止强制删除，&lt;strong&gt;默认策略&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;volatile-ttl&lt;/strong&gt;，从带过期时间的键中删除最接近过期的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;volatile-lru&lt;/strong&gt;，从带过期时间的键中删除最近最久未使用的 (&lt;code&gt;Least Recently Used&lt;/code&gt;)；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;volatile-lfu&lt;/strong&gt;，从带过期时间的键中删除最近最少使用的 (&lt;code&gt;Least Frequently Used&lt;/code&gt;)；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;volatile-random&lt;/strong&gt;，从带过期时间的键中随机删除；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;allkeys-lru&lt;/strong&gt;，从所有键中删除最近最久未使用的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;allkeys-lfu&lt;/strong&gt;，从所有键中删除最近最少使用的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;allkeys-random&lt;/strong&gt;，从带过期时间的键中随机删除；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;持久化&#34;&gt;持久化&lt;/h3&gt;
&lt;p&gt;redis 数据落到硬盘依赖两种持久化机制：RDB 和 AOF。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;RDB&lt;/th&gt;
&lt;th&gt;AOF&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;存储内容&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;数据&lt;/td&gt;
&lt;td&gt;写操作日志&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;性能影响&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;小&lt;/td&gt;
&lt;td&gt;大&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;恢复速度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;存储空间&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;小&lt;/td&gt;
&lt;td&gt;大&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;可读性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;安全程度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;较低，保存频率低&lt;/td&gt;
&lt;td&gt;较高，保存频率高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;默认开启&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;存储策略&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;save 900 1&lt;/code&gt;：九百秒内一次修改即保存 &lt;br&gt;&lt;code&gt;save 300 10&lt;/code&gt;：三百秒内十次修改即保存 &amp;lt; br&amp;gt;&lt;code&gt;save 60 10000&lt;/code&gt;：六十秒内一万次修改即保存 &amp;lt; br &amp;gt; 允许自定义&lt;/td&gt;
&lt;td&gt;&lt;code&gt;always&lt;/code&gt;：逐条保存 &amp;lt; br&amp;gt;or&lt;br&gt;&lt;code&gt;everysec&lt;/code&gt;：每秒保存 &amp;lt; br&amp;gt;or&lt;br&gt;&lt;code&gt;no&lt;/code&gt;：系统自己决定什么时候保存&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;RDB 的 save 策略配合大键有时候简直性能地狱。必要时请重写触发机制。&lt;/p&gt;
&lt;p&gt;AOF 的日志文件会膨胀的非常厉害，所以会定期重写。如果文件变动过于剧烈，你会发现 swap 比内存更先被吃干净。&lt;/p&gt;
&lt;p&gt;redis4.0 以后支持一个叫 &lt;code&gt;aof-use-rdb-preamble&lt;/code&gt; 的参数，意思就是在重写 AOF 文件的时候，会把早期日志写成 RDB 格式，新增加的继续使用 AOF。这样一来可以替高重写和恢复的速度。某种意义上有了这个就不必单独开启 RDB 持久化了。&lt;/p&gt;
&lt;h3 id=&#34;内存清理&#34;&gt;内存清理&lt;/h3&gt;
&lt;p&gt;在 redis4.0 之后，可以通过将配置里的 &lt;code&gt;activedefrag&lt;/code&gt; 设置为 &lt;code&gt;yes&lt;/code&gt; 开启自动清理，或者通过 &lt;code&gt;memory purge&lt;/code&gt; 命令手动清理。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>优化指南 - 运维</title>
      <link>https://szthanatos.github.io/topic/redis/04-advanced/improve-03/</link>
      <pubDate>Mon, 18 Mar 2019 15:04:35 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/redis/04-advanced/improve-03/</guid>
      <description>&lt;h2 id=&#34;监控&#34;&gt;监控&lt;/h2&gt;
&lt;p&gt;为了发现前面所说的问题，需要开发 / 运维人员不断的监控 redis 运行情况。&lt;/p&gt;
&lt;h3 id=&#34;redis-cli-查询&#34;&gt;redis-cli 查询&lt;/h3&gt;
&lt;p&gt;部分信息无法通过 redis 命令直接获取，但是可以通过 &lt;code&gt;redis-cli [参数]&lt;/code&gt; 获取：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;–-bigkeys&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;后台 scan 出每种数据类型中较大的 key&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--latency&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;服务端响应延时&lt;/p&gt;
&lt;h3 id=&#34;slowlog-命令&#34;&gt;slowlog 命令&lt;/h3&gt;
&lt;p&gt;在客户端执行 &lt;code&gt;slowlog get [n]&lt;/code&gt; 可以获取最慢的 n 条执行命令的记录&lt;/p&gt;
&lt;h3 id=&#34;info-命令&#34;&gt;info 命令&lt;/h3&gt;
&lt;p&gt;返回服务器信息，性能监测的时候注意其中的几个部分：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;memory&lt;/strong&gt;：&lt;code&gt;mem_fragmentation_ratio&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;内存碎片率，&lt;code&gt;used_memory_rss&lt;/code&gt;(系统分配内存总量) 和 &lt;code&gt;used_memory&lt;/code&gt;(Redis 分配器分配的内存总量) 的比值。&lt;/p&gt;
&lt;p&gt;在 1-1.5 之间都是合理值，&amp;lt;1 则说明内存已经占满，正在和硬盘进行内存交换，性能下降严重，&amp;gt;1.5 则说明碎片过多需要清理了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stats&lt;/strong&gt;：&lt;code&gt;latest_fork_usec&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最近一次 fork 操作耗时&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;persistence&lt;/strong&gt;：&lt;code&gt;aof_delayed_fsync&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;被延迟的 fsync 调用数量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;clients&lt;/strong&gt;：&lt;code&gt;connected_clients&lt;/code&gt;，&lt;code&gt;blocked_clients&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;已连接客户端的数量和正在等待阻塞命令的客户端的数量&lt;/p&gt;
&lt;h3 id=&#34;monitor-命令&#34;&gt;monitor 命令&lt;/h3&gt;
&lt;p&gt;可以用来监测一个节点一段时间内执行的命令，从而统计出热点 key。但是 monitor 自己也是有内存占用的，所以不能频繁、持续的使用。&lt;/p&gt;
&lt;h2 id=&#34;部署&#34;&gt;部署&lt;/h2&gt;
&lt;h3 id=&#34;网络&#34;&gt;网络&lt;/h3&gt;
&lt;p&gt;影响 redis 性能的最主要因素是网络。&lt;/p&gt;
&lt;p&gt;按官方基准测试来说，对于 10kb 以内的数据，redis 的处理能力在 100000q/s 以上。&lt;/p&gt;
&lt;p&gt;那么假设每次 set/get 的 4kb 大小的字符串，这时占用的带宽就有 3.2 Gbit/s ，千兆网卡 (1 Gbit/s) 就不够用了，得换万兆网卡 (10 Gbit/s) 才能满足需求，可见想跑满 redis 的 CPU 计算力对网络的要求是很夸张的。&lt;/p&gt;
&lt;p&gt;当然，这个例子比较极端，redis 官方推荐的网络环境下每次传输的包最好不超过一个 &lt;code&gt;MTU&lt;/code&gt;(大约 1500 bytes)。&lt;/p&gt;
&lt;p&gt;如果完全抛开网络因素，客户端服务端都在单机上时，使用 Unix 域套接字 (&lt;code&gt;Unix domain sockets&lt;/code&gt;，也叫 &lt;code&gt;IPC(inter-precess communication) socket&lt;/code&gt; 进程间通信套接字) 替换默认的 TCP/IP 连接方式，能额外再有 50% 的吞吐量提升(不过在大量使用 pipeline 的情况下就没差这么多了)。&lt;/p&gt;
&lt;p&gt;启用 Unix 域套接字需要在配置文件中取消注释：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# unixsocket 路径
unixsocket /tmp/redis.sock

# unixsocket 权限
unixsocketperm 700
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后就可以在客户端使用指定方式连接了，以 python 客户端为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import redis

redis_connect = redis.Redis(unix_socket_path=&#39;/tmp/redis.sock&#39;)
pass
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;cpu&#34;&gt;CPU&lt;/h3&gt;
&lt;p&gt;redis 更倾向于具有更大缓存而不是更多核的 CPU，在多核的情况下，redis 性能会受 NUMA 配置和进程所处位置的影响，指定客户端和服务器使用同一 CPU 的两个不同核心可以使从 L3 缓存获得的收益最大化。&lt;/p&gt;
&lt;p&gt;另外，redis 在 Inter 和 AMD 的 CPU 上的表现也有差别，在某些情况下在 AMD 的 CPU 上性能可能只有 Inter 的一半。&lt;/p&gt;
&lt;h3 id=&#34;内存&#34;&gt;内存&lt;/h3&gt;
&lt;p&gt;只有在面对大于 10KB 的数据的时候，内存频率 / 带宽才会影响 redis 性能，所以一般不用去考虑。内存大小只会影响能存放的数据量。&lt;/p&gt;
&lt;h3 id=&#34;连接数&#34;&gt;连接数&lt;/h3&gt;
&lt;p&gt;redis 可以在 60000 多个连接时维持 50000 q/s 的性能，但是根据官方测试，具有 30000 个连接的 redis 实例只能处理 100 个连接实例可实现的吞吐量的一半。&lt;/p&gt;
&lt;h3 id=&#34;虚拟化&#34;&gt;虚拟化&lt;/h3&gt;
&lt;p&gt;虚拟机中的 redis 性能肯定是低于实机上的，系统调用和中断上面浪费的太多。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 Docker 开发环境</title>
      <link>https://szthanatos.github.io/topic/wsl2/coding_with_wsl2_07/</link>
      <pubDate>Sat, 22 Aug 2020 18:07:41 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/wsl2/coding_with_wsl2_07/</guid>
      <description>&lt;p&gt;嗯，是的，其实可以直接在 Windows 下运行 Docker 而无需 Wsl。但是 Wsl2 会提供更好的性能——&lt;/p&gt;
&lt;p&gt;如果开启 Wsl2，Docker 会默认把自己的文件系统迁移到 wsl 上（因为在 Win 下的本质也是开了个 Hyper-V 的虚拟机在运行）&lt;/p&gt;
&lt;p&gt;——另一方面，咱们前面配好的终端环境也比 Windows 的终端好使&amp;hellip;&lt;/p&gt;
&lt;p&gt;看到说 Powershell 好的人有，但是真拿它写东西的人好像没见到过&amp;hellip;&lt;/p&gt;
&lt;p&gt;再一个是 Docker Desktop 可以访问到 Windows 下的文件，而如果直接在 wsl2 中安装 Docker 就没有这份福利了&amp;hellip;&lt;/p&gt;
&lt;p&gt;所以 Docker Desktop + Wsl2 是最合适的一个组合。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;下载安装 &lt;a href=&#34;https://download.docker.com/win/edge/Docker%20Desktop%20Installer.exe&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Desktop&lt;/a&gt; edge 版本&lt;/li&gt;
&lt;li&gt;打开设置，检查 &lt;code&gt;General&lt;/code&gt; 中 &lt;code&gt;use the WSL2 base egine&lt;/code&gt; 应该是默认勾选的状态；&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;Resources&lt;/code&gt;-&lt;code&gt;WSL INTEGRATION&lt;/code&gt; 中检查 &lt;code&gt;Enable integration with my default WSL Distro&lt;/code&gt; 应该是勾选状态，并将 Linux 发行版置为 &lt;code&gt;Enable&lt;/code&gt; 状态;&lt;/li&gt;
&lt;li&gt;点击 &lt;code&gt;Apply &amp;amp; Restart&lt;/code&gt;，完成~&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Docker Desktop 重启之后，在任意终端 (Windows &amp;amp; Linux) 都可以执行 Docker 命令啦~&lt;/p&gt;
&lt;h2 id=&#34;配置连接-docker&#34;&gt;配置连接 Docker&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;设置&lt;/code&gt;-&lt;code&gt;构建、执行、部署&lt;/code&gt; 下找到 &lt;code&gt;Docker&lt;/code&gt; 配置，可以直接连接 Docker for window：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/szthanatos/image-host/master/pycharm-docker.png&#34; alt=&#34;连接 docker&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;编写环境镜像&#34;&gt;编写环境镜像&lt;/h2&gt;
&lt;h3 id=&#34;最简运行环境&#34;&gt;最简运行环境&lt;/h3&gt;
&lt;p&gt;最简运行环境 Dockerfile 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM python:3.8-buster
LABEL author=&amp;quot;Lex Wayne&amp;quot;

WORKDIR /app
COPY . /app
RUN pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple &amp;amp;&amp;amp;\
    pip install -U pip &amp;amp;&amp;amp;\
    pip install --no-warn-script-location -r /requirements.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是这种比较适用于稳定项目，因为每次更改都会需要重新生成镜像。&lt;/p&gt;
&lt;p&gt;代码写到一半，新 &lt;code&gt;import&lt;/code&gt; 一个第三方包，还得先编辑 &lt;code&gt;requirements.txt&lt;/code&gt; ，重新生成镜像，才能有提示&amp;hellip;画面未免太美。&lt;/p&gt;
&lt;h3 id=&#34;个人开发环境&#34;&gt;个人开发环境&lt;/h3&gt;
&lt;p&gt;我惯用的开发环境 Dockerfile 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM python:3.8-buster
LABEL   version=&amp;quot;1.1&amp;quot; \
        authors=&amp;quot;Lex Wayne&amp;quot; \

ARG DEBIAN_FRONTEND=noninteractive

RUN echo &amp;gt;/etc/apt/sources.list &amp;quot;\n\
deb http://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free\n\
deb http://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free\n\
deb http://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free\n\
deb http://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free\n\
    &amp;quot; &amp;amp;&amp;amp;\
    apt-get update &amp;amp;&amp;amp;\
    apt-get upgrade -y &amp;amp;&amp;amp;\
    apt-get install -y sudo vim openssh-server openssh-client &amp;amp;&amp;amp;\
    mkdir -p /var/run/sshd &amp;amp;&amp;amp;\
    echo &#39;root:123456&#39; | chpasswd &amp;amp;&amp;amp;\
    sed -i &#39;s/#PermitRootLogin prohibit-password/PermitRootLogin yes/&#39; /etc/ssh/sshd_config &amp;amp;&amp;amp;\
    sed &#39;s@session\s*required\s*pam_loginuid.so@session optional pam_loginuid.so@g&#39; -i /etc/pam.d/sshd &amp;amp;&amp;amp;\
    echo &amp;quot;export VISIBLE=now&amp;quot; &amp;gt;&amp;gt; /etc/profile

RUN pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple

EXPOSE 22

CMD [&amp;quot;/usr/sbin/sshd&amp;quot;, &amp;quot;-D&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用时相当于后台长期运行一个 Linux 容器环境，通过 ssh 进行远程调试，默认密码 &lt;code&gt;123456&lt;/code&gt; 请修改掉。&lt;/p&gt;
&lt;h2 id=&#34;运行-docker-容器&#34;&gt;运行 Docker 容器&lt;/h2&gt;
&lt;p&gt;完成 Docker 配置后会在左下方底栏新增一个 &lt;code&gt;Services&lt;/code&gt;，没有的话从顶部 &lt;code&gt;视图&lt;/code&gt;-&lt;code&gt;工具窗口&lt;/code&gt; 中也能找到，&lt;/p&gt;
&lt;p&gt;双击连接 Docker，右键运行环境容器；&lt;/p&gt;
&lt;p&gt;点击侧边绿色三个箭头的图标即可使用 Dockerfile 部署。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/szthanatos/image-host/master/pycharm-dockerfile.png&#34; alt=&#34;dockerfile 部署&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Docker 官方文档: &lt;a href=&#34;https://docs.docker.com/docker-for-windows/wsl/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Desktop WSL 2 backend&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vs Code 团队博客: &lt;a href=&#34;https://code.visualstudio.com/blogs/2020/03/02/docker-in-wsl2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Using Docker in WSL 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Pycharm 易用性设置</title>
      <link>https://szthanatos.github.io/topic/wsl2/coding_with_wsl2_08/</link>
      <pubDate>Sat, 22 Aug 2020 21:51:08 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/wsl2/coding_with_wsl2_08/</guid>
      <description>&lt;h2 id=&#34;选项&#34;&gt;选项&lt;/h2&gt;
&lt;h3 id=&#34;大小写敏感&#34;&gt;大小写敏感&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;File&lt;/code&gt; -&amp;gt; &lt;code&gt;Settings&lt;/code&gt; -&amp;gt; &lt;code&gt;Editor&lt;/code&gt; -&amp;gt; &lt;code&gt;General&lt;/code&gt; -&amp;gt; &lt;code&gt;Code Completion&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;取消后全小写也能自动补全，不过为了养成好习惯建议还是开首字母。&lt;/p&gt;
&lt;h3 id=&#34;行分隔符&#34;&gt;行分隔符&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;File&lt;/code&gt; -&amp;gt; &lt;code&gt;Settings&lt;/code&gt; -&amp;gt; &lt;code&gt;Editor&lt;/code&gt; -&amp;gt; &lt;code&gt;Code Style&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Windows 下默认换行是 &lt;code&gt;CRLF&lt;/code&gt; 即 &lt;code&gt;\r\n&lt;/code&gt;，改成 Unix 的 &lt;code&gt;LF&lt;/code&gt;(&lt;code&gt;\n&lt;/code&gt;)&lt;/p&gt;
&lt;h3 id=&#34;头部模板&#34;&gt;头部模板&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;File&lt;/code&gt; -&amp;gt; &lt;code&gt;Settings&lt;/code&gt; -&amp;gt; &lt;code&gt;Editor&lt;/code&gt; -&amp;gt; &lt;code&gt;File and Code Templates&lt;/code&gt; -&amp;gt; &lt;code&gt;Python Script&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;写入以下内容作为 Python 默认头部模板：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&amp;quot;&amp;quot;&amp;quot;
@Author : ${USER}
@File   : ${NAME}.py
@Project: ${PROJECT_NAME}
@Time   : ${DATE} ${TIME}
&amp;quot;&amp;quot;&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;${USER}&lt;/code&gt; 是系统用户名，你也可以写死。&lt;/p&gt;
&lt;h3 id=&#34;鼠标缩放&#34;&gt;鼠标缩放&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;File&lt;/code&gt; -&amp;gt; &lt;code&gt;Settings&lt;/code&gt; -&amp;gt; &lt;code&gt;Editor&lt;/code&gt; -&amp;gt; &lt;code&gt;General&lt;/code&gt; -&amp;gt; &lt;code&gt;Change font size(Zoom) with Ctrl+Mouse Wheel&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按住 &lt;code&gt;Ctrl&lt;/code&gt; 滚轮缩放。&lt;/p&gt;
&lt;h2 id=&#34;插件&#34;&gt;插件&lt;/h2&gt;
&lt;h3 id=&#34;市场插件&#34;&gt;市场插件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.env file support&lt;/code&gt;: .env 文件格式支持&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.ignore&lt;/code&gt;: git .ignore 模板&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Chinese (Simplified) Language Pack EAP&lt;/code&gt;: 汉化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CodeGlance&lt;/code&gt;: Sublime 式的小地图&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Key Promoter X&lt;/code&gt;: 使用功能时显示对应快捷键&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Rainbow Brackets&lt;/code&gt;: 不同层级括号不同颜色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Requirement&lt;/code&gt;: 自动检查 Requirement 文件是否和实际环境匹配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Translation&lt;/code&gt;: 翻译插件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;外部插件&#34;&gt;外部插件&lt;/h3&gt;
&lt;p&gt;另外建议使用 &lt;a href=&#34;https://github.com/psf/black&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Black&lt;/a&gt; 让强制统一代码风格，多人协作的时候非常有用。&lt;/p&gt;
&lt;p&gt;运行 Black 需要 Python 环境，到底放 Windows 还是 Wsl 还是 Docker 都行，看你有多骚了。&lt;/p&gt;
&lt;p&gt;集成步骤直接按 &lt;a href=&#34;https://black.readthedocs.io/en/stable/editor_integration.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt; 走就好。摘抄如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;pip install black&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录 Black 位置&lt;/p&gt;
&lt;p&gt;Windows 下可能在 &lt;code&gt;C:\Users\{用户名}\AppData\Local\Programs\Python\{Python 版本}\Scripts\black.exe&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Linux 和 MacOS 可能在 &lt;code&gt;/usr/local/bin/black&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;File&lt;/code&gt; -&amp;gt; &lt;code&gt;Settings&lt;/code&gt; -&amp;gt; &lt;code&gt;Tools&lt;/code&gt; -&amp;gt; &lt;code&gt;External Tools&lt;/code&gt;，新建内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Name: Black
Description: Black is the uncompromising Python code formatter.
Program: &amp;lt;第二步的位置&amp;gt;
Arguments: &amp;quot;$FilePath$&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建议取消 &lt;code&gt;Advanced Options&lt;/code&gt; 中的 &lt;code&gt;打开工具输出控制台&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置快捷键，我建议是直接替换 &lt;code&gt;Ctrl+Alt+l&lt;/code&gt; 格式化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;监视文件更改自动执行，在 &lt;code&gt;File&lt;/code&gt; -&amp;gt; &lt;code&gt;Settings&lt;/code&gt; -&amp;gt; &lt;code&gt;Tools&lt;/code&gt; -&amp;gt; &lt;code&gt;File Watchers&lt;/code&gt; 下新建：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Name: Black
File type: Python
Scope: Project Files
Program: &amp;lt;第二步的位置&amp;gt;
Arguments: $FilePath$
Output paths to refresh: $FilePath$
Working directory: $ProjectFileDir$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建议不勾选 &lt;code&gt;Advanced Options&lt;/code&gt; 中的 &lt;code&gt;Auto-save edited files to trigger the watcher&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;快捷键&#34;&gt;快捷键&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;File&lt;/code&gt; -&amp;gt; &lt;code&gt;Settings&lt;/code&gt; -&amp;gt; &lt;code&gt;Keymap&lt;/code&gt; -&amp;gt; &lt;code&gt;Editor Action&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我用 Pycharm 默认键位很习惯，只加了:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向左: &lt;code&gt;Ctrl + ;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;向右: &lt;code&gt;Ctrl +  Shift + ;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>指北系列指南</title>
      <link>https://szthanatos.github.io/post/incomplete-guide/</link>
      <pubDate>Mon, 28 Dec 2020 19:03:14 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/incomplete-guide/</guid>
      <description>&lt;p&gt;我觉得网上技术教程都很有坑。&lt;/p&gt;
&lt;p&gt;比如官方文档。如果只想尽快使用上某种技术产品，入门章节一般都是实验级别的，不太够用，而其余章节就有点过于细节;&lt;/p&gt;
&lt;p&gt;要么是零碎的个人笔记，基本只写自己关心的那一部分，叙述角度和内容都非常零散。&lt;/p&gt;
&lt;p&gt;所以我到底想要什么样的教程呢？&lt;/p&gt;
&lt;p&gt;对于我个人而言，我期望的是一个比个人笔记长，比官方文档短的一个教程，读起来不会太累；&lt;/p&gt;
&lt;p&gt;内容可以不深入，但是要系统和全面，看完了能让读者有一个整体的概念；&lt;/p&gt;
&lt;p&gt;而对于不同领域的知识，通过同样的叙述方式，降低认知负担，快速定位自己关心的部分；&lt;/p&gt;
&lt;p&gt;教程都统一叫指北，不全面也不权威，和系统学习官方文档背道而驰，但是30分钟建立一个感性认识完全足够了。&lt;/p&gt;
&lt;p&gt;所以我拟定了这样的一个思路：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://szthanatos.github.io/media/%E6%8C%87%E5%8C%97%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png&#34; alt=&#34;指北系列目录结构&#34;&gt;&lt;/p&gt;
&lt;p&gt;作为我个人博客的指北专题的固定格式，&lt;/p&gt;
&lt;p&gt;也期望通过这样的方式更好的帮助自己建立和分享知识体系。&lt;/p&gt;
&lt;p&gt;生成目录的脚本如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
create_page(){
    cat &amp;gt; ${1}/${2}.md &amp;lt;&amp;lt;EOF
---
title: 
linktitle: ${3}
summary: 
date: $(date &#39;+%Y-%m-%d %H:%M:%S&#39;)
lastmod: $(date &#39;+%Y-%m-%d %H:%M:%S&#39;)
draft: false
toc: true
type: book
weight: ${4}
---
EOF
}

doc_title=&amp;quot;$1&amp;quot;
mkdir -p content/$1
cd content/$1

dir_list=( 
    01-design 
    02-useage 
    03-operation 
    04-advanced 
    05-troubleshooting 
    )

for chapter in ${dir_list[*]}
do
    mkdir -p $chapter
done

# chapter
create_page &amp;quot;${PWD}&amp;quot; _index &amp;quot;简介&amp;quot; 1
create_page 01-design _index &amp;quot;设计&amp;quot; 10
create_page 02-useage _index &amp;quot;使用&amp;quot; 40
create_page 03-operation _index &amp;quot;运维&amp;quot; 70
create_page 04-advanced _index &amp;quot;进阶&amp;quot; 100
create_page 05-troubleshooting _index &amp;quot;排错&amp;quot; 130

# page
create_page 01-design concept &amp;quot;概念&amp;quot; 10
create_page 01-design architecture &amp;quot;架构&amp;quot; 20
create_page 01-design component &amp;quot;组件&amp;quot; 30
create_page 02-useage install-and-config &amp;quot;安装/配置&amp;quot; 40
create_page 02-useage operate &amp;quot;操作&amp;quot; 50
create_page 02-useage example &amp;quot;用例&amp;quot; 60
create_page 03-operation update-and-rollback &amp;quot;升级/降级&amp;quot; 70
create_page 03-operation backup-and-restore &amp;quot;备份/恢复&amp;quot; 80
create_page 03-operation observability &amp;quot;观测性&amp;quot; 90
create_page 04-advanced optimize &amp;quot;优化&amp;quot; 100
create_page 04-advanced trick&amp;quot;技巧&amp;quot; 110
create_page 04-advanced reference &amp;quot;参考&amp;quot; 120

cd ../../

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你也使用 &lt;code&gt;hugo&lt;/code&gt; 和 &lt;code&gt;wowchemy&lt;/code&gt;，那么在项目主目录执行 &lt;code&gt;./create_book.sh [文档名]&lt;/code&gt; 就会在 &lt;code&gt;content/[文档名]&lt;/code&gt; 下生成所有相关文件和文件夹，并配置好目录顺序。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>加速 ssh 连接</title>
      <link>https://szthanatos.github.io/post/ssh_speed_up/</link>
      <pubDate>Fri, 15 Nov 2019 17:18:05 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/ssh_speed_up/</guid>
      <description>&lt;h2 id=&#34;报错信息&#34;&gt;报错信息&lt;/h2&gt;
&lt;p&gt;之前运维给做了几台测试服务器，远程连接的时候速度特别慢，ssh 之后需要接近 1 分钟才能连上。&lt;/p&gt;
&lt;h2 id=&#34;原因&#34;&gt;原因&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;ssh -v &amp;lt;服务器&amp;gt;&lt;/code&gt; 显示连接过程：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ssh -v 123.456.789.0
OpenSSH_6.6.1, OpenSSL 1.0.1e-fips 11 Feb 2013
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: /etc/ssh/ssh_config line 56: Applying options for *
debug1: Connecting to 123.456.789.0 [123.456.789.0] port 22.
debug1: Connection established.
debug1: permanently_set_uid: 0/0
debug1: identity file /root/.ssh/id_rsa type -1
debug1: identity file /root/.ssh/id_rsa-cert type -1
debug1: identity file /root/.ssh/id_dsa type -1
debug1: identity file /root/.ssh/id_dsa-cert type -1
debug1: identity file /root/.ssh/id_ecdsa type -1
debug1: identity file /root/.ssh/id_ecdsa-cert type -1
debug1: identity file /root/.ssh/id_ed25519 type -1
debug1: identity file /root/.ssh/id_ed25519-cert type -1
debug1: Enabling compatibility mode for protocol 2.0
debug1: Local version string SSH-2.0-OpenSSH_6.6.1
debug1: Remote protocol version 2.0, remote software version OpenSSH_6.6.1
debug1: match: OpenSSH_6.6.1 pat OpenSSH_6.6.1* compat 0x04000000
debug1: SSH2_MSG_KEXINIT sent
debug1: SSH2_MSG_KEXINIT received
debug1: kex: server-&amp;gt;client aes128-ctr hmac-md5-etm@openssh.com none
debug1: kex: client-&amp;gt;server aes128-ctr hmac-md5-etm@openssh.com none
debug1: kex: curve25519-sha256@libssh.org need=16 dh_need=16
debug1: kex: curve25519-sha256@libssh.org need=16 dh_need=16
debug1: sending SSH2_MSG_KEX_ECDH_INIT
debug1: expecting SSH2_MSG_KEX_ECDH_REPLY
debug1: Server host key: ECDSA 3f:00:c1:54:09:7a:aa:50:93:a2:53:83:74:b5:07:8f
debug1: Host &#39;123.456.789.0&#39; is known and matches the ECDSA host key.
debug1: Found key in /root/.ssh/known_hosts:2
debug1: ssh_ecdsa_verify: signature correct
debug1: SSH2_MSG_NEWKEYS sent
debug1: expecting SSH2_MSG_NEWKEYS
debug1: SSH2_MSG_NEWKEYS received
debug1: Roaming not allowed by server
debug1: SSH2_MSG_SERVICE_REQUEST sent
debug1: SSH2_MSG_SERVICE_ACCEPT received
debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mic,password
debug1: Next authentication method: gssapi-keyex # 0
debug1: No valid Key exchange context
debug1: Next authentication method: gssapi-with-mic # 1
debug1: Unspecified GSS failure.  Minor code may provide more information
No Kerberos credentials available

debug1: Unspecified GSS failure.  Minor code may provide more information
No Kerberos credentials available

debug1: Unspecified GSS failure.  Minor code may provide more information


debug1: Unspecified GSS failure.  Minor code may provide more information
No Kerberos credentials available

debug1: Next authentication method: publickey # 2
debug1: Trying private key: /root/.ssh/id_rsa
debug1: Trying private key: /root/.ssh/id_dsa
debug1: Trying private key: /root/.ssh/id_ecdsa
debug1: Trying private key: /root/.ssh/id_ed25519
debug1: Next authentication method: password # 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现卡住的位置是 &lt;code&gt;debug1: Next authentication method: gssapi-with-mic&lt;/code&gt; 附近。&lt;/p&gt;
&lt;p&gt;证明是由于 &lt;code&gt;gssapi&lt;/code&gt; 认证带来的问题。&lt;/p&gt;
&lt;p&gt;从网上找到相关的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;GSSAPI(Generic Security Services Application Programming Interface) 是一套通用网络安全系统接口。
该接口是对各种不同的客户端服务器安全机制的封装，以消除安全接口的不同，降低编程难度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenSSH 在用户登录的时候会验证 IP，它根据用户的 IP 使用反向 DNS 找到主机名，再使用 DNS 找到 IP 地址，最后匹配一下登录的 IP 是否合法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;进行身份认证的时候，OpenSSH 虽然说的是 &lt;code&gt;publickey,gssapi-keyex,gssapi-with-mic,password&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;但默认顺序是：&lt;code&gt;gssapi-with-mic&lt;/code&gt; → &lt;code&gt;hostbased&lt;/code&gt; → &lt;code&gt;publickey&lt;/code&gt; → &lt;code&gt;keyboard-interactive&lt;/code&gt; → &lt;code&gt;password&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上面连接过程我也标出了 0123，实际顺序的确如此。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gssapi&lt;/code&gt; 的认证是基于 &lt;code&gt;Kerberos&lt;/code&gt; 的，没见到人用过，&lt;/p&gt;
&lt;p&gt;另一方面，客户端反向 DNS 的过程也会在连接 DNS 服务器 / 查询客户端域名 (没域名可就会一层层 DNS 查上去) 上花费时间。&lt;/p&gt;
&lt;h2 id=&#34;解决办法&#34;&gt;解决办法&lt;/h2&gt;
&lt;p&gt;客户端，编辑 &lt;code&gt;/etc/ssh/ssh_config&lt;/code&gt; 文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方式 1：将 &lt;code&gt;GSSAPIAuthentication&lt;/code&gt; 改为 no；&lt;/li&gt;
&lt;li&gt;方式 2：编辑 / 新增 &lt;code&gt;PreferredAuthentications&lt;/code&gt; 为 publickey 或者 password，改变认证优先度;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务端，编辑 &lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt; 文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将 &lt;code&gt;UseDNS&lt;/code&gt; 改为 no；&lt;/li&gt;
&lt;li&gt;(可选) 将 &lt;code&gt;GSSAPIAuthentication&lt;/code&gt; 改为 no(所有连接都不做 gssapi 认证了)；&lt;/li&gt;
&lt;li&gt;重启 sshd 服务；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实际效果，关闭 &lt;code&gt;GSSAPIAuthentication&lt;/code&gt; 让连接时间从 1 分钟下降到 8 秒左右，关闭 &lt;code&gt;UseDNS&lt;/code&gt; 后几乎接近秒连。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>基于 Rancher HA 搭建容器云平台</title>
      <link>https://szthanatos.github.io/post/rancher_ha/</link>
      <pubDate>Thu, 26 Sep 2019 22:58:39 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/rancher_ha/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#硬件需求&#34;&gt;硬件需求&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#0-工具准备&#34;&gt;0. 工具准备&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#1-配置-nginx-负载均衡&#34;&gt;1. 配置 Nginx 负载均衡&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#2-使用-rke-安装-k8s&#34;&gt;2. 使用 RKE 安装 K8S&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#3-初始化-helm&#34;&gt;3. 初始化 helm&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#4-配置-ca-证书&#34;&gt;4. 配置 ca 证书&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#5-安装-rancher&#34;&gt;5. 安装 rancher&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#6-添加主机别名&#34;&gt;6. 添加主机别名&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;硬件需求&#34;&gt;硬件需求&lt;/h2&gt;
&lt;p&gt;rancher ha 推荐的架构是单独搭建一个 K8s 集群部署 Rancher，然后再用这个 Rancher 去管理其他的 K8s 集群。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://szthanatos.github.io/media/rancher2ha.png&#34; alt=&#34;推荐架构&#34;&gt;&lt;/p&gt;
&lt;p&gt;rancher 集群的配置和能管理的集群规模之间的关系如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;规模&lt;/th&gt;
&lt;th&gt;集群&lt;/th&gt;
&lt;th&gt;节点&lt;/th&gt;
&lt;th&gt;虚拟 CPU 核数&lt;/th&gt;
&lt;th&gt;内存&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;S&lt;/strong&gt;mall&lt;/td&gt;
&lt;td&gt;最多 5 个&lt;/td&gt;
&lt;td&gt;最多 50 个&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;8 GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;M&lt;/strong&gt;iddle&lt;/td&gt;
&lt;td&gt;最多 15 个&lt;/td&gt;
&lt;td&gt;最多 200 个&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;16 GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;L&lt;/strong&gt;arge&lt;/td&gt;
&lt;td&gt;最多 50 个&lt;/td&gt;
&lt;td&gt;最多 500 个&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;32 GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;X-L&lt;/strong&gt;arge&lt;/td&gt;
&lt;td&gt;最多 100 个&lt;/td&gt;
&lt;td&gt;最多 1000 个&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;128 GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;XX-L&lt;/strong&gt;arge&lt;/td&gt;
&lt;td&gt;100+&lt;/td&gt;
&lt;td&gt;1000+&lt;/td&gt;
&lt;td&gt;联系 Rancher&lt;/td&gt;
&lt;td&gt;联系 Rancher&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;单节点部署的 Rancher 只支持中小规模 (&lt;strong&gt;S&lt;/strong&gt;,&lt;strong&gt;M&lt;/strong&gt;) 的集群。&lt;/p&gt;
&lt;p&gt;我这次部署的机器配置如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;虚拟 CPU 核数&lt;/th&gt;
&lt;th&gt;内存&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;loadbalance&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;8G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;server-01&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;16 GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;server-02&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;16 GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;server-03&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;16 GB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一个负载均衡服务器，3 个服务器组成 K8S 集群。&lt;/p&gt;
&lt;p&gt;操作系统均为 &lt;code&gt;RancherOS 1.54&lt;/code&gt;(&lt;code&gt;Console&lt;/code&gt; 是 &lt;code&gt;Ubuntu&lt;/code&gt;，因为 &lt;code&gt;Longhorn&lt;/code&gt; 只支持这个)，Docker 版本 &lt;code&gt;18.09&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;0-工具准备&#34;&gt;0. 工具准备&lt;/h2&gt;
&lt;p&gt;在任意一节点 (我这里都是在 &lt;code&gt;server-01&lt;/code&gt; 上) 上准备以下工具：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;工具&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;kubectl&lt;/td&gt;
&lt;td&gt;Kubernetes 命令行工具&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.16.md#v1160&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kubernetes-v1.16.0&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rke&lt;/td&gt;
&lt;td&gt;Rancher 出品的用于构建 Kubernetes 集群的命令行工具&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/rancher/rke/releases/tag/v0.2.8&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Release v0.2.8&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;helm&lt;/td&gt;
&lt;td&gt;Kubernetes 包管理工具&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/helm/helm/releases/tag/v2.14.3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Helm v2.14.3&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;kubectl&lt;/code&gt; 安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://dl.k8s.io/v1.16.0/kubernetes-client-linux-amd64.tar.gz
tar -zxvf kubernetes-client-linux-amd64.tar.gz
sudo ln -s $(pwd)/kubernetes/client/bin/kubectl /usr/local/bin/kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;rke&lt;/code&gt; 安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://github.com/rancher/rke/releases/download/v0.2.8/rke_linux-arm64
sudo ln -s $(pwd)/rke_linux-amd64 /usr/local/bin/rke
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;helm&lt;/code&gt; 安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://get.helm.sh/helm-v3.0.0-beta.3-linux-amd64.tar.gz
tar -zxvf helm-v2.14.3-linux-amd64.tar.gz
sudo ln -s $(pwd)/linux-amd64/helm /usr/local/bin/helm
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-配置-nginx-负载均衡&#34;&gt;1. 配置 Nginx 负载均衡&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;loadbalance&lt;/code&gt; 主机上编写 nginx.conf 配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;worker_processes 4;
worker_rlimit_nofile 40000;

events {
    worker_connections 8192;
}

stream {
    upstream rancher_servers_http {
        least_conn;
        server &amp;lt;IP_NODE_1&amp;gt;:80 max_fails=3 fail_timeout=5s;
        server &amp;lt;IP_NODE_2&amp;gt;:80 max_fails=3 fail_timeout=5s;
        server &amp;lt;IP_NODE_3&amp;gt;:80 max_fails=3 fail_timeout=5s;
    }
    server {
        listen     80;
        proxy_pass rancher_servers_http;
    }

    upstream rancher_servers_https {
        least_conn;
        server &amp;lt;IP_NODE_1&amp;gt;:443 max_fails=3 fail_timeout=5s;
        server &amp;lt;IP_NODE_2&amp;gt;:443 max_fails=3 fail_timeout=5s;
        server &amp;lt;IP_NODE_3&amp;gt;:443 max_fails=3 fail_timeout=5s;
    }
    server {
        listen     443;
        proxy_pass rancher_servers_https;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即使用 stream 方式让 nginx 转发 80/443 端口的 http/https 流量。&lt;/p&gt;
&lt;p&gt;启动 nginx：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -d \
       --name lb-nginx \
       --restart =unless-stopped \
       -p 80:80 \
       -p 443:443 \
       -v /nginx.conf:/etc/nginx/nginx.conf \
       nginx:1.14
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-使用-rke-安装-k8s&#34;&gt;2. 使用 RKE 安装 K8S&lt;/h2&gt;
&lt;p&gt;三个作为 rancher-server 的服务器需要配置相互免密。&lt;code&gt;ssh-keygen&lt;/code&gt; 生成密钥附加到 &lt;code&gt;authorized_keys&lt;/code&gt; 上，不赘述。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;server-01&lt;/code&gt; 节点，编写 &lt;code&gt;rancher-cluster.yml&lt;/code&gt;，告诉 rke 要如何创建集群：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;nodes:
  - address: &amp;lt;IP_NODE_1&amp;gt;
    internal_address: &amp;lt;IP_NODE_1&amp;gt;
    user: rancher
    role: [controlplane,worker,etcd]
  - address: &amp;lt;IP_NODE_2&amp;gt;
    internal_address: &amp;lt;IP_NODE_2&amp;gt;
    user: rancher
    role: [controlplane,worker,etcd]
  - address: &amp;lt;IP_NODE_3&amp;gt;
    internal_address: &amp;lt;IP_NODE_3&amp;gt;
    user: rancher
    role: [controlplane,worker,etcd]

services:
  etcd:
    snapshot: true
    creation: 6h
    retention: 24h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;节点的配置项中，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;internal_address&lt;/code&gt; 非必填，如果没有内网 IP 的话可以删去。&lt;/p&gt;
&lt;p&gt;如果没有配置 &lt;code&gt;ssh_key_path&lt;/code&gt;，则会默认使用 &lt;code&gt;$HOME/.ssh/id_rsa&lt;/code&gt; 建立连接。&lt;/p&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rke up --config ./rancher-cluster.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成创建，中间如果失败了可以多执行几次，直到最后看到消息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Finished building Kubernetes cluster successfully.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;说明安装完毕。&lt;/p&gt;
&lt;p&gt;K8S 创建成功后会在根目录生成集群信息 &lt;code&gt;rancher-cluster.rkestate&lt;/code&gt; 和配置文件 &lt;code&gt;kube_config_rancher-cluster.yml&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;这两个文件包含访问 K8S 的凭据。&lt;/p&gt;
&lt;h2 id=&#34;3-初始化-helm&#34;&gt;3. 初始化 helm&lt;/h2&gt;
&lt;p&gt;helm 是由客户端 helm 和服务端 tiller 组成，我们之前安装了 helm 可以调用 helm 命令了。&lt;/p&gt;
&lt;p&gt;为了保存和管理 helm 软件包 (helm charts)，我们还需要在本地启动一个服务端。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 创建名为 tiller 的 serviceaccount
kubectl -n kube-system create serviceaccount tiller

# 授予 tiller 帐户对集群的访问权限
kubectl create clusterrolebinding tiller \
  --clusterrole=cluster-admin \
  --serviceaccount=kube-system:tiller

# 安装 tiller，官方国内用的是阿里的源
# helm init --service-account tiller --tiller-image registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:&amp;lt;tag&amp;gt;
helm init \
     --service-account tiller \
     --upgrade \
     --tiller-image gcr.azk8s.cn/kubernetes-helm/tiller:v2.14.3 \
     --stable-repo-url https://mirror.azure.cn/kubernetes/charts/

# 测试是否安装成功
kubectl -n kube-system rollout status deploy/tiller-deploy
helm version
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-配置-ca-证书&#34;&gt;4. 配置 ca 证书&lt;/h2&gt;
&lt;p&gt;rancher 支持三种来源的证书，rancher 自生成 / 来自 Let’s Encrypt 的 / 来自文件的。&lt;/p&gt;
&lt;p&gt;前两种都需要额外安装 CERT-MANAGER。&lt;/p&gt;
&lt;p&gt;这里我们采用第一种方式，依据 &lt;a href=&#34;https://docs.cert-manager.io/en/latest/getting-started/install/kubernetes.html#installing-with-helm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cert-manager 官方文档&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Install the CustomResourceDefinition resources separately
kubectl apply --validate=false -f https://raw.githubusercontent.com/jetstack/cert-manager/release-0.11/deploy/manifests/00-crds.yaml

# Create the namespace for cert-manager
kubectl create namespace cert-manager

# Add the Jetstack Helm repository
helm repo add jetstack https://charts.jetstack.io

# Update your local Helm chart repository cache
helm repo update

# Install the cert-manager Helm chart
helm install \
  --name cert-manager \
  --namespace cert-manager \
  --version v0.11.0 \
  jetstack/cert-manager
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;kubectl get pods --namespace cert-manager&lt;/code&gt; 测试是否安装成功，&lt;/p&gt;
&lt;p&gt;应该能看到 &lt;code&gt;cert-manager&lt;/code&gt;，&lt;code&gt;cert-manager-webhook&lt;/code&gt;，&lt;code&gt;cert-manager-cainjector&lt;/code&gt; 运行中。&lt;/p&gt;
&lt;p&gt;注意 cert-manager 使用的镜像来自 &lt;code&gt;quay.io&lt;/code&gt;，可以编辑 charts 中的 &lt;code&gt;values.yaml&lt;/code&gt; 来修改镜像源，或者提前从国内源下载好镜像放到服务器上。&lt;/p&gt;
&lt;h2 id=&#34;5-安装-rancher&#34;&gt;5. 安装 rancher&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 在 helm 中添加 rancher 源，建议使用 stable
helm repo add rancher-stable https://releases.rancher.com/server-charts/stable
helm repo update

# 安装 rancher
helm install rancher-stable/rancher \
  --name rancher \
  --namespace cattle-system \
  --set hostname=&amp;lt;你的域名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等待一段时间，可以运行 &lt;code&gt;kubectl -n cattle-system rollout status deploy/rancher&lt;/code&gt; 查看安装进度。&lt;/p&gt;
&lt;h2 id=&#34;6-添加主机别名&#34;&gt;6. 添加主机别名&lt;/h2&gt;
&lt;p&gt;由于没有内部 DNS 服务器，我们还需要为 Agent Pod 添加主机别名 (/etc/hosts)。&lt;/p&gt;
&lt;p&gt;不然&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;K8S 集群运行起来之后，因为 &lt;code&gt;cattle-cluster-agent Pod&lt;/code&gt; 和 &lt;code&gt;cattle-node-agent&lt;/code&gt; 无法通过 DNS 记录找到 &lt;code&gt;Rancher Server URL&lt;/code&gt;, 最终导致无法通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我们需要 (以下步骤直接复制于 &lt;a href=&#34;https://www.rancher.cn/docs/rancher/v2.x/cn/installation/ha-install/helm-rancher/tcp-l4/rancher-install/#6-%E5%8F%AF%E9%80%89-%E4%B8%BAagent-pod%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA%E5%88%AB%E5%90%8D-etc-hosts&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Rancher2.0-CN 文档&lt;/a&gt;)：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cattle-cluster-agent Pod&lt;/code&gt; 和 &lt;code&gt;cattle-node-agent&lt;/code&gt; 需要在 &lt;code&gt;LOCAL&lt;/code&gt; 集群初始化之后才会部署，所以先通过 &lt;code&gt;Rancher Server URL&lt;/code&gt; 访问 Rancher Web UI 进行初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行以下命令为 Rancher Server 容器配置 hosts:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#指定 kubectl 配置文件
export kubeconfig=xxx/xxx/xx.kubeconfig.yml

kubectl --kubeconfig=$kubeconfig -n cattle-system \
    patch deployments rancher --patch &#39;{
        &amp;quot;spec&amp;quot;: {
            &amp;quot;template&amp;quot;: {
                &amp;quot;spec&amp;quot;: {
                    &amp;quot;hostAliases&amp;quot;: [
                        {
                            &amp;quot;hostnames&amp;quot;:
                            [
                                &amp;quot;xxx.cnrancher.com&amp;quot;
                            ],
                                &amp;quot;ip&amp;quot;: &amp;quot;192.168.1.100&amp;quot;
                        }
                    ]
                }
            }
        }
    }&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code&gt;Rancher Server URL&lt;/code&gt; 访问 Rancher Web UI，设置用户名密码和 &lt;code&gt;Rancher Server URL&lt;/code&gt; 地址，然后会自动登录 Rancher Web UI；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Rancher Web UI 中依次进入 &lt;code&gt;local 集群 / system 项目&lt;/code&gt;，在 &lt;code&gt;cattle-system&lt;/code&gt; 命名空间中查看是否有 &lt;code&gt;cattle-cluster-agent Pod&lt;/code&gt; 和 &lt;code&gt;cattle-node-agent&lt;/code&gt; 被创建。如果有创建则进行下面的步骤，没有创建则等待；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cattle-cluster-agent pod&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export kubeconfig=xxx/xxx/xx.kubeconfig.yml

kubectl --kubeconfig=$kubeconfig -n cattle-system \
patch deployments cattle-cluster-agent --patch &#39;{
    &amp;quot;spec&amp;quot;: {
        &amp;quot;template&amp;quot;: {
            &amp;quot;spec&amp;quot;: {
                &amp;quot;hostAliases&amp;quot;: [
                    {
                        &amp;quot;hostnames&amp;quot;:
                        [
                            &amp;quot;demo.cnrancher.com&amp;quot;
                        ],
                            &amp;quot;ip&amp;quot;: &amp;quot;192.168.1.100&amp;quot;
                    }
                ]
            }
        }
    }
}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cattle-node-agent pod&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export kubeconfig=xxx/xxx/xx.kubeconfig.yml

kubectl --kubeconfig=$kubeconfig -n cattle-system \
patch  daemonsets cattle-node-agent --patch &#39;{
    &amp;quot;spec&amp;quot;: {
        &amp;quot;template&amp;quot;: {
            &amp;quot;spec&amp;quot;: {
                &amp;quot;hostAliases&amp;quot;: [
                    {
                        &amp;quot;hostnames&amp;quot;:
                        [
                            &amp;quot;xxx.rancher.com&amp;quot;
                        ],
                            &amp;quot;ip&amp;quot;: &amp;quot;192.168.1.100&amp;quot;
                    }
                ]
            }
        }
    }
}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;这几步花的时间比较长，需要耐心等待。安装过程到此结束。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RancherOS 初步使用小结</title>
      <link>https://szthanatos.github.io/post/rancheros/</link>
      <pubDate>Sun, 01 Sep 2019 15:39:50 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/rancheros/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#介绍&#34;&gt;介绍&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#安装&#34;&gt;安装&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#使用&#34;&gt;使用&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#ros&#34;&gt;ros&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#系统服务&#34;&gt;系统服务&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#docker&#34;&gt;docker&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#cloud-config&#34;&gt;cloud-config&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;RancherOS&lt;/code&gt; 是 Rancher 推出的一个轻量级的 Linux 内核操作系统，专为容器环境而设计。&lt;/p&gt;
&lt;p&gt;按官网的说法，它具有如下特性：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;官方说法&lt;/th&gt;
&lt;th&gt;瞎翻译&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Minimalist OS&lt;/td&gt;
&lt;td&gt;极简系统 ——当前版本 (v1.5.4) 镜像也只有 146M，还内置了各类虚拟机工具和 N 个版本的 Docker 环境&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Comprehensive System Services&lt;/td&gt;
&lt;td&gt;综合系统服务——所有的系统服务都可以通过 Compose 文件声明和启动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Improved Security&lt;/td&gt;
&lt;td&gt;更安全——没有额外的工具 / 代码，所有应用都跑在容器里，当然更安全&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Up-to-Date Version of Docker &amp;amp; Linux&lt;/td&gt;
&lt;td&gt;集成最新的 Docker&amp;amp;Linux 发行版——装完系统直接就有 Docker 用，还是最新的，美滋滋&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Automated OS Configuration&lt;/td&gt;
&lt;td&gt;自动化系统配置——使用 cloud-init 工具解析 &lt;code&gt;cloud-config&lt;/code&gt; 文件，统一管理系统级的所有配置，比如网络，docker 源&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;24x7 Enterprise-level Support&lt;/td&gt;
&lt;td&gt;不解释&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;简单的来说，当我们开始使用容器化的方式来管理应用和服务的时候，我们自然而然的会发现，我们对操作系统其实没什么需求了
——环境依赖和工具链由镜像提供，GUI 界面或者浏览器毫无作用，系统内置的各种工具也就是启动一个容器的事&amp;hellip;&lt;/p&gt;
&lt;p&gt;把这些七七八八的都去掉，最后剩下：一个 Linux 内核 + Docker 环境 + 精简但是统一的配置管理 = RancherOS&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://szthanatos.github.io/media/rancheroshowitworks.png&#34; alt=&#34;RancherOS 架构&#34;&gt;&lt;/p&gt;
&lt;p&gt;RancherOS 的架构也非常简单，除了内核，就是两个 Docker。&lt;/p&gt;
&lt;p&gt;一个系统级的 Docker(&lt;code&gt;system-docker&lt;/code&gt;) 接管了系统的绝大部分功能，比如在一般 Linux 上你会用 &lt;code&gt;systemctl restart&lt;/code&gt; 重启服务，在这里就是用 &lt;code&gt;system-docker restart&lt;/code&gt; 重启一个容器了。&lt;/p&gt;
&lt;p&gt;用户级别的 Docker 也作为一个服务运行在 &lt;code&gt;system-docker&lt;/code&gt; 之上，也就是我们一般意义上跑应用的 docker，正常使用。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;a href=&#34;https://github.com/rancher/os/releases/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RancherOS Gitlab 页面&lt;/a&gt; 下载对应版本镜像。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建虚拟机，加载 ISO 镜像，默认会以 &lt;code&gt;rancher&lt;/code&gt; 用户身份进入一个运行在内存之上的临时 RancherOS，所以建虚拟机的时候内存可以适当大一点，比如 2G&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建 / 上传一个 &lt;code&gt;cloud-config.yml&lt;/code&gt; 文件，主要内容就是写入你的 ssh 公钥，因为 RancherOS 安装之后就只能通过 ssh + 公钥的方式登陆 (是的，你在虚拟机控制台都进不去)，一个最简单的示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# cloud-config
ssh_authorized_keys:
- ssh-rsa AAA...
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有其他配置了的话，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo ros config valicate -i cloud-config.yml&lt;/code&gt; 校验没有格式错误，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo ros install -c cloud-config.yml -d /dev/sda&lt;/code&gt; 将 RancherOS 安装到硬盘。&lt;/p&gt;
&lt;p&gt;一路只有 2 个选项，是否要安装？Y，是否要重启？N，因为重启比你卸载光驱还快&amp;hellip; 直接就又进入一个新的临时 RancherOS 了&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;手动 &lt;code&gt;sudo poweroff&lt;/code&gt;，卸载光驱，重启，看到熟悉的牛头 LOGO，恭喜完成~&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;如果一定要为 rancher 设置一个密码的话，将安装命令替换为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo ros install -c cloud-config.yml -d /dev/sda --append=rancher.password = 密码&lt;/code&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;我遇到的一个情况，在 Vmware 上安装时，临时 RancherOS 默认没有网，
需要手动配置网卡：&lt;/p&gt;
&lt;p&gt;修改 &lt;code&gt;/etc/network/interfaces&lt;/code&gt; 文件，在末尾添加：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;auto eth0
iface eth0 inet static
# IP
address             xxx.xxx.xxx.xxx
# 子网掩码
netmask             xxx.xxx.xxx.xxx
# 广播地址 (可选)
broadcast           xxx.xxx.xxx.xxx
# 所在网段 (可选)
network             xxx.xxx.xxx.xxx
# 网关
gateway             xxx.xxx.xxx.xxx
# dns 服务器
dns-nameservers     xxx.xxx.xxx.xxx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置好执行 &lt;code&gt;sudo ifup eth0&lt;/code&gt; 即可连上网络。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;p&gt;整个 RancherOS 自底向上分三个层面进行管理&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;层面&lt;/th&gt;
&lt;th&gt;工具&lt;/th&gt;
&lt;th&gt;管理&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;系统管理&lt;/td&gt;
&lt;td&gt;ros&lt;/td&gt;
&lt;td&gt;cloud-config.yml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务管理&lt;/td&gt;
&lt;td&gt;system-docker&lt;/td&gt;
&lt;td&gt;类 Compose 文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;应用管理&lt;/td&gt;
&lt;td&gt;docker&lt;/td&gt;
&lt;td&gt;直接 run&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;ros&#34;&gt;ros&lt;/h3&gt;
&lt;p&gt;ros 是对系统进行管理的工具，所以必须要以 root 权限执行，具体用法可以 help 看一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo ros help
NAME:
   ros - Control and configure RancherOS
built: &#39;2019-08-22T07:44:10Z&#39;

USAGE:
   ros [global options] command [command options] [arguments...]

VERSION:
   v1.5.4

AUTHOR(S):
   Rancher Labs, Inc.

COMMANDS:
     config, c   configure settings                               # 配置管理
     console     manage which console container is used           # 切换命令行
     engine      manage which Docker engine is used               # 切换 Docker 版本
     service, s                                                   # 系统服务管理
     os          operating system upgrade/downgrade               # 内核管理
     tls         setup tls configuration                          # tls 管理
     install     install RancherOS to disk                        # 安装系统
     help, h     Shows a list of commands or help for one command

GLOBAL OPTIONS:
   --help, -h     show help
   --version, -v  print the version

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ros-config&#34;&gt;&lt;code&gt;ros config&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ros config
NAME:
   ros config - configure settings

USAGE:
   ros config command [arguments...]

COMMANDS:
     get       get value                                            # 获取配置
     set       set a value                                          # 设定配置
     images    List Docker images for a configuration from a file   # 没用过
     generate  Generate a configuration file from a template        # 没用过
     export    export configuration                                 # 输出配置，比直接看 cloud-config.yml 全面
     merge     merge configuration from stdin                       # 合并配置文件
     syslinux  edit Syslinux boot global.cfg                        # 没用过
     validate  validate configuration from stdin                    # 校验配置文件格式
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有面向系统的设置都是通过 &lt;code&gt;ros config&lt;/code&gt; 进行管理的，默认的配置存放在 &lt;code&gt;/var/lib/rancher/conf/cloud-config.yml&lt;/code&gt; 中。未记录的配置修改都会在重启后失效 (是的，&lt;code&gt;sudo passwd&lt;/code&gt; 也不能让你下次直接用户名密码登陆，不过有别的办法)&lt;/p&gt;
&lt;p&gt;简单的修改配置可以直接执行 &lt;code&gt;ros config set &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;，比如&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ros config set rancher.docker.tls true&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;多个值写成列表，比如&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ros config set rancher.network.dns.nameservers &amp;quot;[&#39;8.8.8.8&#39;,&#39;8.8.4.4&#39;]&amp;quot;&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;复杂一点的可以写一个小的 yml，然后执行 &lt;code&gt;ros config merge -i &amp;lt;文件&amp;gt;&lt;/code&gt; 进行合并，
理论上也可以手动添加到 &lt;code&gt;/var/lib/rancher/conf/cloud-config.yml&lt;/code&gt; 中。
但是个人不推荐这样做，因为现在版本的 cloud-config.yml 和 &lt;code&gt;ros config export&lt;/code&gt; 输出的不是一回事，待研究。&lt;/p&gt;
&lt;h4 id=&#34;ros-service&#34;&gt;&lt;code&gt;ros service&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$  ros service
NAME:
   ros service -

USAGE:
   ros service command [command options] [arguments...]

COMMANDS:
     enable   turn on an service              # 启用服务
     disable  turn off an service             # 禁止服务
     list     list services and state         # 服务列表
     delete   delete a service                # 删除服务
     build    Build or rebuild services       # 构建 / 重构服务
     create   Create services                 # 创建服务
     up       Create and start containers     # 创建并启动服务
     start    Start services                  # 启动服务
     logs     View output from containers     # 查看服务日志
     restart  Restart services                # 重启服务
     stop     Stop services                   # 停止服务
     rm       Delete services                 # 删除服务及镜像
     pull     Pulls service images            # pull 服务镜像
     kill     Kill containers                 # 杀死服务容器
     ps       List containers                 # 列出服务容器

OPTIONS:
   --tls               Use TLS; implied by --tlsverify
   --tlsverify         Use TLS and verify the remote [$DOCKER_TLS_VERIFY]
   --tlscacert value   Trust certs signed only by this CA
   --tlscert value     Path to TLS certificate file
   --tlskey value      Path to TLS key file
   --configdir value   Path to docker config dir, default ${HOME}/.docker
   --verbose, --debug
   --help, -h          show help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;控制的是随系统启动的服务，用法包括声明文件的写法基本和 Docker Compose 一样，把它理解成 Docker Compose 的替代品就对了。&lt;/p&gt;
&lt;p&gt;别的命令不解释了&amp;hellip;&lt;/p&gt;
&lt;h3 id=&#34;系统服务&#34;&gt;系统服务&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ros s list
disabled amazon-ecs-agent
disabled container-cron
disabled open-iscsi
disabled zfs
disabled kernel-extras
disabled kernel-headers
disabled kernel-headers-system-docker
enabled  open-vm-tools
disabled hyperv-vm-tools
disabled qemu-guest-agent
disabled rancher-server
disabled rancher-server-stable
disabled amazon-metadata
disabled volume-cifs
disabled volume-efs
disabled volume-nfs
disabled modem-manager
disabled waagent
disabled virtualbox-tools
disabled pingan-amc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面说到系统级的服务都是用 &lt;code&gt;ros s&lt;/code&gt; 控制启停，而想要自定义一个系统级的服务的话:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用 Docker Compose 语法编写服务的 &lt;code&gt;xxx.yml&lt;/code&gt; 文件，一般存放到 &lt;code&gt;/var/lib/rancher/conf/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ros service enable /var/lib/rancher/conf/xxx.yml&lt;/code&gt; 启用该服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ros service up &amp;lt;serviceName&amp;gt;&lt;/code&gt; 启动服务，如果一个 Compose 里定义了多个服务，那么需要
&lt;code&gt;ros service up &amp;lt;serviceName1&amp;gt; &amp;lt;serviceName2&amp;gt; &amp;lt;serviceName3&amp;gt; ...&lt;/code&gt; 来同时启动&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;docker&#34;&gt;docker&lt;/h3&gt;
&lt;p&gt;没啥好说的&amp;hellip;Just use it.&lt;/p&gt;
&lt;h2 id=&#34;cloud-config&#34;&gt;cloud-config&lt;/h2&gt;
&lt;p&gt;额外说一下这个 cloud-config。&lt;/p&gt;
&lt;p&gt;现有的公有云 / 虚拟化厂商大多支持 &lt;code&gt;cloud-init&lt;/code&gt; 工具进行系统配置初始化 (某种意义上的事实标准)。cloud-config 就是为 &lt;code&gt;cloud-init&lt;/code&gt; 服务的。RancherOS 在 &lt;code&gt;system-docker&lt;/code&gt; 中运行了一个 &lt;code&gt;cloud-init&lt;/code&gt; 容器，它会在启动时查找可能位置上的 cloud-config 文件并依此配置系统配置项。&lt;/p&gt;
&lt;p&gt;cloud-config 的语法格式就是标准的 YAML 语法，一个我在用的、比较完整的 cloud-config 的示例如下：&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    使用时请删除掉中文注释&amp;hellip; 给别人演示的时候懒得删注释结果 validate 没问题，但是配置就是不生效&amp;hellip;
  &lt;/div&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# 主机名
hostname: ros-test

# 系统配置
rancher:
  # 替换控制台为 alpine，也可以是 ubuntu/centos/debian...
  console: alpine

  # 初始 Docker 源
  bootstrap_docker:
    registry_mirror: &amp;quot;http://dockerhub.azk8s.cn/&amp;quot;
  # 系统 Docker 源
  system_docker:
    registry_mirror: &amp;quot;http://dockerhub.azk8s.cn/&amp;quot;
  # 用户 Docker 源
  docker:
    registry_mirror: &amp;quot;http://dockerhub.azk8s.cn/&amp;quot;

  # 网络
  network:
    interfaces:
      eth0:
        # IP 要是 CIDR 格式，要是和子网掩码对不上就上不了网
        address: 192.168.0.1/24
        # netmask: 255.255.255.0
        # broadcast: 192.168.0.255
        gateway: 192.168.0.254
        mtu: 1500
        dhcp: false
    dns:
      nameservers:
        - 114.114.114.114
        - 8.8.8.8

  # # 扩容现有磁盘不要用 fdisk，除非你想把系统格式化了，用这个就能调整磁盘大小
  # resize_device: /dev/sda

# 可登录的机器公钥
ssh_authorized_keys:
  - ssh-rsa ...
  - ssh-rsa ...

# # 挂载新磁盘
# mounts:
# - [&amp;quot;/dev/vdb&amp;quot;, &amp;quot;/mnt/s&amp;quot;, &amp;quot;ext4&amp;quot;, &amp;quot;&amp;quot;]

# 写文件
write_files:
  # 修改 apk 使用国内镜像
  - path: /etc/apk/repositories
    permissions: &amp;quot;0755&amp;quot;
    owner: root
    content: |
      https://mirrors.ustc.edu.cn/alpine/latest-stable/main
      https://mirrors.ustc.edu.cn/alpine/latest-stable/community

  # 设置 CST 时区
  - path: /etc/profile
    permissions: &amp;quot;0755&amp;quot;
    owner: root
    content: |
      export CHARSET=UTF-8
      export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
      export PAGER=less
      # 显示样式
      export PS1=&amp;quot;\[\e[37m\][\[\e[32m\]\u\[\e[37m\]@\h \[\e[36m\]\w\[\e[0m\]]\\$&amp;quot;
      # 时区
      export TZ=&#39;CST-8&#39;
      umask 022

      for script in /etc/profile.d/*.sh ; do
              if [-r $script] ; then
                      . $script
              fi
      done

  # 确保 ssh 连接时会读取. bashrc
  - path: /home/rancher/.bash_profile
    permissions: &amp;quot;0755&amp;quot;
    owner: rancher
    content: |
      # If the shell is interactive and .bashrc exists, get the aliases and functions
      if [[$- == *i* &amp;amp;&amp;amp; -f ~/.bashrc]]; then
          . ~/.bashrc
      fi

  # 配置. bashrc
  - path: /home/rancher/.bashrc
    permissions: &amp;quot;0755&amp;quot;
    owner: rancher
    content: |
      # .bashrc
      # User specific aliases and functions
      alias  d=&amp;quot;docker&amp;quot;
      alias di=&amp;quot;docker image&amp;quot;
      alias dc=&amp;quot;docker container&amp;quot;
      alias dv=&amp;quot;docker volumn&amp;quot;
      alias dn=&amp;quot;docker netwrok&amp;quot;

      # Source global definitions
      if [-f /etc/bashrc]; then
              . /etc/bashrc
      fi

# 启动时执行命令
runcmd:
  #   # 两种写法
  #   - [touch, /home/rancher/test1]
  #   - echo &amp;quot;test&amp;quot; &amp;gt; /home/rancher/test2
  # 开机更新 apk 源
  - apk update
  # 启动定时任务服务
  - crond

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>connection reset by peer</title>
      <link>https://szthanatos.github.io/topic/redis/05-troubleshooting/connection_reset/</link>
      <pubDate>Sun, 16 Jun 2019 23:06:41 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/redis/05-troubleshooting/connection_reset/</guid>
      <description>&lt;h2 id=&#34;报错信息&#34;&gt;报错信息&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Error: Connection reset by peer&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;原因&#34;&gt;原因&lt;/h2&gt;
&lt;p&gt;读写操作发生在连接断开后。&lt;/p&gt;
&lt;h2 id=&#34;解决办法&#34;&gt;解决办法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;用 &lt;code&gt;info&lt;/code&gt;/&lt;code&gt;cluster info&lt;/code&gt; 命令检查连接数是否过多&lt;/li&gt;
&lt;li&gt;检查 redis-server 是否正确监听配置文件&lt;/li&gt;
&lt;li&gt;检查配置文件中 &lt;code&gt;bind&lt;/code&gt; 部分，如果是 &lt;code&gt;bind 127.0.0.1&lt;/code&gt; 则只允许本地访问&lt;/li&gt;
&lt;li&gt;检查配置文件中 &lt;code&gt;protected-mode&lt;/code&gt; 部分是否为 &lt;code&gt;no&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重启 redis-server&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>JanusGraph 搭建及简单使用</title>
      <link>https://szthanatos.github.io/post/janusgraph/</link>
      <pubDate>Sun, 17 Mar 2019 21:50:19 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/janusgraph/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#基本环境&#34;&gt;基本环境&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#安装&#34;&gt;安装&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#配置&#34;&gt;配置&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#基本用法&#34;&gt;基本用法&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#加载诸神图&#34;&gt;加载诸神图&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#一些基本操作&#34;&gt;一些基本操作&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#增操作&#34;&gt;增操作&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#删操作&#34;&gt;删操作&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#查询&#34;&gt;查询&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;基本环境&#34;&gt;基本环境&lt;/h2&gt;
&lt;p&gt;底层数据库基于 HBase，检索服务基于 Elasticserach。&lt;/p&gt;
&lt;p&gt;系统运行服务大致如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@xnode208 ~] jps
21584 GremlinServer
27857 DataNode
23218 Jps
3251 HMaster
27283 NameNode
21707 Console
17131 Elasticsearch
29503 SecondaryNameNode
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;下载 &lt;a href=&#34;https://github.com/JanusGraph/janusgraph/releases/download/v0.2.2/janusgraph-0.2.2-hadoop2.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;janusgraph0.22 安装包&lt;/a&gt; 并解压&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://github.com/JanusGraph/janusgraph/releases/download/v0.2.2/janusgraph-0.2.2-hadoop2.zip
unzip janusgraph-0.2.2-hadoop2.zip
cd janusgraph-0.2.2-hadoop2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;在这里我们采用的是启动 gremlin-server 服务时，加载指定配置文件的方法创建图表，所以需要设置 gremlin-server 端以及图表的配置文件。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 gremlin-server 端配置文件 &lt;code&gt;janusgraph-0.2.2-hadoop2/conf/gremlin-server/socket-gremlin-server.yaml&lt;/code&gt;，这里我们复制 gremlin 服务默认的配置文件，在此基础上进行修改&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cp conf/gremlin-server/gremlin-server.yaml conf/gremlin-server/socket-gremlin-server.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 &lt;code&gt;socket-gremlin-server.yaml&lt;/code&gt;：在配置文件中添加 graphManager; 并在 graphs 项中添加 graph 键及其值，一个键值代表一个图表，值表示对图表的设置 (可添加多个图表，每一个图表都有自己的配置文件)，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;graphManager: org.janusgraph.graphdb.management.JanusGraphManager
graphs: {
  blablabla,
  graph: conf/gremlin-server/socket-jg-hbase_fyk-server-configraph.properties
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;准备上述 &lt;code&gt;socket-gremlin-server.yaml&lt;/code&gt; 中对图表进行设置的 properties 文件，&lt;code&gt;conf/gremlin-server/socket-jg-hbase_fyk-server-configraph.properties&lt;/code&gt; 文件内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gremlin.graph=org.janusgraph.core.JanusGraphFactory
graph.graphname=graph

storage.backend=hbase  # 设置我们本地启动的 hbase 作为底层数据库
storage.hostname=127.0.0.1

index.search.backend=elasticsearch  # 设置 Janus graph 自带的 es 作为我们的检索服务
index.search.hostname=127.0.0.1

cache.db-cache = true
cache.db-cache-clean-wait = 20
cache.db-cache-time = 180000
cache.db-cache-size = 0.5
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;基本用法&#34;&gt;基本用法&lt;/h2&gt;
&lt;p&gt;依次启动 hbase,elasticsearch 以及 gremlin-server，最后进入 gremlin.sh 客户端对图表进行操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;hbase&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@xnode208 ~] start-hbase.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;elasticsearch.(注：Janusgraph 自带的 elastic search 服务启动时为确保安全被禁止使用 root 用户)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[zkr@xnode208 ~] cd /usr/local/janusgraph-0.2.2-hadoop2
[zkr@xnode208 elasticsearch] ./bin/elasticsearch
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gremlin-server(启动成功后，会创建我们在配置文件中设计的图表)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[zkr@xnode208 janusgraph0.2] ./bin/gremlin-server.sh ./conf/gremlin-server/socket-gremlin-server.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gremlin.sh(进入 gremlin 交互式客户端)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@xnode208 janusgraph0.2] ./bin/gremlin.sh
gremlin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;加载诸神图&#34;&gt;加载诸神图&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 连接 gremlin server
gremlin&amp;gt; :remote connect tinkerpop.server conf/remote.yaml session
==&amp;gt;Configured localhost/127.0.0.1:8182-[f6db862e-752c-48db-839b-1b5b16f1786a]
gremlin&amp;gt; :remote console
==&amp;gt;All scripts will now be sent to Gremlin Server - [localhost/127.0.0.1:8182]-[f6db862e-752c-48db-839b-1b5b16f1786a] - type &#39;:remote console&#39; to return to local mode

# 加载诸神图到我们创建的空图表中
gremlin&amp;gt; GraphOfTheGodsFactory.load(graph)
==&amp;gt;null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例数据描述了一部分希腊诸神以及他们居住的诸神殿的相关关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://szthanatos.github.io/media/graph-of-the-gods-2.png&#34; alt=&#34;graph-of-the-gods&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;粗体键&lt;/td&gt;
&lt;td&gt;带索引的键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;星标粗体键&lt;/td&gt;
&lt;td&gt;具有唯一值的带索引的键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;带下划线的键&lt;/td&gt;
&lt;td&gt;以顶点为核心的带索引的键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;空心箭头边&lt;/td&gt;
&lt;td&gt;不能有多个指向的唯一边&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;尾部划线的边&lt;/td&gt;
&lt;td&gt;单向边&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在 JanusGraph 中，实体以顶点表示，关系以边表示，顶点和边都可以具有属性。&lt;/p&gt;
&lt;h2 id=&#34;一些基本操作&#34;&gt;一些基本操作&lt;/h2&gt;
&lt;h3 id=&#34;增操作&#34;&gt;增操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 添加顶点
v1 = graph.addVertex(label, &#39;student&#39;);  # 创建第一个顶点 v1 并增加标签
v2 = graph.addVertex();  # 创建第二个顶点没有标签

# 为顶点添加属性
v1.property(&#39;id&#39;, &#39;1&#39;);  # 为顶点 v1 添加 id 属性，值为 1
v3 = graph.addVertex(label,&#39;girl&#39;,&#39;name&#39;,&#39;huahua&#39;);  # 创建第三个顶点并且增加标签，属性以及属性值
v4 = graph.addVertex(label,&#39;boy&#39;,&#39;name&#39;,&#39;wuyanzu&#39;,&#39;age&#39;,18)  # 创建第四个顶点添加标签以及多个属性属性值

# 添加边
t1 = v1.addEdge(&#39;friends&#39;, v2);  # 为 v1 添加关系到 v2, 并定义这个关系为 t1
t2 = v1.addEdge(&#39;boyfriend&#39;, v2);  # 两个顶点之间可以增加多种关系

# 为边增加属性
t1.property(&#39;reason&#39;,&#39;cool&#39;);  # 为 t1 增加属性
v3.addEdge(&#39;boyfriend&#39;,v4,&#39;reason&#39;,&#39;because the reason&#39;);  # v3 添加关系到 v4 并且增加关系属性及属性值

# 提交修改
graph.tx().commit();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;删操作&#34;&gt;删操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 清空
g.V().drop();  # 删除所有点 / 图
g.E().drop();  # 删除所有边
graph1.close();
JanusGraphFactory.drop(graph1);  # 清空图中的所有数据

# 删除顶点
pluto = g.V().has(&#39;name&#39;,&#39;pluto&#39;).next();g.V(pluto).drop().iterate();  # 删除 name 属性为 &amp;quot;pluto&amp;quot; 的顶点
g.V().has(&#39;keys&#39;,&#39;ll&#39;).drop().iterate();  # 删除 keys 属性为 &amp;quot;ll&amp;quot; 的顶点
g.V().hasLabel(&#39;student&#39;).has(&#39;name&#39;,&#39;ll&#39;).drop().iterate();  # 删除标签为 student，并且顶点属性 name 的值为 &amp;quot;ll&amp;quot; 的顶点

# 删除边
g.E().has(&#39;uuu&#39;,&#39;because the reason&#39;).drop().iterate();  # 删除边属性 uuu 的属性值为 because the reason 的边
g.E().hasLabel(&#39;boyfriend&#39;).has(&#39;event&#39;,&#39;the reason&#39;).drop().iterate();  # 删除边标签为 boyfriend 并且边属性 event 的值为 the reason 的边

# 删除顶点标签以及顶点属性
g.V().hasLabel(&#39;girl&#39;).drop();  # 删除标签 girl 以及标签为 girl 的所有顶点
g.V().properties(&#39;name&#39;).drop();  # 删除顶点属性 name

# 删除边标签、边属性以及属性值
g.E().hasLabel(&#39;boyfriend&#39;).drop();  # 删除边标签 boyfriend
g.E().properties(&#39;uuu&#39;).drop();  # 删除边属性 uuu
g.E().hasLabel(&amp;quot;friend&amp;quot;).properties().drop();  # 删除边标签为 friend 的所有属性以及属性值
g.E().values(&#39;because the reason&#39;).drop();  # 删除边属性值为 because the reason 以及对应的属性


graph.tx().commit();  # 提交
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;查询&#34;&gt;查询&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 设置 g=graph.traversal(), 方便查询
gremlin&amp;gt; g = graph.traversal()
==&amp;gt;graphtraversalsource[standardjanusgraph[hbase:[127.0.0.1]], standard]

# 顶点标签查询
g.V();  # 查看所有顶点 id
g.V().label();  # 查看所有顶点标签
g.V().hasLabel(&amp;quot;god&amp;quot;);  # 查看所有标签为 god 的顶点 id
g.V().filter(label().is(&#39;god&#39;));  # 用 filter 查看所有标签为 god 的顶点 id
g.V().has(&#39;name&#39;,&#39;hercules&#39;);  # 查看属性为 name, 值为 hercules 的顶点

# 顶点属性及属性值查询
g.V().valueMap();  # 遍历每个顶点的属性及属性值 (若没有展示空集)
g.V().properties();  # 查看所有顶点的属性及属性值 (不展示空)
g.V().hasLabel(&amp;quot;god&amp;quot;).values();  # 查看所有顶点标签为 god 的属性值
g.V().hasLabel(&amp;quot;god&amp;quot;).properties();  # 查看顶点标签为 god 的所有顶点属性以及属性值
g.V().values(&#39;id&#39;);  # 查看顶点属性为 id 的属性值
g.V().properties(&#39;id&#39;)  # 查看顶点属性为 id 的属性及属性值

# 边标签查询
g.E();  # 查看所有顶点之间的边 顶点 id---&amp;gt; 边 ---&amp;gt; 顶点 id
g.E().label();  # 查看所有边的标签 (关系)
g.E().hasLabel(&amp;quot;battled&amp;quot;)  # 查看标签为 battled 的所有边
g.E().filter(label().is(&#39;battled&#39;));  # 用 filter 查看标签为 battled 的所有边
g.E().has(&#39;time&#39;,12);  # 查看属性 time 的值为 12 的所有边

# 边属性及属性值查询
g.E().valueMap();  # 遍历所有边属性及属性值
g.E().properties();  # 查看所有边属性及属性值
g.E().hasLabel(&amp;quot;battled&amp;quot;).values();  # 查看所有标签为 battled 的边属性值
g.E().hasLabel(&amp;quot;battled&amp;quot;).properties();  # 查看所有标签为 battled 的边属性以及属性值
g.E().values(&#39;reason&#39;);  # 查看边属性为 reason 的属性值
g.E().properties(&#39;reason&#39;);  # 查看边属性为 reason 的属性及属性值
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Git三棵树和reset/checkout命令</title>
      <link>https://szthanatos.github.io/post/git/git_trees/</link>
      <pubDate>Sat, 05 Jan 2019 14:13:21 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/git/git_trees/</guid>
      <description>&lt;p&gt;理解Git没有比从三棵树开始更好的了。&lt;/p&gt;
&lt;p&gt;完整的话还是看&lt;a href=&#34;https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;git文档&lt;/a&gt;比较好，说的蛮清楚了。&lt;/p&gt;
&lt;h2 id=&#34;三棵树和正向流程&#34;&gt;三棵树和正向流程&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;树&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;HEAD&lt;/td&gt;
&lt;td&gt;上一次提交的快照，下一次提交的父结点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Index&lt;/td&gt;
&lt;td&gt;预期的下一次提交的快照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Working Directory&lt;/td&gt;
&lt;td&gt;沙盒&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;git的核心工作就是管理这三棵树。&lt;code&gt;git add&lt;/code&gt;就是把你工作目录(Working Directory)的修改提交到暂存区(Index)，&lt;code&gt;git commit&lt;/code&gt;就是把暂存区的内容同步到仓库里作为一个快照，并移动&lt;code&gt;HEAD&lt;/code&gt;指向新快照；&lt;img src=&#34;https://szthanatos.github.io/media/git_flow.gif&#34; alt=&#34;git_flow&#34;&gt;&lt;/p&gt;
&lt;p&gt;额外说一下这个&lt;code&gt;HEAD指针&lt;/code&gt;，每一次commit都相当于在仓库(Repository)里生成一个快照，
把N个快照想象成一个右进左出的队列(List)，再想象有一个指针，默认指向队首(最新快照)，告诉你当前到底用的是哪一个版本快照。&lt;/p&gt;
&lt;h2 id=&#34;reset&#34;&gt;reset&lt;/h2&gt;
&lt;p&gt;显然，&lt;code&gt;git reset&lt;/code&gt;就是对上述行为的反向操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;reset&lt;/code&gt;的本质其实是移动&lt;code&gt;HEAD&lt;/code&gt;指针指向哪个快照，而通过&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--soft&lt;/code&gt;——只改变指针指向的快照；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--mixed&lt;/code&gt;——移动指针的同时也把快照内容同步到暂存区；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--hard&lt;/code&gt;——三棵树全同步为指针指向的快照；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参数来&lt;strong&gt;递进的&lt;/strong&gt;控制改变是发生在哪几颗树上。&lt;img src=&#34;https://szthanatos.github.io/media/git_reflow.gif&#34; alt=&#34;git_reflow&#34;&gt;&lt;/p&gt;
&lt;p&gt;再强调一遍，&lt;code&gt;reset&lt;/code&gt;的改变的是&lt;code&gt;HEAD&lt;/code&gt;指针，而不是文件。即使&lt;code&gt;git reset File&lt;/code&gt;的写法是有效的，但它的本质是&lt;code&gt;git reset --mixed HEAD File&lt;/code&gt;的缩写，即将&lt;code&gt;File&lt;/code&gt;从&lt;code&gt;HEAD&lt;/code&gt;指向的快照复制到索引中。&lt;code&gt;HEAD&lt;/code&gt;指针永远只能指向一个快照，但是快照是可以局部修改它里面的文件的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HEAD~&lt;/code&gt;表示前一个快照，&lt;code&gt;HEAD~2&lt;/code&gt;表示前两个，依此类推。&lt;/p&gt;
&lt;h2 id=&#34;checkout&#34;&gt;checkout&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;checkout&lt;/code&gt;的本质就有所不同，它关心的是分支(branch)，它的主要作用是让&lt;code&gt;HEAD&lt;/code&gt;在不同分支间移动(默认三棵树都会更新)。&lt;/p&gt;
&lt;p&gt;还是拿刚才那个队列举例，分支相当于是平行的一条队列，现在把他放在你脑子里之前那个队列的上方，
由于&lt;code&gt;HEAD&lt;/code&gt;指针只能指向一个快照，所以这个时候它可能会在两个队列间“跳动”，&lt;code&gt;checkout&lt;/code&gt;就是控制指针上下移动的命令，而&lt;code&gt;reset&lt;/code&gt;则是控制指针在当前队列左右(前后)移动。&lt;img src=&#34;https://szthanatos.github.io/media/git_checkout.gif&#34; alt=&#34;git_chechout&#34;&gt;&lt;/p&gt;
&lt;p&gt;同样的，&lt;code&gt;checkout&lt;/code&gt;后面也可以跟一个文件，和&lt;code&gt;git reset --hard [branch] file&lt;/code&gt;可能会产生的效果一样。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>(翻译)Academic 文档 - 内容编写</title>
      <link>https://szthanatos.github.io/post/academic/trans_writing_content/</link>
      <pubDate>Tue, 01 Jan 2019 12:54:29 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/academic/trans_writing_content/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;本文是对 &lt;a href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/&#34;&gt;Academic 文档 - Writing content 章节&lt;/a&gt; 的个人翻译，基于个人理解，不保证绝对准确。&lt;/p&gt;
&lt;p&gt;原文见上方连接。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#副标题&#34;&gt;副标题&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#强调&#34;&gt;强调&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#有序列表&#34;&gt;有序列表&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#无序列表&#34;&gt;无序列表&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#图片&#34;&gt;图片&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#图片集&#34;&gt;图片集&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#视频&#34;&gt;视频&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#本地视频文件&#34;&gt;本地视频文件&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#youtube&#34;&gt;Youtube&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#vimeo&#34;&gt;Vimeo&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#链接&#34;&gt;链接&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#标签和分类&#34;&gt;标签和分类&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#emojis&#34;&gt;Emojis&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#段落引用&#34;&gt;段落引用&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#高亮引用&#34;&gt;高亮引用&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#脚注&#34;&gt;脚注&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#嵌入文档&#34;&gt;嵌入文档&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#speaker-deck&#34;&gt;Speaker Deck&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#代码高亮&#34;&gt;代码高亮&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#高亮选项&#34;&gt;高亮选项&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#twitter-tweet&#34;&gt;Twitter tweet&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#github-gist&#34;&gt;GitHub gist&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#latex-数学公式&#34;&gt;LATEX 数学公式&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#多行方程式&#34;&gt;多行方程式&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#论文摘要&#34;&gt;论文摘要&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#表格&#34;&gt;表格&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#警报&#34;&gt;警报&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#目录&#34;&gt;目录&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;p&gt;Academic 支持使用 Markdown、LaTeX 数学公式和 Hugo 代码段编写内容。
此外，可以使用 HTML 以实现高级样式。
本文概述最常见的格式选项。&lt;/p&gt;
&lt;h2 id=&#34;副标题&#34;&gt;副标题&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;## Heading 2
### Heading 3
#### Heading 4
##### Heading 5
###### Heading 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;强调&#34;&gt;强调&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 下划线内为斜体
Italics with _underscores_.

# * 内为粗体
Bold with **asterisks**.

# 粗体和斜体可以组合
Combined emphasis with **asterisks and _underscores_**.

# 双波浪符内为删除线
Strikethrough with ~~two tildes~~.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;有序列表&#34;&gt;有序列表&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;1. First item
2. Another item
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;无序列表&#34;&gt;无序列表&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;我个人更习惯用 -
* First item
* Another item
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;图片&#34;&gt;图片&lt;/h2&gt;
&lt;p&gt;图片可以存放在你的媒体库 &lt;code&gt;static/img&lt;/code&gt; 或你的 &lt;a href=&#34;https://gohugo.io/content-management/page-bundles/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;页面文件夹&lt;/a&gt;。
使用以下任一方式即可引用图片：&lt;/p&gt;
&lt;p&gt;假设图片来自你的 &lt;code&gt;static/img&lt;/code&gt; 媒体库：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; figure library=&amp;quot;1&amp;quot; src=&amp;quot;image.jpg&amp;quot; title=&amp;quot;A caption&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设图片来自你的页面文件夹 (比如 &lt;code&gt;content/post/hello/&lt;/code&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; figure src=&amp;quot;image.jpg&amp;quot; title=&amp;quot;A caption&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;带编号和标题的图片：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; figure src=&amp;quot;image.jpg&amp;quot; title=&amp;quot;A caption&amp;quot; numbered=&amp;quot;true&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般图片：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;![alternative text for search engines](/media/image.jpg)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;图片集&#34;&gt;图片集&lt;/h2&gt;
&lt;p&gt;为页面包增加一个图片集：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 &lt;a href=&#34;https://gohugo.io/content-management/page-bundles/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;页面包&lt;/a&gt;(也就是你的页面文件夹) 内创建图片集文件夹；&lt;/li&gt;
&lt;li&gt;将图片放入图片集文件夹；&lt;/li&gt;
&lt;li&gt;粘贴 &lt;code&gt;{``{&amp;lt; gallery album=&amp;quot;&amp;lt;ALBUM FOLDER&amp;gt;&amp;quot; &amp;gt;}``}&lt;/code&gt; 到文章中你想要它出现的地方，将 album 参数修改为你文件集的名称；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可选的，要为你的图片集添加标题的话，将下面的实例添加到你扉页的尾部:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[[gallery_item]]
album = &amp;quot;&amp;lt;ALBUM FOLDER&amp;gt;&amp;quot;
image = &amp;quot;&amp;lt;IMAGE NAME&amp;gt;.jpg&amp;quot;
caption = &amp;quot;Write your image caption here&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，想要在图片集中使用网络位置 / 媒体库中的图片；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将图片添加到 &lt;code&gt;static/img/&lt;/code&gt; 文件夹；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在文章的扉页尾部声明图片引用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[[gallery_item]]
album = &amp;quot;1&amp;quot;
image = &amp;quot;my_image.jpg&amp;quot;
caption = &amp;quot;Write your image caption here&amp;quot;

[[gallery_item]]
album = &amp;quot;1&amp;quot;
image = &amp;quot;https://raw.githubusercontent.com/gcushen/hugo-academic/master/images/theme-dark.png&amp;quot;
caption = &amp;quot;Dark theme&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在正文要显示的位置使用 &lt;code&gt;{``{&amp;lt; gallery album=&amp;quot;1&amp;quot;&amp;gt;}``}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;视频&#34;&gt;视频&lt;/h2&gt;
&lt;p&gt;页面可以添加以下几种类型的视频。&lt;/p&gt;
&lt;h3 id=&#34;本地视频文件&#34;&gt;本地视频文件&lt;/h3&gt;
&lt;p&gt;要添加视频，将它放在 &lt;code&gt;static/img/&lt;/code&gt; 媒体库或者页面文件夹内，使用以下任一方式即可引用。&lt;/p&gt;
&lt;p&gt;位于 &lt;code&gt;static/img/&lt;/code&gt; 文件夹下的视频：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; video library=&amp;quot;1&amp;quot; src=&amp;quot;my_video.mp4&amp;quot; controls=&amp;quot;yes&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;位于页面文件夹下的视频：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; video src=&amp;quot;my_video.mp4&amp;quot; controls=&amp;quot;yes&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;youtube&#34;&gt;Youtube&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; youtube w7Ft2ymGmfc &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;vimeo&#34;&gt;Vimeo&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; vimeo 146022717 &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;链接&#34;&gt;链接&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;[I&#39;m a link](https://www.google.com)
[A post]({{&amp;lt; ref &amp;quot;post/hi.md&amp;quot; &amp;gt;}})
[A publication]({{&amp;lt; ref &amp;quot;publication/hi.md&amp;quot; &amp;gt;}})
[A project]({{&amp;lt; ref &amp;quot;project/hi.md&amp;quot; &amp;gt;}})
[Another section]({{&amp;lt; relref &amp;quot;hi.md#who&amp;quot; &amp;gt;}})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想要链接到一个文件，比如 PDF，首先将它放到 &lt;code&gt;static/files/&lt;/code&gt; 文件夹下，然后使用下面方式链接：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{% staticref &amp;quot;files/cv.pdf&amp;quot; &amp;quot;newtab&amp;quot; %}}Download my CV{{% /staticref %}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;staticref&lt;/code&gt; 的 &lt;code&gt;&amp;quot;newtab&amp;quot;&lt;/code&gt; 参数将使链接在新页面打开。&lt;/p&gt;
&lt;h3 id=&#34;标签和分类&#34;&gt;标签和分类&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;{``{&amp;lt; list_tags&amp;gt;}``}&lt;/code&gt; 生成标签链接列表，使用 &lt;code&gt;{``{&amp;lt; list_categories &amp;gt;}``}&lt;/code&gt; 生成分类链接列表。&lt;/p&gt;
&lt;h2 id=&#34;emojis&#34;&gt;Emojis&lt;/h2&gt;
&lt;p&gt;可用 Emojis 见 &lt;a href=&#34;http://www.webpagefx.com/tools/emoji-cheat-sheet/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Emoji cheat sheet&lt;/a&gt;。
下面的这个示例在实际使用时需要把: 和表情名之前的空格去掉：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;I : heart : Academic : smile :
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I ❤️ Academic 😄&lt;/p&gt;
&lt;h2 id=&#34;段落引用&#34;&gt;段落引用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; This is a blockquote.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a blockquote.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;高亮引用&#34;&gt;高亮引用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;This is a {{&amp;lt; hl&amp;gt;}}highlighted quote{{&amp;lt; /hl &amp;gt;}}.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a &lt;mark&gt;highlighted quote&lt;/mark&gt;.&lt;/p&gt;
&lt;h2 id=&#34;脚注&#34;&gt;脚注&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;I have more [^1] to say.
[^1]: Footnote example.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;嵌入文档&#34;&gt;嵌入文档&lt;/h2&gt;
&lt;p&gt;下面几种类型的文档可以被嵌入到页面中。&lt;/p&gt;
&lt;p&gt;要插入 &lt;strong&gt;谷歌文档&lt;/strong&gt; (比如幻灯片) 点击 Google Docs 中的 &lt;em&gt;File &amp;gt; Publish to web &amp;gt; Embed&lt;/em&gt; 并复制 &lt;code&gt;src=&amp;quot;...&amp;quot;&lt;/code&gt; 部分中的 URL。
之后粘贴到下面代码中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; gdocs src=&amp;quot;https://docs.google.com/...&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;speaker-deck&#34;&gt;Speaker Deck&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; speakerdeck 4e8126e72d853c0060001f97 &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;代码高亮&#34;&gt;代码高亮&lt;/h2&gt;
&lt;p&gt;将语言的代码，比如 &lt;code&gt;python&lt;/code&gt;，作为参数放在三个反引号之后：(打出来 ``` 就会被解析，只能加空格了)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt; ` ` `python
 # Example of code highlighting
 input_string_var = input(&amp;quot;Enter some data:&amp;quot;)
 print(&amp;quot;You entered: {}&amp;quot;.format(input_string_var))
 ` ` `

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Example of code highlighting
input_string_var = input(&amp;quot;Enter some data:&amp;quot;)
print(&amp;quot;You entered: {}&amp;quot;.format(input_string_var))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;高亮选项&#34;&gt;高亮选项&lt;/h3&gt;
&lt;p&gt;Academic 主题使用 &lt;a href=&#34;https://highlightjs.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;highlight.js&lt;/a&gt; 作为高亮的来源，并且默认为所有页面启用。
并且，有一些更细粒度的选项可以控制 highlight.js 的显示效果。&lt;/p&gt;
&lt;p&gt;下表列出了 highlight.js 支持的一些选项，包含他们的类型和简短描述。
&lt;strong&gt;config.toml&lt;/strong&gt; 列中的 &amp;ldquo;yes&amp;rdquo; 表示允许在 &lt;code&gt;config.toml&lt;/code&gt; 中全局设置，
&lt;strong&gt;preamble&lt;/strong&gt; 列中的 &amp;ldquo;yes&amp;rdquo; 表示可以设定在特定页面中。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;option&lt;/th&gt;
&lt;th&gt;type&lt;/th&gt;
&lt;th&gt;description&lt;/th&gt;
&lt;th&gt;config.toml&lt;/th&gt;
&lt;th&gt;preamble&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;highlight&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;启用 / 禁用高亮&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;highlight_languages&lt;/td&gt;
&lt;td&gt;slice&lt;/td&gt;
&lt;td&gt;选择额外语言&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;highlight_style&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;选择高亮样式&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;highlight-选项&#34;&gt;&lt;code&gt;highlight&lt;/code&gt; 选项&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;highlight&lt;/code&gt; 选项允许在全局或者特定页面启动 / 禁止语法高亮。
如果没有明确指定的话，默认会认为你设置了 &lt;code&gt;highlight = true&lt;/code&gt;。
也就是说，highlight.js 的 javascript/css 文件会出现在每一个页面文件中。
如果你只希望那些真的需要使用的页面才有语法高亮，
你可以在 &lt;code&gt;config.toml&lt;/code&gt; 中设置 &lt;code&gt;highlight = false&lt;/code&gt;，
之后在需要的页面的扉页覆盖为 &lt;code&gt;highlight = true&lt;/code&gt;。
相反，你也可以全局启用语法高亮，在不需要的页面中禁用。
下面给出一张展示不同全局和单独页面设置下，页面是否高亮。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;config.toml&lt;/th&gt;
&lt;th&gt;page preamble&lt;/th&gt;
&lt;th&gt;highlighting enabled for page?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;unset or true&lt;/td&gt;
&lt;td&gt;unset or true&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unset or true&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;unset or false&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;highlight_languages-选项&#34;&gt;&lt;code&gt;highlight_languages&lt;/code&gt; 选项&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;highlight_languages&lt;/code&gt; 选项允许你指定 highlight.js 支持的，但是不是默认支持的常见的语言。
比如，你想在所有页面高亮 Go 和 clojure 语言，那就在 &lt;code&gt;config.toml&lt;/code&gt; 中设置 &lt;code&gt;highlight_languages = [&amp;quot;go&amp;quot;, &amp;quot;clojure&amp;quot;]&lt;/code&gt;。
另外，如果你想为页面只启用特定的语法高亮，那就去页面扉页设置 &lt;code&gt;highlight_languages&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;config.toml&lt;/code&gt; 和扉页设置的 &lt;code&gt;highlight_languages&lt;/code&gt; 是累加的。
也就是说，如果 &lt;code&gt;config.toml&lt;/code&gt; 里设置了 &lt;code&gt;highlight_languages = [&amp;quot;go&amp;quot;]&lt;/code&gt;，而扉页设置了 &lt;code&gt;highlight_languages = [&amp;quot;ocaml&amp;quot;]&lt;/code&gt;，
那么这个页面会包含两者的高亮文件。&lt;/p&gt;
&lt;p&gt;当你设置了 &lt;code&gt;highlight_languages&lt;/code&gt; 之后，相应的高亮脚本会由 &lt;a href=&#34;https://cdnjs.com/libraries/highlight.js/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cdnjs 服务&lt;/a&gt; 提供。
要查看支持的语言，访问 &lt;a href=&#34;https://cdnjs.com/libraries/highlight.js/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cdnjs page&lt;/a&gt; 页面并查找包含 &amp;ldquo;languages&amp;rdquo; 关键字的链接。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;highlight_languages&lt;/code&gt; 选项通过 CDN 提供了一种方便又容易的方式来满足附加语言的高亮需求。
如果 cdnjs 提供的默认的文件不能满足你的需求，你可以通过 &lt;a href=&#34;https://sourcethemes.com/academic/docs/customization/#add-scripts-js&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;个性化指南&lt;/a&gt; 中的方法来使用自己的 javascript 文件。&lt;/p&gt;
&lt;h4 id=&#34;highlight_style-选项&#34;&gt;&lt;code&gt;highlight_style&lt;/code&gt; 选项&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;highlight_style&lt;/code&gt; 选项允许你使用备选的高亮样式。
比如，如果你想使用 solarized-dark 样式，你可以在 &lt;code&gt;config.toml&lt;/code&gt; 中设置 &lt;code&gt;highlight_style = &amp;quot;solarized-dark&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果未设置 &lt;code&gt;highlight_style&lt;/code&gt;，默认会使用 Academic 提供的或者在你的 &lt;code&gt;static&lt;/code&gt; 文件夹下的 &lt;code&gt;/css/highlight.min.css&lt;/code&gt;。
Academic 提供的默认样式和 &lt;code&gt;github&lt;/code&gt; 是一致的。&lt;/p&gt;
&lt;p&gt;如果设置了 &lt;code&gt;highlight_style&lt;/code&gt;，&lt;code&gt;/css/highlight.min.css&lt;/code&gt; 就会被忽略，相应的样式会由 &lt;a href=&#34;https://cdnjs.com/libraries/highlight.js/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cdnjs 服务&lt;/a&gt; 提供。
要查看支持的样式列表，访问 &lt;a href=&#34;https://cdnjs.com/libraries/highlight.js/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cdnjs page&lt;/a&gt; 页面并查找包含 &amp;ldquo;styles&amp;rdquo; 关键字的链接。&lt;/p&gt;
&lt;p&gt;可以在 &lt;a href=&#34;https://highlightjs.org/static/demo/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;highlight.js demo page&lt;/a&gt; 上查看可用样式。&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    不是所有 &lt;a href=&#34;https://highlightjs.org/static/demo/&#34;&gt;highlight.js demo page&lt;/a&gt; 上列出的样式都在 &lt;a href=&#34;https://cdnjs.com/libraries/highlight.js/&#34;&gt;cdnjs 服务&lt;/a&gt; 上可用。
如果你想使用不是由 cdnjs 提供的样式，那么保持 &lt;code&gt;highlight_style&lt;/code&gt; 未设置，然后将相应文件放到 &lt;code&gt;/static/css/highlight.min.css&lt;/code&gt;。
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    如果你不想更换 Academic 附带的样式，但是还是想由 &lt;a href=&#34;https://cdnjs.com/libraries/highlight.js/&#34;&gt;cdnjs&lt;/a&gt; 提供服务，那么在 &lt;code&gt;config.toml&lt;/code&gt; 中设置 &lt;code&gt;highlight_style = &amp;quot;github&amp;quot;&lt;/code&gt;。
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;只有在 &lt;code&gt;config.toml&lt;/code&gt; 中设置的 &lt;code&gt;highlight_style&lt;/code&gt; 才会生效，在扉页设置的 &lt;code&gt;highlight_style&lt;/code&gt; 不会生效。&lt;/p&gt;
&lt;h2 id=&#34;twitter-tweet&#34;&gt;Twitter tweet&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; tweet 666616452582129664 &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;github-gist&#34;&gt;GitHub gist&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; gist USERNAME GIST-ID &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;latex-数学公式&#34;&gt;LATEX 数学公式&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$$\left [– \frac{\hbar^2}{2 m} \frac{\partial^2}{\partial x^2} + V \right ] \Psi = i \hbar \frac{\partial}{\partial t} \Psi$$
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
$$\left [– \frac{\hbar^2}{2 m} \frac{\partial^2}{\partial x^2} + V \right ] \Psi = i \hbar \frac{\partial}{\partial t} \Psi$$
&lt;/div&gt;
&lt;p&gt;另外，单行的数学公式可以只用单个 &lt;code&gt;$&lt;/code&gt; 包裹：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;This is inline: $\mathbf{y} = \mathbf{X}\boldsymbol\beta + \boldsymbol\varepsilon$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is inline: $\mathbf{y} = \mathbf{X}\boldsymbol\beta + \boldsymbol\varepsilon$&lt;/p&gt;
&lt;p&gt;注意 Markdown 的特殊符号需要使用反斜杠转义，才能被识别为数学公式而非 Markdown 关键字。
比如 &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;_&lt;/code&gt; 应该被替换为 &lt;code&gt;\*&lt;/code&gt; 和 &lt;code&gt;\_&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;多行方程式&#34;&gt;多行方程式&lt;/h3&gt;
&lt;p&gt;标准 LaTeX 的双反斜杠换行应该被替换为 6 个反斜杠：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$$f(k;p\_0^\*) = \begin{cases} p\_0^\* &amp;amp; \text{if }k=1, \\\\\\
1-p\_0^\* &amp;amp; \text {if}k=0.\end{cases}$$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$$f(k;p_0^*) = \begin{cases} p_0^* &amp;amp; \text{if }k=1, \\\&lt;br&gt;
1-p_0^* &amp;amp; \text {if}k=0.\end{cases}$$&lt;/p&gt;
&lt;h3 id=&#34;论文摘要&#34;&gt;论文摘要&lt;/h3&gt;
&lt;p&gt;由于 Hugo 和 Academic 会尝试解析摘要中的 TOML, Markdown, 以及 LaTeX 内容，论文的 &lt;code&gt;abstract&lt;/code&gt; 和 &lt;code&gt;abstract_short&lt;/code&gt; 部分应当遵循下面两个方针：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LaTeX 的反斜杠 &lt;code&gt;\&lt;/code&gt; 应该被转义为双反斜杠，也就是 &lt;code&gt;\\&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;LaTeX 的下划线 &lt;code&gt;_&lt;/code&gt; 应该被转义为双反斜杠加下划线，也就是 &lt;code&gt;\\_&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，&lt;code&gt;abstract = &amp;quot;${O(d_{\max})}$&amp;quot;&lt;/code&gt; 就会变成 &lt;code&gt;abstract = &amp;quot;${O(d\\_{\\max})}$&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;表格&#34;&gt;表格&lt;/h2&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;| Command         | Description         |
| --------------- | ------------------- |
| `hugo`          | Build your website. |
| `hugo serve -w` | View your website.  |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hugo&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build your website.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hugo serve -w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;View your website.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;警报&#34;&gt;警报&lt;/h2&gt;
&lt;p&gt;在你为文章添加提示、注意项、警告时，警报是一个非常有用的功能。
尤其是对于教程性质的文章。
使用对应的短代码以在文章中显示警报：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;{{% alert note %}}
Here&#39;s a tip or note...
{{% /alert %}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会显示为如下 &lt;em&gt;注意&lt;/em&gt; 项：&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Here&amp;rsquo;s a tip or note&amp;hellip;
  &lt;/div&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;{{% alert warning %}}
Here&#39;s some important information...
{{% /alert %}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会展示为如下 &lt;em&gt;警告&lt;/em&gt; 项：&lt;/p&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    Here&amp;rsquo;s some important information&amp;hellip;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;
&lt;p&gt;目录对于长文章或者教程 / 文档可能特别有用，在你 Markdown 正文的任何位置使用 &lt;code&gt;{``{% toc %}``}&lt;/code&gt; 短代码自动生成目录。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>(翻译)Academic 文档 - 内容管理</title>
      <link>https://szthanatos.github.io/post/academic/trans_managing_content/</link>
      <pubDate>Tue, 01 Jan 2019 12:54:11 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/academic/trans_managing_content/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;本文是对 &lt;a href=&#34;https://sourcethemes.com/academic/docs/managing-content/&#34;&gt;Academic 文档 - Managing content 章节&lt;/a&gt; 的个人翻译，基于个人理解，不保证绝对准确。&lt;/p&gt;
&lt;p&gt;原文见上方连接。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#精选图片&#34;&gt;精选图片&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#标题图片&#34;&gt;标题图片&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#数学公式和代码&#34;&gt;数学公式和代码&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#页面特性&#34;&gt;页面特性&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#创建一个出版物&#34;&gt;创建一个出版物&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#自动&#34;&gt;自动&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#手动&#34;&gt;手动&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#关联其它资源&#34;&gt;关联其它资源&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#创建博文&#34;&gt;创建博文&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#创建项目&#34;&gt;创建项目&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#创建演讲&#34;&gt;创建演讲&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#创建幻灯片&#34;&gt;创建幻灯片&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#创建课程或文档&#34;&gt;创建课程或文档&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#创建小部件页面&#34;&gt;创建小部件页面&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#创建其他页面-eg-简历&#34;&gt;创建其他页面 (e.g. 简历)&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#管理列表页&#34;&gt;管理列表页&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#移除内容&#34;&gt;移除内容&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#查看站点更新&#34;&gt;查看站点更新&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#部署站点&#34;&gt;部署站点&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;p&gt;这是一个使用 Academic 框架管理你的文章的简短指南。
Academic 提供的内容模板包括出版物、项目、宣讲、新闻 / 博客文章、以及小部件页。
之后，你可能同样对 &lt;a href=&#34;https://szthanatos.github.io/post/trans_writing_content.md&#34;&gt;使用 Markdown、LaTeX 数学公式和代码段进行创作&lt;/a&gt; 感兴趣。&lt;/p&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    Hugo V0.49 版本在使用本指南中的 &lt;code&gt;hugo new&lt;/code&gt; 命令时存在一个 bug，请升级到 V0.50 及以上。
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;精选图片&#34;&gt;精选图片&lt;/h2&gt;
&lt;p&gt;要在文章页显示一个精选图片，简单的将名为 &lt;code&gt;featured.*&lt;/code&gt;(e.g. &lt;code&gt;featured.jpg&lt;/code&gt;) 的图片文件拖拽到文章文件夹即可。&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    如果你的页面在它所属的分类文件夹下没有自己的文件夹 (&lt;a href=&#34;https://gohugo.io/content-management/page-bundles/&#34;&gt;页面包&lt;/a&gt;)，
你可以创建一个和你页面 &lt;code&gt;NAME.md&lt;/code&gt; 同名的文件夹 &lt;code&gt;NAME&lt;/code&gt;，并将页面文件放入文件夹中，变为 &lt;code&gt;NAME/index.md&lt;/code&gt;。
这里有一个 &lt;a href=&#34;https://github.com/sourcethemes/academic-scripts&#34;&gt;自动迁移工具&lt;/a&gt;。
使用页面包需要 Academic v3+ 以及 Hugo v0.50 以上。
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;想要为图片添加标题或者设置一个焦点以控制图片的裁剪？
将下方的参数添加到扉页 (也就是 md 文件 &lt;code&gt;+++&lt;/code&gt; 括起来的部分) 的底部以自定义图片的外观。
标题 (caption) 参数支持使用 Markdown 为图片添加标题或描述。
焦点 (focal_point) 参数确保图片自动缩放的时候主要内容始终可见。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Featured image
# To use, add an image named `featured.jpg/png` to your page&#39;s folder.
[image]
  # Caption (optional)
  caption = &amp;quot;Photo by [Academic](https://sourcethemes.com/academic/)&amp;quot;

  # Focal point (optional)
  # Options: Smart, Center, TopLeft, Top, TopRight, Left, Right, BottomLeft, Bottom, BottomRight
  focal_point = &amp;quot;Smart&amp;quot;

  # Show image only in page previews?
  preview_only = false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;标题图片&#34;&gt;标题图片&lt;/h2&gt;
&lt;p&gt;将下面的 header 参数添加到扉页的末尾，以在页面顶部展示一个占据全部宽度的标题图片。
图片文件默认会从静态图片文件库 &lt;code&gt;static/img/&lt;/code&gt; 读取 (所以不必写全)，所以下面例子的图片文件的完整路径是 &lt;code&gt;static/img/header.png&lt;/code&gt;。
标题参数作用和精选图一致。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;[header]
  image = &amp;quot;header.png&amp;quot;
  caption = &amp;quot;Image credit: [**Academic**](https://github.com/gcushen/hugo-academic/)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数学公式和代码&#34;&gt;数学公式和代码&lt;/h2&gt;
&lt;p&gt;要在页面中启用 &lt;strong&gt;LaTeX&lt;/strong&gt; 渲染数学公式，在页面的扉页中应该申明 &lt;code&gt;math = true&lt;/code&gt;，如同示例网站的例子一样。
或者，在 &lt;code&gt;config.toml&lt;/code&gt; 中设置 &lt;code&gt;math = true&lt;/code&gt;，以在全局范围内允许数学公式渲染。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;config.toml&lt;/code&gt; 中设置 &lt;code&gt;highlight = false&lt;/code&gt; 以全局禁用代码高亮。你可以在需要代码高亮的页面的扉页单独设置 &lt;code&gt;highlight = true&lt;/code&gt;。
查看 &lt;a href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/#code-highlighting&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;code-highlighting docs&lt;/a&gt; 以获取更多细节。&lt;/p&gt;
&lt;h2 id=&#34;页面特性&#34;&gt;页面特性&lt;/h2&gt;
&lt;p&gt;将下述参数添加到页面扉页以管理页面特性：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;reading_time = false  # 显示估计阅读时间
share = false  # 显示分享按钮
profile = false  # 显示作者信息
comments = false  # 显示评论区
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;创建一个出版物&#34;&gt;创建一个出版物&lt;/h2&gt;
&lt;h3 id=&#34;自动&#34;&gt;自动&lt;/h3&gt;
&lt;p&gt;先进的文献管理工具可以帮助你将你的出版物转化为开源的 BibTeX 格式。
如果你是新手的话我们推荐你使用流行的开源工具 &lt;a href=&#34;https://www.zotero.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Zotero&lt;/a&gt; 来管理你的文献。&lt;/p&gt;
&lt;p&gt;在你的文献管理工具中创建你自己的出版物列表并导出为 &lt;code&gt;*.bib&lt;/code&gt; 格式的 BibTeX 文件。&lt;/p&gt;
&lt;p&gt;工具需要 Python3 环境，所以请先 &lt;a href=&#34;https://realpython.com/installing-python/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;安装 Python3&lt;/a&gt;。
同样，为了让你有机会检查 Academic 管理工具产生的改变，你需要备份你的站点，或者确保它已经处于 Git 的管理之中。&lt;/p&gt;
&lt;p&gt;打开你的终端或者命令提示符应用，安装 Academic 管理工具：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip3 install -U academic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;cd&lt;/code&gt; 命令进入你的站点目录。&lt;/p&gt;
&lt;p&gt;之后，导入你的出版物：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;academic import --bibtex &amp;lt;path_to_your/publications.bib&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个工具尚处于测试阶段，目的是为了给你提供辅助。
所以在发布你的站点之前你应该检查 &lt;code&gt;publications&lt;/code&gt; 文件夹下产生的内容。
你同样可以看看下一章节 &lt;code&gt;手动&lt;/code&gt; 部分有关扉页参数的细节，以想办法增强展示效果。&lt;/p&gt;
&lt;p&gt;想要支持这个工具或者提供建议 / 反馈，请查看 &lt;a href=&#34;https://github.com/sourcethemes/academic-admin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Academic admin tool 项目主页&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;手动&#34;&gt;手动&lt;/h3&gt;
&lt;p&gt;另一种选择，使用命令手动的创建出版物：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo new --kind publication publication/&amp;lt;my-publication&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;my-publication&amp;gt;&lt;/code&gt; 是你得出版物的名称，使用 &lt;code&gt;-&lt;/code&gt; 代替空格。&lt;/p&gt;
&lt;p&gt;之后，编辑 &lt;code&gt;content/publication/&amp;lt;my-publication&amp;gt;/index.md&lt;/code&gt; 内含有你的出版物信息的参数。主要参数如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;title&lt;/strong&gt;: 标题&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;date&lt;/strong&gt;: 发布日期 (必须使用有效的 TOML 日期格式)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;publication_types&lt;/strong&gt;: 使用图例来说明你出版物的类型, e.g. conference proceedings&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;publication&lt;/strong&gt;: 你的出版物发布在什么地方 - 允许使用 Markdown 以标注斜体或其他.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;abstract&lt;/strong&gt;: 摘要&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 Markdown 格式将你出版物的细节写到文档的正文部分 (在 &lt;code&gt;+++&lt;/code&gt; 部分之后)。
内容会出现在你的出版物页之上。&lt;/p&gt;
&lt;p&gt;要使访客能够阅读到你的作品，将作品的 PDF 链接填入 &lt;code&gt;url_pdf&lt;/code&gt;，或者将作品 PDF 文件放置到出版物目录并统一为相同命名，这样会自动生成 PDF 的链接。
举例，如果你的出版物说明位于 &lt;code&gt;publication/photons/index.md&lt;/code&gt;，将 PDF 文件重命名并放到 &lt;code&gt;publication/photons/photons.pdf&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;关联其它资源&#34;&gt;关联其它资源&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;url_&lt;/code&gt; 链接以指向本地 / 网络内容。
要关联本地内容的话将之复制到出版物文件夹并使用例如 &lt;code&gt;url_code = &amp;quot;code.zip&amp;quot;&lt;/code&gt; 的方式添加引用。&lt;/p&gt;
&lt;p&gt;你也可以将下面的代码块添加到扉页，以使用自定义链接按钮：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;url_custom = [{name = &amp;quot;Custom Link 1&amp;quot;, url = &amp;quot;http://example.org&amp;quot;},
              {name = &amp;quot;Custom Link 2&amp;quot;, url = &amp;quot;http://example.org&amp;quot;}]
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    想要在扉页的参数中使用双引号或者反斜杠需要额外添加一个反斜杠，&lt;em&gt;例子懒得翻&lt;/em&gt;，更多信息请参阅 &lt;a href=&#34;https://github.com/toml-lang/toml#user-content-string&#34;&gt;TOML 文档&lt;/a&gt;。
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;创建博文&#34;&gt;创建博文&lt;/h2&gt;
&lt;p&gt;要创建一篇新文章：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo new  --kind post post/my-article-name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后用你的完整标题和内容填充新生成的 &lt;code&gt;content/post/my-article-name.md&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;Academic 会自动生成内容摘要并显示在主页上。
如果你不满意自动生成的摘要内容，你可以在文章内容中放置 &lt;code&gt;&amp;lt;!``--more--&amp;gt;&lt;/code&gt; 以限定摘要的长度，
或者像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;summary = &amp;quot;Summary of my post.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在扉页内添加 &lt;code&gt;summary&lt;/code&gt; 参数以覆盖自动生成的摘要。&lt;/p&gt;
&lt;p&gt;要为特定的文章禁止评论，在扉页添加 &lt;code&gt;disable_comments = true&lt;/code&gt; 参数。
要全局的禁止评论的话，在 &lt;code&gt;config.toml&lt;/code&gt; 中设置 &lt;code&gt;disqusShortname = &amp;quot;&amp;quot;&lt;/code&gt; 或者 &lt;code&gt;disable_comments = true&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;创建项目&#34;&gt;创建项目&lt;/h2&gt;
&lt;p&gt;要创建一个项目：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo new  --kind project project/my-project-name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后编辑新生成的 &lt;code&gt;content/project/my-project-name.md&lt;/code&gt; 文件。
在扉页将 &lt;code&gt;external_link = &amp;quot;http://external-project.com&amp;quot;&lt;/code&gt; 设置成已经存在的项目网址，
或者也可以手动在正文中介绍项目的情况。&lt;/p&gt;
&lt;h2 id=&#34;创建演讲&#34;&gt;创建演讲&lt;/h2&gt;
&lt;p&gt;要创建一个演讲：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo new  --kind talk talk/my-talk-name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后用你的完整标题和内容填充新生成的 &lt;code&gt;content/talk/my-talk-name.md&lt;/code&gt; 文件。
你会注意到演讲的很多参数和出版物是类似的。&lt;/p&gt;
&lt;h2 id=&#34;创建幻灯片&#34;&gt;创建幻灯片&lt;/h2&gt;
&lt;p&gt;可以使用 Markdown 非常高效的创建幻灯片并通过你的网站分享给观众。
甚至还包括演讲者笔记。&lt;/p&gt;
&lt;p&gt;查看 &lt;a href=&#34;https://themes.gohugo.io//theme/academic/slides/example-slides#/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;slides demo&lt;/a&gt;
——尽管你可以注意到这个幻灯片是由 Hugo 团队制作的，并且他们缩减了一些功能。
运行 &lt;code&gt;themes/academic/exampleSite/&lt;/code&gt; 下的示例站点以查看完整的包含演讲者笔记的示例。&lt;/p&gt;
&lt;p&gt;查看 &lt;code&gt;themes/academic/exampleSite/content/slides/example-slides.md&lt;/code&gt; 内的 &lt;code&gt;example slide deck&lt;/code&gt; 以开始学习。&lt;/p&gt;
&lt;p&gt;在演讲 / 出版物页面使用 &lt;code&gt;url_slides&lt;/code&gt; 参数来关联到幻灯片。
比如，&lt;code&gt;url_slides = &amp;quot;slides/example-slides&amp;quot;&lt;/code&gt; 可以关联到上面的示例站点。
在 &lt;a href=&#34;https://raw.githubusercontent.com/gcushen/hugo-academic/master/exampleSite/content/talk/example/index.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt; 可以看到包含 &lt;code&gt;url_slides&lt;/code&gt; 的完整扉页的示例。&lt;/p&gt;
&lt;h2 id=&#34;创建课程或文档&#34;&gt;创建课程或文档&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;文档&lt;/em&gt; 是用来 &lt;strong&gt;分享知识&lt;/strong&gt; 的。常见例子包括在线课程、教程、软件文档以及知识库。&lt;/p&gt;
&lt;p&gt;你现在阅读的这个页面 (不是我翻译之后的这个) 就是用_文档_的方式来展现 Academic 相关的。
同样，这里也有一个 &lt;a href=&#34;https://themes.gohugo.io//theme/academic/tutorial/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在线课程&lt;/a&gt; 的例子。&lt;/p&gt;
&lt;p&gt;查看 &lt;code&gt;themes/academic/exampleSite/content/tutorial/&lt;/code&gt; 的示例以学习如何开始。&lt;/p&gt;
&lt;p&gt;如果你是一名使用 R 语言的数据分析师 / 数据科学家 (e.g. RStudio and RMarkdown)，我们推荐你阅读 &lt;a href=&#34;https://github.com/sourcethemes/project-kickstart-r&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;R boilerplate project on GitHub&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;创建小部件页面&#34;&gt;创建小部件页面&lt;/h2&gt;
&lt;p&gt;你是否想利用 Academic 的小部件系统，创建一个和 Academic 主页类似的页面？&lt;/p&gt;
&lt;p&gt;在你的 &lt;code&gt;content&lt;/code&gt; 文件夹下创建一个新的，以你的页面命名的文件夹。在这个例子中我们将创建 &lt;code&gt;content/tutorials/&lt;/code&gt; 文件夹以创建我们的 tutorials 页。&lt;/p&gt;
&lt;p&gt;在新建的 &lt;code&gt;content/tutorials/&lt;/code&gt; 文件夹下创建一个名为 &lt;code&gt;_index.md&lt;/code&gt; 的文件，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;+++
title = &amp;quot;Tutorials&amp;quot;  # Add a page title.
date = 2017-01-01T00:00:00  # Add today&#39;s date.
widgets = true  # Page type is a Widget Page.
summary = &amp;quot;&amp;quot;  # Add a page description.
+++
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将你的小部件放入 &lt;code&gt;content/tutorials/&lt;/code&gt; 文件夹，可以通过复制 &lt;code&gt;content/home/&lt;/code&gt; 下的小部件或者从 &lt;a href=&#34;https://github.com/gcushen/hugo-academic/tree/master/exampleSite/content/home&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github&lt;/a&gt; 上下载来实现。&lt;/p&gt;
&lt;h2 id=&#34;创建其他页面-eg-简历&#34;&gt;创建其他页面 (e.g. 简历)&lt;/h2&gt;
&lt;p&gt;其他类型内容的话，可以创建自己的自定义页面。
例如，我们在 &lt;code&gt;content&lt;/code&gt; 文件夹下创建一个 &lt;code&gt;cv.md&lt;/code&gt; 简历页面。复制任意一个文章的扉页，根据需要进行调整，然后在下面编辑 Markdown 内容。
再之后，您可以使用 &lt;code&gt;[My CV]{``{&amp;lt; ref &amp;quot;cv.md&amp;quot; &amp;gt;}}&lt;/code&gt; 代码将简历添加到任何现有页面的内容上。&lt;/p&gt;
&lt;p&gt;或者，在上面的例子中，我们可以使用简历的 PDF 文件。为此，在 &lt;code&gt;static&lt;/code&gt; 文件夹中创建名为 &lt;code&gt;files&lt;/code&gt; 的文件夹，并将名为 &lt;code&gt;cv.pdf&lt;/code&gt; 的 PDF 文件移动到该位置。
然后可以使用以下代码将 PDF 文件链接到你的任意内容中：&lt;code&gt;{``{% staticref &amp;quot;files/cv.pdf&amp;quot; %}}`` 下载我的简历 ``{``{% /staticref %}}&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;管理列表页&#34;&gt;管理列表页&lt;/h2&gt;
&lt;p&gt;档案 (archive，我理解的就是列表) 页或者说节点页，是列出你所有内容的特殊页面。
博客文章、出版物、演讲都会有列表页。
如果存在一个小部件放不下的内容的话，主页上的小部件会自动链接到列表页。
因此，如果你没有足够多的内容的话你可能不会看到自动生成的链接——
不过你也可以在文章中用一般的 Markdown 链接格式，手动的链接他们。&lt;/p&gt;
&lt;p&gt;你可以通过将以下 &lt;code&gt;_index.md&lt;/code&gt; 文件从示例站点复制到你的 &lt;code&gt;content/&lt;/code&gt; 文件夹中的相同位置，来编辑标题并添加自己的内容（比如简介）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/themes/academic/exampleSite/content/post/_index.md
/themes/academic/exampleSite/content/publication/_index.md
/themes/academic/exampleSite/content/talk/_index.md
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后，根据需要编辑每个 &lt;code&gt;_index.md&lt;/code&gt; 中的 &lt;code&gt;title&lt;/code&gt; 参数，并在扉页之后添加任何内容。
你可能注意到 &lt;code&gt;_index.md&lt;/code&gt; 文件略有不同，其中一些具有可用于关联内容类型的特殊选项。
例如，&lt;code&gt;publication/_index.md&lt;/code&gt; 包含用于设置出版物列表页面上显示的列表的引用样式的选项。&lt;/p&gt;
&lt;h2 id=&#34;移除内容&#34;&gt;移除内容&lt;/h2&gt;
&lt;p&gt;通常来说，要移除任意内容，简单的从你的 &lt;code&gt;content/post&lt;/code&gt;、&lt;code&gt;content/publication&lt;/code&gt;、&lt;code&gt;content/project&lt;/code&gt; 或者 &lt;code&gt;content/talk&lt;/code&gt; 文件夹中删除对应页面文件即可。&lt;/p&gt;
&lt;h2 id=&#34;查看站点更新&#34;&gt;查看站点更新&lt;/h2&gt;
&lt;p&gt;在你对站点做出修改之后，你可以通过执行 &lt;code&gt;hugo server&lt;/code&gt; 并在浏览器中打开 &lt;a href=&#34;http://localhost:1313/&#34;&gt;http://localhost:1313/&lt;/a&gt; 来看到效果。&lt;/p&gt;
&lt;h2 id=&#34;部署站点&#34;&gt;部署站点&lt;/h2&gt;
&lt;p&gt;最后，你可以 &lt;a href=&#34;https://sourcethemes.com/academic/docs/deployment/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;部署你的站点&lt;/a&gt; 了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tmux in 10 minutes</title>
      <link>https://szthanatos.github.io/post/tmux/</link>
      <pubDate>Tue, 01 Jan 2019 12:27:05 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/tmux/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#简介&#34;&gt;简介&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#安装-tmux&#34;&gt;安装 tmux&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#基础概念&#34;&gt;基础概念&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#配置&#34;&gt;配置&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#常用控制&#34;&gt;常用控制&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#会话&#34;&gt;会话&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#窗口&#34;&gt;窗口&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#窗格&#34;&gt;窗格&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#tpm-插件&#34;&gt;tpm 插件&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#鼠标操作&#34;&gt;鼠标操作&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Tmux 是一个终端复用软件，默认的 Linux 终端一个会话只能干一件事，有了 tmux 就能在一个窗口同时管理多个前 / 后台程序了。&lt;/p&gt;
&lt;h2 id=&#34;安装-tmux&#34;&gt;安装 tmux&lt;/h2&gt;
&lt;p&gt;基础软件，跳过&lt;/p&gt;
&lt;h2 id=&#34;基础概念&#34;&gt;基础概念&lt;/h2&gt;
&lt;p&gt;见图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://szthanatos.github.io/media/tmux.jpg&#34; alt=&#34;Tmux 页面&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Session&lt;/code&gt;：输入 tmux 后就创建了一个会话，一个会话是一组窗体的集合；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Window&lt;/code&gt;：会话中一个可见的窗口；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pane&lt;/code&gt;: 一个窗口可以分成多个窗格；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用 win10 任务视图 (Win+Tab 调出) 的概念来类比，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Pane&lt;/code&gt; 就是一个个应用窗口，在一个桌面上可以同时开多个 (但是不能堆叠，)；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Window&lt;/code&gt; 就是一组组桌面，同一时间你只能看到一个桌面&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Session&lt;/code&gt; 就是一个用户，区别就是 win10 同一个账户只能登陆一次，tmux 里相当于一个用户登陆 N 次。&lt;/p&gt;
&lt;p&gt;为了控制这些元素，tmux 分为三种模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;控制模式&lt;/code&gt;: （按下或者按住前缀 (tmux-prefix)，默认 ctrl+b, 下文用 &lt;code&gt;※ + X&lt;/code&gt; 表示按下前缀之后按 X，&lt;code&gt;※※ + Y&lt;/code&gt; 表示按住前缀的同时按 Y）相当于各种热键；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;命令模式&lt;/code&gt;: （输入 tmux 后接命令，或者在 tmux 内输入 &lt;code&gt;※ + shift + :&lt;/code&gt;）也就是输入命令，但是执行的不是系统命令，而是 tmux 自身的命令；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;一般模式&lt;/code&gt;:  正常打字；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;和 zsh 一样，得先配置才能用的舒坦。下面是我个人用的配置文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ctrl+b&lt;/code&gt; 被我替换为 &lt;code&gt;Ctrl+x&lt;/code&gt;，横竖分割窗格我分别设置为 &lt;code&gt;-&lt;/code&gt; 和 &lt;code&gt;\&lt;/code&gt;，刚好一横一竖嘛，并且启用了 tpm 管理 tmux 插件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;#-- base --#
# (可选) 设置 zsh 为默认 shell
set -g default-shell /bin/zsh

#-- settings --#
set -g mouse on # 开启鼠标切换窗格，按住 shift 复制粘贴
set -g base-index 1 # 窗口编号从 1 开始计数
set -g renumber-windows on # 关掉某个窗口后，编号重排
set -g pane-base-index 1 # 窗格编号从 1 开始计数
set -g display-panes-time 5000 # PREFIX-Q 显示编号的驻留时长，单位 ms
setw -g mode-keys vi # 进入复制模式的时候使用 vi 键位（默认是 EMACS）
setw -g allow-rename off # 禁止活动进程修改窗口名
setw -g automatic-rename off # 禁止自动命名新窗口
set -g default-terminal &amp;quot;tmux-256color&amp;quot; # 开启 256 colors 支持

#-- bindkeys --#
# 以下 3 行设置 ctrl+x 代替 ctrl+b 的快捷键
set -g prefix C-x
unbind C-b
bind C-x send-prefix

# 设置 tmux-prefix + \ 垂直分割窗格
unbind %
bind \ split-window -h
# 设置 tmux-prefix + - 水平分割窗格
unbind &#39;&amp;quot;&#39;
bind - split-window -v

# 设置 ctrl+vim 方式切换窗格
bind -n C-h select-pane -L
bind -n C-j select-pane -D
bind -n C-k select-pane -U
bind -n C-l select-pane -R

# plugins
# tmux plugin manager 插件管理
set -g @plugin &#39;tmux-plugins/tpm&#39;
set -g @plugin &#39;tmux-plugins/tmux-sensible&#39;
# 保存布局插件，tmux-prefix + ctrl+s/tmux-prefix + ctrl+r 保存 / 恢复
set -g @plugin &#39;tmux-plugins/tmux-resurrect&#39;
# 自动保存插件
set -g @plugin &#39;tmux-plugins/tmux-continuum&#39;

# tmux-resurrect 配置
# 恢复 shell 的历史记录, 只有无前台任务运行的窗格 才能被保存
set -g @resurrect-save-bash-history &#39;on&#39;
# 恢复窗格内容, 目前使用该功能时，请确保 tmux 的 default-command 没有包含 &amp;amp;&amp;amp; 或者 || 操作符，
# 否则将导致 bug。（查看 default-command 的值，请使用命令 tmux show -g default-command。）
set -g @resurrect-capture-pane-contents &#39;on&#39;
# 恢复 vim 会话
set -g @resurrect-strategy-vim &#39;session&#39;

# set -g @resurrect-save &#39;S&#39;
# set -g @resurrect-restore &#39;R&#39;

# tmux-continuum 配置
# 开启自动恢复
set -g @continuum-restore &#39;on&#39;
# 设置备份间隔（分钟，0 为不自动备份）
set -g @continuum-save-interval &#39;240&#39;
# 状态栏查看备份状态
# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)
set -g status-right &#39;Continuum status: #{continuum_status}&#39;

run &#39;/etc/.tmux/plugins/tpm/tpm&#39;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体配置步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编辑 &lt;code&gt;.tmux.conf&lt;/code&gt; 文件放到你的根目录下；&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;git clone https://github.com/tmux-plugins/tpm /etc/.tmux/plugins/tpm&lt;/code&gt; 将 tpm 安装到 &lt;code&gt;etc&lt;/code&gt; 目录下
(或者随你喜欢，我是个人和 root 共用一套配置，所以放个公共的地)；&lt;/li&gt;
&lt;li&gt;输入 &lt;code&gt;tmux source-file ~/.tmux.conf&lt;/code&gt; 载入配置；&lt;/li&gt;
&lt;li&gt;进入 tmux，输入 &lt;code&gt;※ + U&lt;/code&gt; 查看 tpm 插件更新，弹出页面默认打开命令模式，直接输入 &lt;code&gt;all&lt;/code&gt; 完成更新；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;常用控制&#34;&gt;常用控制&lt;/h2&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    注意，下列所有快捷键区分大小写。
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;会话&#34;&gt;会话&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;※ + d&lt;/td&gt;
&lt;td&gt;休眠&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + s&lt;/td&gt;
&lt;td&gt;以菜单方式显示和选择会话&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + L&lt;/td&gt;
&lt;td&gt;切换回上一次的会话&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;窗口&#34;&gt;窗口&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;※ + c&lt;/td&gt;
&lt;td&gt;创建新窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + n&lt;/td&gt;
&lt;td&gt;选择下一个窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + p&lt;/td&gt;
&lt;td&gt;选择前一个窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + l&lt;/td&gt;
&lt;td&gt;最近一次活跃窗口之间进行切换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + 0~9&lt;/td&gt;
&lt;td&gt;选择几号窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + ,&lt;/td&gt;
&lt;td&gt;重命名窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + .&lt;/td&gt;
&lt;td&gt;更改窗口的编号，但只能更改成未使用的编号，所以要交换窗口的话，得多次更改进行交换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + &amp;amp;&lt;/td&gt;
&lt;td&gt;关闭窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + w&lt;/td&gt;
&lt;td&gt;以菜单方式显示及选择窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + f&lt;/td&gt;
&lt;td&gt;在所有窗口中查找内容&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;窗格&#34;&gt;窗格&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;※ + z&lt;/td&gt;
&lt;td&gt;最大化 / 还原当前窗格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + &amp;quot;&lt;/td&gt;
&lt;td&gt;模向分隔窗格，&lt;strong&gt;替换为了 &lt;code&gt;-&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + %&lt;/td&gt;
&lt;td&gt;纵向分隔窗格，&lt;strong&gt;替换为了 &lt;code&gt;\&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + o&lt;/td&gt;
&lt;td&gt;跳到下一个分隔窗格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + x&lt;/td&gt;
&lt;td&gt;关闭窗格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + ;&lt;/td&gt;
&lt;td&gt;切换到最后一个使用的窗格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + ↑/↓/←/→&lt;/td&gt;
&lt;td&gt;切换到上 / 下 / 左 / 右的窗格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※※ + h/j/k/l&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;自定义配置，vim 方式切换窗格&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + q&lt;/td&gt;
&lt;td&gt;显示窗格编号，并在右上角显示窗格的长宽&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + 空格键&lt;/td&gt;
&lt;td&gt;自动排布窗格，可多次执行尝试多种布局&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;tpm-插件&#34;&gt;tpm 插件&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;※ + S&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;自定义配置，保存当前布局&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + R&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;自定义配置，还原保存的布局&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;鼠标操作&#34;&gt;鼠标操作&lt;/h2&gt;
&lt;p&gt;鼠标按住窗格的分割线可以修改窗格大小；&lt;/p&gt;
&lt;p&gt;如果你用 &lt;code&gt;wsltty&lt;/code&gt; 或者其他软件，发现右键 / 中键失效，记得按住修饰键 (比如 &lt;code&gt;Shift&lt;/code&gt;) 再试。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>about</title>
      <link>https://szthanatos.github.io/about/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      <guid>https://szthanatos.github.io/about/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Git Tips</title>
      <link>https://szthanatos.github.io/post/git/git_tips/</link>
      <pubDate>Fri, 14 Dec 2018 09:35:32 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/git/git_tips/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#deploy-keyssh-keygithub&#34;&gt;Deploy key/SSH key(github)&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#更换-git-协议&#34;&gt;更换 git 协议&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#强制覆盖本地文件&#34;&gt;强制覆盖本地文件&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#撤销修改&#34;&gt;撤销修改&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#add-之前撤销&#34;&gt;add 之前撤销&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#commit-之前撤销&#34;&gt;commit 之前撤销&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#push-之前撤销&#34;&gt;push 之前撤销&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#删除历史提交记录&#34;&gt;删除历史提交记录&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#忽略文件权限&#34;&gt;忽略文件权限&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;deploy-keyssh-keygithub&#34;&gt;Deploy key/SSH key(github)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Deploy key&lt;/code&gt; 是在 &lt;code&gt;项目主页&lt;/code&gt;-&lt;code&gt;setting&lt;/code&gt;-&lt;code&gt;Delpoy keys&lt;/code&gt; 下进行添加，如果勾选 &lt;code&gt;Allow write access&lt;/code&gt;，则相当于具有对这个项目的读写权限 (否则只能 &lt;code&gt;clone&lt;/code&gt; 不能 &lt;code&gt;push&lt;/code&gt;)。&lt;strong&gt;作用范围是这个项目。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SSH key&lt;/code&gt; 是在你 &lt;code&gt;个人主页&lt;/code&gt;-&lt;code&gt;Settings&lt;/code&gt;-&lt;code&gt;SSH and GPG keys&lt;/code&gt; 下进行添加。&lt;strong&gt;作用范围是你的账户下的所有项目。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同一个 &lt;code&gt;公钥&lt;/code&gt;，只能作为整个账户的 &lt;code&gt;SSH key&lt;/code&gt;，或者 &lt;strong&gt;一个项目&lt;/strong&gt; 的 &lt;code&gt;Deploy key&lt;/code&gt;。想为一台机器授予多个项目的读写权限的话，需要通过 &lt;code&gt;ssh-keygen&lt;/code&gt; 生成多个密钥，分别作为不同项目的 &lt;code&gt;Deploy key&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;更换-git-协议&#34;&gt;更换 git 协议&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;http&lt;/code&gt;/&lt;code&gt;https&lt;/code&gt; 协议连接仓库相比 &lt;code&gt;ssh&lt;/code&gt; 即不够安全，也会存在 &lt;code&gt;push&lt;/code&gt; 的时候必须输入用户名密码的问题。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;git remote -v&lt;/code&gt; 可以查看项目使用的协议。&lt;/p&gt;
&lt;p&gt;如果是新建的项目，推荐在一开始就使用 &lt;code&gt;git@github.com:{USER}/{PROJECT}.git&lt;/code&gt; 进行 &lt;code&gt;clone&lt;/code&gt;。这样默认都是用 &lt;code&gt;ssh&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;如果是已有项目，使用 &lt;code&gt;git remote set-url {repository} {url}&lt;/code&gt; 更改。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git remote -v
origin  https://github.com/abc/bcd.git (fetch)
origin  https://github.com/abc/bcd.git (push)

$ git remote set-url origin git@github.com:abc/bcd.git

$ git remote -v
origin  git@github.com:abc/bcd.git (fetch)
origin  git@github.com:abc/bcd.git (push)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;强制覆盖本地文件&#34;&gt;强制覆盖本地文件&lt;/h2&gt;
&lt;p&gt;啥都别说了，直接重来吧：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git fetch --all
git reset --hard origin/master
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;撤销修改&#34;&gt;撤销修改&lt;/h2&gt;
&lt;h3 id=&#34;add-之前撤销&#34;&gt;add 之前撤销&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 单个文件
git checkout FileName

# 所有文件
git checkout .
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;commit-之前撤销&#34;&gt;commit 之前撤销&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 取消暂存
git reset HEAD FileName

# 撤销修改
git checkout FileName
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;push-之前撤销&#34;&gt;push 之前撤销&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git reset [--hard|soft|mixed] [commit|HEAD]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;删除历史提交记录&#34;&gt;删除历史提交记录&lt;/h2&gt;
&lt;p&gt;commit 多了项目也会膨胀&amp;hellip; 清了一干二净。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 用 orphan 参数创建全新的分支
git checkout --orphan {new_branch}

# 添加所有文件
git add -A

# 提交
git commit -am &amp;quot;commit message&amp;quot;

# 删除原始分支
git branch -D {old_branch}

# 交换分支
git branch -m {old_branch}

# 强制提交变更
git push -f origin {old_branch}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;忽略文件权限&#34;&gt;忽略文件权限&lt;/h2&gt;
&lt;p&gt;文件在系统间转移的时候可能由于权限改变而使文件全都处于 &amp;ldquo;modified&amp;rdquo; 状态。（比如从 linux 到 Windows，权限会从 644 变成 755）可以以项目为单位设置忽略文件权限：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git config core.filemode false
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Academic 实现 Github Page 个人博客</title>
      <link>https://szthanatos.github.io/post/academic/academic_in_practice/</link>
      <pubDate>Sun, 09 Dec 2018 16:34:42 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/academic/academic_in_practice/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#hugo-安装--更新&#34;&gt;Hugo 安装 / 更新&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#安装--更新&#34;&gt;安装 / 更新&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#常用命令&#34;&gt;常用命令&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#academic-安装--更新&#34;&gt;Academic 安装 / 更新&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#通过-netlify&#34;&gt;通过 Netlify&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#通过-git&#34;&gt;通过 Git&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#部署到-github-pages&#34;&gt;部署到 Github Pages&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#原理&#34;&gt;原理&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#官方教程-缩减版&#34;&gt;官方教程 (缩减版)&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#脚本&#34;&gt;脚本&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#个性化配置&#34;&gt;个性化配置&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#configtoml-主要配置项解释&#34;&gt;config.toml 主要配置项解释&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#修改网站-logo&#34;&gt;修改网站 logo&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#给文章添加精选图&#34;&gt;给文章添加精选图&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#给文章添加头部背景&#34;&gt;给文章添加头部背景&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#目录&#34;&gt;目录&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#注意--警告标识&#34;&gt;注意 / 警告标识&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#消除短代码效果&#34;&gt;消除短代码效果&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#修改模板&#34;&gt;修改模板&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;hugo-安装--更新&#34;&gt;Hugo 安装 / 更新&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://gohugo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hugo&lt;/a&gt; 是使用 &lt;code&gt;Go&lt;/code&gt; 语言开发的静态站点生成器。不过无需准备 &lt;code&gt;Go&lt;/code&gt; 语言环境，可以直接通过二进制编译包进行跨平台部署。&lt;/p&gt;
&lt;p&gt;以下均以 Ubuntu18.0 为例。&lt;/p&gt;
&lt;h3 id=&#34;安装--更新&#34;&gt;安装 / 更新&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;前往 &lt;a href=&#34;https://github.com/gohugoio/hugo/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github 页面&lt;/a&gt; 下载最新版本，这里我们下载 &lt;code&gt;hugo_0.52_Linux-64bit.deb&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;使用命令 &lt;code&gt;dpkg -i hugo_0.52_Linux-64bit.deb&lt;/code&gt; 安装 hugo;&lt;/li&gt;
&lt;li&gt;更新即重复上面两步，覆盖安装即可;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;常用命令&#34;&gt;常用命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;hugo&lt;/code&gt;&lt;/strong&gt;： 编译项目生成静态网站，默认位置在项目的 &lt;code&gt;public&lt;/code&gt; 目录下&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;hugo server&lt;/code&gt;&lt;/strong&gt;： 启动你的网站服务，可以通过浏览器访问 &lt;code&gt;http://127.0.0.1:1313/&lt;/code&gt; 访问站点;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;hugo new {folder}/{name}.md&lt;/code&gt;&lt;/strong&gt;: 创建新文章，使用 &lt;code&gt;markdown&lt;/code&gt; 进行排版，一般默认放在 &lt;code&gt;post&lt;/code&gt; 文件夹下；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本没了，一般情况下用这三个命令就够了。&lt;/p&gt;
&lt;h2 id=&#34;academic-安装--更新&#34;&gt;Academic 安装 / 更新&lt;/h2&gt;
&lt;p&gt;Academic 是一个 Hugo 主题，从名字就可以知道这个主题比较学院派，适合科研 / 学术人员发布个人信息 / 介绍科研项目，当然，拿来做个人博客也是没问题的。&lt;/p&gt;
&lt;h3 id=&#34;通过-netlify&#34;&gt;通过 Netlify&lt;/h3&gt;
&lt;p&gt;Academic 推荐使用第三方博客管理平台 &lt;a href=&#34;https://app.netlify.com/start/deploy?repository=https://github.com/sourcethemes/academic-kickstart&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netlify&lt;/a&gt; 安装，如果你没有域名或者没想建站，只是想自己使用，那我建议不使用它的服务——请直接跳到下一部分，否则跟随网站引导完成安装;&lt;/p&gt;
&lt;h3 id=&#34;通过-git&#34;&gt;通过 Git&lt;/h3&gt;
&lt;h4 id=&#34;安装&#34;&gt;安装&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;通过 git 安装的话，首先建议你在 GitHub 上 fork 成你自己的项目，默认的话，通过 &lt;code&gt;git clone https://github.com/sourcethemes/academic-kickstart.git My_Website&lt;/code&gt; 将代码克隆到本地文件夹 &lt;code&gt;My_Website&lt;/code&gt; &lt;em&gt;(当然，更推荐使用 ssh 协议，更安全，也免于 push 时输入密码，这里暂时按官方的来)&lt;/em&gt; ;&lt;/li&gt;
&lt;li&gt;进入文件夹，初始化项目：&lt;code&gt;git submodule update --init --recursive&lt;/code&gt;，完成安装;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;自动更新&#34;&gt;自动更新&lt;/h4&gt;
&lt;p&gt;说是自动，还是需要手动执行一条命令：&lt;code&gt;git submodule update --remote --merge&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;这么做的前提条件是你是 &lt;code&gt;install&lt;/code&gt; 的，也就是 &lt;code&gt;git submodule update --init --recursive&lt;/code&gt; 过的，而不是直接把 &lt;code&gt;academic&lt;/code&gt; 给 clone 到 themes 文件夹。&lt;/p&gt;
&lt;h4 id=&#34;手动更新&#34;&gt;手动更新&lt;/h4&gt;
&lt;p&gt;如果是 clone 到 themes 文件夹的话要这么更新：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;cd themes/academic&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;origin&lt;/code&gt; 仓库重命名为 &lt;code&gt;upstream&lt;/code&gt;：&lt;code&gt;git remote rename origin upstream&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;将更新下载到本地：&lt;code&gt;git fetch upstream&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;列出可用更新：&lt;code&gt;git log --pretty=oneline --abbrev-commit --decorate HEAD..upstream/master&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;更新：&lt;code&gt;git pull upstream&lt;/code&gt;;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;部署到-github-pages&#34;&gt;部署到 Github Pages&lt;/h2&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;网上介绍的办法很多，但核心其实就一句：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将 &lt;code&gt;hugo&lt;/code&gt; 命令生成的 &lt;code&gt;public&lt;/code&gt; 文件夹上传到 GitHub pages 项目下&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; 文件夹相当于编译完成的静态网站，你在本地打开其实就能看。换句话说，你每次手动将这个目录下的内容上传到你的 GitHub page 项目也是可以的。&lt;/p&gt;
&lt;p&gt;然后为了达到这个目的，Academic 给出的做法是利用 &lt;code&gt;git submodule&lt;/code&gt; 将你的 &lt;code&gt;GitHub page&lt;/code&gt; 项目作为 &lt;code&gt;My_Website&lt;/code&gt; 项目的子模块存放到 &lt;code&gt;public&lt;/code&gt; 目录。那么当你更新你的文章之后，只提交 &lt;code&gt;public&lt;/code&gt; 文件夹内的变更到 &lt;code&gt;GitHub page&lt;/code&gt; 项目即可。&lt;/p&gt;
&lt;h3 id=&#34;官方教程-缩减版&#34;&gt;官方教程 (缩减版)&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&#34;https://sourcethemes.com/academic/docs/deployment/#github-pages&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;原教程&lt;/a&gt; 看这里；&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 GitHub 上创建两个项目，一个是 fork 的 &lt;a href=&#34;https://github.com/sourcethemes/academic-kickstart.git&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;academic-kickstart&lt;/a&gt;，也就是你前面 clone 到本地的 &lt;code&gt;My_Website&lt;/code&gt;，另一个即是以你用户名 / 组织名开头、以 &lt;code&gt;.github.io&lt;/code&gt; 结尾的 GitHub page 项目。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;My_Website&lt;/code&gt; 目录下执行 &lt;code&gt;git submodule update --init --recursive&lt;/code&gt; 将子模块更新到最新状态；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 &lt;code&gt;config.toml&lt;/code&gt; 中的 &lt;code&gt;baseurl&lt;/code&gt; 设置为你的 GitHub page 地址；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;(实质)&lt;/strong&gt; 删除 &lt;code&gt;public&lt;/code&gt; 文件夹 (如果有的话)，将 GitHub page 项目添加为子模块：&lt;code&gt;git submodule add -f -b master https://github.com/&amp;lt;USERNAME&amp;gt;/&amp;lt;USERNAME&amp;gt;.github.io.git public&lt;/code&gt;;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;这时候你的 &lt;code&gt;My_Website&lt;/code&gt; 项目实际上有两个子模块：作为主题依赖的 &lt;code&gt;themes/academic&lt;/code&gt; 和作为网站的 &lt;code&gt;&amp;lt;USERNAME&amp;gt;.github.io&lt;/code&gt;；&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;有意思的是一般是子模块 &lt;code&gt;themes/academic&lt;/code&gt; 更新了之后，你更新主项目 &lt;code&gt;My_Website&lt;/code&gt; 的依赖；&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;而你更新主项目 &lt;code&gt;My_Website&lt;/code&gt; 的文章之后，再会手动的更新子模块 &lt;code&gt;&amp;lt;USERNAME&amp;gt;.github.io&lt;/code&gt;，刚好反过来。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新增 / 编辑文章后，更新 &lt;code&gt;academic-kickstart&lt;/code&gt; 项目：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;Initial commit&amp;quot;
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新 GitHub page 项目：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo
cd public
git add .
git commit -m &amp;quot;Build website&amp;quot;
git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实际上只有第六步是更新 GitHub page，每次重复执行这一部分就行 (如果你不把文章保存到 &lt;code&gt;academic-kickstart&lt;/code&gt; 的话)。&lt;/p&gt;
&lt;h3 id=&#34;脚本&#34;&gt;脚本&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Hugo&lt;/code&gt; 官方把上面步骤打包到了一个脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

echo -e &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m&amp;quot;

# Build the project.
hugo # if using a theme, replace with `hugo -t &amp;lt;YOURTHEME&amp;gt;`

# Go To Public folder
cd public
# Add changes to git.
git add .

# Commit changes.
msg=&amp;quot;rebuilding site `date`&amp;quot;
if [$# -eq 1]
  then msg=&amp;quot;$1&amp;quot;
fi
git commit -m &amp;quot;$msg&amp;quot;

# Push source and build repos.
git push origin master

# Come Back up to the Project Root
cd ..
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际上我们干脆连第五步也放进去呗：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
# Receive args.
if [$1 = &amp;quot;push&amp;quot;]; then
    if [$# -eq 1]; then
        TIME_NOW=$(date +%T\ %F)
        MSG=&amp;quot;Change something nobody knows at ${TIME_NOW}...&amp;quot;
        EDITED_FILE=&amp;quot;.&amp;quot;

    elif [$# -eq 2]; then
        MSG=&amp;quot;$2&amp;quot;
        EDITED_FILE=&amp;quot;.&amp;quot;

    elif [$# -gt 2]; then
        MSG=&amp;quot;$2&amp;quot;
        shift 2
        EDITED_FILE=&amp;quot;$*&amp;quot;

    else
        echo &amp;quot;WTF?&amp;quot;

    fi

    echo &amp;quot;\033[0;32m
    ---------------------------
    Deploying to GitHub Page...
    ---------------------------
    \033[0m&amp;quot;

    # Build the project.
    hugo # if using a theme, replace with `hugo -t &amp;lt;YOURTHEME&amp;gt;`

    # Go To Public folder
    cd public

    # Add changes to git.
    git add .

    # Commit changes.
    git commit -m &amp;quot;$MSG&amp;quot;

    # Push source and build repos.
    git push origin master

    # Come Back up to the Project Root
    cd ..

    echo &amp;quot;\033[0;32m
    -----------------------------
    Updating content to GitHub...
    -----------------------------
    \033[0m&amp;quot;

    # Add changes to git.
    git add $EDITED_FILE

    # Commit changes.
    git commit -m &amp;quot;$MSG&amp;quot;

    # Push source and build repos.
    git push origin master

elif [$1 = &amp;quot;pull&amp;quot;]; then

    # Update main repo.
    git pull

    # Update submodule.
    git submodule update

    echo &amp;quot;Synchronize finish.&amp;quot;

else
    echo &amp;quot;Determine What you wanna do.&amp;quot;

fi

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将脚本保存为 &lt;code&gt;deploy.sh&lt;/code&gt;，放到项目根目录下，完成修改后执行 &lt;code&gt;./deploy.sh&lt;/code&gt; + &lt;code&gt;pull&lt;/code&gt;/&lt;code&gt;push&lt;/code&gt; 一键从服务器同步 / 提交 + 部署。&lt;/p&gt;
&lt;p&gt;参数的第一个是你要执行的动作，从远程服务器 down 到本地的话就是 &lt;code&gt;./deploy.sh pull&lt;/code&gt;，不用接别的。&lt;/p&gt;
&lt;p&gt;如果是要将更新上传到服务器并部署，那就执行 &lt;code&gt;./deploy.sh push&lt;/code&gt; + commit message，提交消息可以不写 (但最好还是写一下)：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./deploy.sh push &amp;quot;{Your optional commit message}&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果修改了多个文件，只想提交其中的一部分文件以保持 commit 的纯净，那就在 mesaage 后面附加你要提交的文件路径 (不超过 10 个&amp;hellip;)：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./deploy.sh push &amp;quot;{Your optional commit message}&amp;quot; path1 path2...&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;个性化配置&#34;&gt;个性化配置&lt;/h2&gt;
&lt;p&gt;项目目录结构大体如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;content 目录&lt;/code&gt;： 网站内容，&lt;code&gt;home&lt;/code&gt; 是你的主页的小控件，&lt;code&gt;post&lt;/code&gt; 是默认文章存放位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public 目录&lt;/code&gt;： 生成的静态页面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resouces 目录&lt;/code&gt;： JS 资源存放位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static 目录&lt;/code&gt;： 静态资源存放位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;themes 目录&lt;/code&gt;： 主题文件所在目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;config.toml&lt;/code&gt;: 全局配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;configtoml-主要配置项解释&#34;&gt;config.toml 主要配置项解释&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;配置项&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;baseurl&lt;/td&gt;
&lt;td&gt;你的站点的 url，不设置这个你的文章 / 资源可能相互引用不到&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;title&lt;/td&gt;
&lt;td&gt;网站标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;defaultContentLanguage&lt;/td&gt;
&lt;td&gt;默认语言，中文的话填 &lt;code&gt;zh&lt;/code&gt;，在文件末尾还有一处配置要同时修改才行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hasCJKLanguage&lt;/td&gt;
&lt;td&gt;是否有中 / 日 / 韩语&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;defaultContentLanguageInSubdir&lt;/td&gt;
&lt;td&gt;目录是否允许用默认语言，&lt;code&gt;true&lt;/code&gt; 就对了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;highlight_languages&lt;/td&gt;
&lt;td&gt;语法高亮，支持的语言可以去 &lt;a href=&#34;https://cdnjs.com/libraries/highlight.js/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;highlight.js&lt;/a&gt; 查到&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[[menu.main]]&lt;/td&gt;
&lt;td&gt;这部分是你主页上标题栏显示的内容，&lt;code&gt;url&lt;/code&gt; 默认和你 &lt;code&gt;content/home&lt;/code&gt; 下的文件名对应&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Languages&lt;/td&gt;
&lt;td&gt;添加中文支持的话，把 &lt;code&gt;[languages.zh]&lt;/code&gt; 部分解除注释，&lt;code&gt;languageCode&lt;/code&gt; 写 &lt;code&gt;&amp;quot;zh-cn&amp;quot;&lt;/code&gt;，添加其他语种的话，相同格式再写一组 &lt;code&gt;[languages.XX]&lt;/code&gt; 即可，支持的语言代码可以在 &lt;code&gt;themes\academic\i18n&lt;/code&gt; 查看&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;修改网站-logo&#34;&gt;修改网站 logo&lt;/h3&gt;
&lt;p&gt;默认的 logo 是 Academic 的蓝色学位帽，想替换的话将你想用的 logo 保存为
&lt;code&gt;icon.png&lt;/code&gt;(默认 32&lt;em&gt;32 像素，大了也没关系)
和 &lt;code&gt;icon-192.png&lt;/code&gt;(192&lt;/em&gt;192 像素)，并放到项目的 &lt;code&gt;static/img&lt;/code&gt; 目录下&lt;/p&gt;
&lt;h3 id=&#34;给文章添加精选图&#34;&gt;给文章添加精选图&lt;/h3&gt;
&lt;p&gt;这个图片只能添加一个，名字必须是 &lt;code&gt;featured.*&lt;/code&gt;(后缀 jpg/png 都行)，而且必须和文章放在同一个文件夹下。&lt;/p&gt;
&lt;p&gt;所以一般做法是把文章 &lt;code&gt;aaa.md&lt;/code&gt; 改名为 &lt;code&gt;index.md&lt;/code&gt; 并新建一个 &lt;code&gt;aaa&lt;/code&gt; 目录，再和 &lt;code&gt;featured.png&lt;/code&gt; 图片一起扔进去。&lt;/p&gt;
&lt;p&gt;显示的效果是在文章列表页，文章右侧有一个缩略图；打开文章，标题默认会居左，右边是精选图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://szthanatos.github.io/media/featured_image_example.png&#34; alt=&#34;example&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;给文章添加头部背景&#34;&gt;给文章添加头部背景&lt;/h3&gt;
&lt;p&gt;这个是文章头部的横跨整个页面的大图，也就是文章头部这个黑底白字的大图。&lt;/p&gt;
&lt;p&gt;这个的图片可以放到 &lt;code&gt;static/img&lt;/code&gt; 目录下，不过需要在你文件的 &lt;code&gt;+++&lt;/code&gt; 的部分添加如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;[header]
  image = &amp;quot;img 名称&amp;quot;
  caption = &amp;quot;标题说明&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;顺便一提，文章内引用 &lt;code&gt;static/img&lt;/code&gt; 下存储的图像的话，路径大致如此 &lt;code&gt;![example](/media/image_abc.png)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;目录&#34;&gt;目录&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;{``{% toc %}}&lt;/code&gt; 加在文章的任何你想要的地方以自动生成目录&lt;/p&gt;
&lt;h3 id=&#34;注意--警告标识&#34;&gt;注意 / 警告标识&lt;/h3&gt;
&lt;p&gt;被 &lt;code&gt;{``{% alert note %}}&lt;/code&gt; 和 &lt;code&gt;{``{% /alert %}}&lt;/code&gt; 包裹起来的内容即为注意项：&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    注意内容 blabla
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;被 &lt;code&gt;{``{% alert warning %}}&lt;/code&gt; 和 &lt;code&gt;{``{% /alert %}}&lt;/code&gt; 包裹起来的内容即为警告项：&lt;/p&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    警告内容 blabla
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;消除短代码效果&#34;&gt;消除短代码效果&lt;/h3&gt;
&lt;p&gt;Hugo 是基于 Go 的 Template，所以所有以 &lt;code&gt;{``{% %}}&lt;/code&gt; 或者 &lt;code&gt;{``{&amp;lt; &amp;gt;}}&lt;/code&gt; 包裹的内容都会被解析为短代码块，而无法直接显示其代码。
那么我是怎么解决的呢，分情况：&lt;/p&gt;
&lt;h4 id=&#34;单行代码&#34;&gt;单行代码&lt;/h4&gt;
&lt;p&gt;你看到的 &lt;code&gt;{``{% toc %}}&lt;/code&gt; 实际是由 &lt;code&gt;`{`&lt;/code&gt; 和 &lt;code&gt;`{% toc %}}`&lt;/code&gt; 组成的。&lt;/p&gt;
&lt;p&gt;而上面打出的 &lt;code&gt;`&lt;/code&gt; 其实是 &lt;code&gt;双反引号 空格 反引号 空格 双反引号&lt;/code&gt;，就不再嵌套了。。。&lt;/p&gt;
&lt;h4 id=&#34;代码块&#34;&gt;代码块&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; figure library=&amp;quot;1&amp;quot; src=&amp;quot;image.jpg&amp;quot; title=&amp;quot;A caption&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;的本质是将 &amp;lt;&amp;gt; 或者 %% 内的内容用 /**/ 注释掉：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{``{&amp;lt;/* figure library=&amp;quot;1&amp;quot; src=&amp;quot;image.jpg&amp;quot; title=&amp;quot;A caption&amp;quot; */&amp;gt;}}&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    谁知道 Markdown 的代码块怎么嵌套&amp;hellip;
比如外层一个 markdown 的代码块，
里面要显示包含反引号格式的 python 代码块&amp;hellip;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;修改模板&#34;&gt;修改模板&lt;/h3&gt;
&lt;p&gt;比如你看到我每个文章结尾都有一个 &lt;a href=&#34;http://creativecommons.org/licenses/by-sa/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;CC4.0 协议&lt;/code&gt;&lt;/a&gt; 的标志，这个肯定不是一篇篇手动添加的，实际上我是自己写了一个 License 的 Widget，插入到文章的模板里面实现的。&lt;/p&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    不要直接修改 &lt;code&gt;theme&lt;/code&gt; 里面的内容，否则更新主题的时候会非常尴尬。
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;正确的做法是在项目根目录建立 &lt;code&gt;layouts&lt;/code&gt; 文件夹，将你想修改的模板从 &lt;code&gt;themes/academic/layouts&lt;/code&gt; 拷贝过来再修改。&lt;/p&gt;
&lt;p&gt;现在 Academic 主题的 layouts 大概是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_default&lt;/code&gt;: 默认文章相关模板；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docs&lt;/code&gt;: 文档相关模板;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;home&lt;/code&gt;: 主页相关模板;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;partials&lt;/code&gt;: 小部件相关模板，页面头部 / 脚注 / 摘要等等的都在这;
&lt;ul&gt;
&lt;li&gt;额外的有一个 &lt;code&gt;widgets&lt;/code&gt; 文件夹，里面是主页的 widget 的模板；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;project&lt;/code&gt;: 项目相关模板;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;publication&lt;/code&gt;: 出版物相关模板;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;section&lt;/code&gt;: 摘要相关模板;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shortcodes&lt;/code&gt;: Academic 提供的额外效果模板，你写的所有 &lt;code&gt;{``{%%}}&lt;/code&gt; 的内容效果都出自这里;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slides&lt;/code&gt;: 幻灯片相关模板;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;talk&lt;/code&gt;: 宣讲相关模板;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;继续用我自己做例子，我新建了 &lt;code&gt;layouts/partials/license.html&lt;/code&gt;，把 CC 协议相关内容存了进去，
接着，复制主题目录下的 &lt;code&gt;layouts/_default/single.html&lt;/code&gt; 到对应位置，在合适地方插入一句 &lt;code&gt;{{partial &amp;quot;license.html&amp;quot; .}}&lt;/code&gt;，表明我要在这里使用名为 &lt;code&gt;license.html&lt;/code&gt; 的 &lt;code&gt;partial&lt;/code&gt;。
再之后就是你们看到的效果了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>hbase 表设计风格指南</title>
      <link>https://szthanatos.github.io/post/hbase_design/</link>
      <pubDate>Sun, 09 Dec 2018 16:19:27 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/hbase_design/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#简介&#34;&gt;简介&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#一般原则&#34;&gt;一般原则&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#命名空间-namespace&#34;&gt;命名空间 (NameSpace)&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#命名规范&#34;&gt;命名规范&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#示例&#34;&gt;示例&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#表-table&#34;&gt;表 (Table)&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#命名规范-1&#34;&gt;命名规范&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#示例-1&#34;&gt;示例&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#行键-rowkey&#34;&gt;行键 (Rowkey)&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#命名规范-2&#34;&gt;命名规范&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#示例-2&#34;&gt;示例&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#注意&#34;&gt;注意&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#列族-columnfamily&#34;&gt;列族 (ColumnFamily)&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#命名规范-3&#34;&gt;命名规范&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#示例-3&#34;&gt;示例&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#注意-1&#34;&gt;注意&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#列-qualifier&#34;&gt;列 (Qualifier)&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#命名规范-4&#34;&gt;命名规范&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#示例-4&#34;&gt;示例&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;本指南是对在 HBase 进行字段设计而提供的指导性准则和建议。总体标准、设计方式参照 &lt;a href=&#34;https://github.com/google/styleguide&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google 开源项目风格指南&lt;/a&gt; 以及现有项目经验。所有条目均为个人总结，&lt;strong&gt;并不是一份官方标准性质的指南&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;HBase 是建立在 Hadoop 文件系统（HDFS）之上的分布式、面向列的数据库。&lt;/p&gt;
&lt;h2 id=&#34;一般原则&#34;&gt;一般原则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;无论是表或者是列或者其他，都应该使用名词或者动宾短语以代表一类对象;&lt;/li&gt;
&lt;li&gt;尽量避免使用 (尤其是单独使用) 例如 &lt;code&gt;int&lt;/code&gt;、&lt;code&gt;join&lt;/code&gt;、&lt;code&gt;select&lt;/code&gt; 等常见保留词;&lt;/li&gt;
&lt;li&gt;HBase 在性能和效率上更擅长处理 “高而瘦” 的表，而非 “矮而胖” 的表——以 Excel 类比，HBase 应该尽可能设计成只有很少的列 (瘦) 而有非常多行 (高) 的模式;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;命名空间-namespace&#34;&gt;命名空间 (NameSpace)&lt;/h2&gt;
&lt;h3 id=&#34;命名规范&#34;&gt;命名规范&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;采用英文单词、阿拉伯数字的组合形式，其中，单词必须大写，并且首字符必须为英文字符，不能是数字;&lt;/li&gt;
&lt;li&gt;不建议用连接符（下划线）拼接多个单词，简单语义的可采用单个单词，复杂语义的可采用多个单词的首字母拼接;&lt;/li&gt;
&lt;li&gt;长度尽量限制在 4~8 字符之间;&lt;/li&gt;
&lt;li&gt;命名空间一般可与项目名称、组织机构名称等保持一致;&lt;/li&gt;
&lt;li&gt;一般情况下如果不指定命名空间，表会被放在默认 (default) 命名空间下;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ZKR
XJ917
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;表-table&#34;&gt;表 (Table)&lt;/h2&gt;
&lt;h3 id=&#34;命名规范-1&#34;&gt;命名规范&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;采用英文单词、阿拉伯数字、连接符（_）的组合形式，其中，单词必须大写，并且首字符必须为英文字符，可用连接符拼接多个单词;&lt;/li&gt;
&lt;li&gt;长度尽量限制在 8~16 字符之间;&lt;/li&gt;
&lt;li&gt;尽量采用具有明确意义的英文单词，而不建议采用汉字的拼音字母或者拼音首字母组合;&lt;/li&gt;
&lt;li&gt;无需以 &lt;code&gt;TABLE&lt;/code&gt; 结尾;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示例-1&#34;&gt;示例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;USER_INFO
WEIBO_USER_FANS
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;行键-rowkey&#34;&gt;行键 (Rowkey)&lt;/h2&gt;
&lt;h3 id=&#34;命名规范-2&#34;&gt;命名规范&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;采用英文单词、阿拉伯数字、非转义字符组合形式，不要求大小写，但首字符必须是英文字符或数字;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示例-2&#34;&gt;示例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;123456-654321
dftf3a3l3rv3qr
s.taobo.com/faefavc
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注意&#34;&gt;注意&lt;/h3&gt;
&lt;h4 id=&#34;慎重将时间戳直接放入行键中&#34;&gt;慎重将时间戳直接放入行键中&lt;/h4&gt;
&lt;p&gt;对于同一条数据，HBase 本身提供时间戳 (TimeStamp) 以在同一个 RowKey 下保存不同版本数据;
对于整体，存放旧数据的区域随着时间戳增大可能不再写入，而存放新数据的区域始终保持高负荷，这样降低了 HBase 整体的读写能力。&lt;/p&gt;
&lt;p&gt;一个推荐的方式是使用反向时间戳。&lt;/p&gt;
&lt;h4 id=&#34;权衡-hash-和-string-的效果&#34;&gt;权衡 hash 和 string 的效果&lt;/h4&gt;
&lt;p&gt;哈希化 (一般特指单项哈希) 的 Rowkey 能很好的避免热点问题，但是也会同时丢失直接使用 String 的 RowKey 的天然聚类和排序的能力。&lt;/p&gt;
&lt;h2 id=&#34;列族-columnfamily&#34;&gt;列族 (ColumnFamily)&lt;/h2&gt;
&lt;h3 id=&#34;命名规范-3&#34;&gt;命名规范&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;采用英文单词、阿拉伯数字的组合形式，其中，单词必须大写，并且首字符必须为英文字符，不能是数字;&lt;/li&gt;
&lt;li&gt;长度尽量限制在 1~6 字符之间，过长的列族名称将占用更多的存储空间, 它们不应该像在典型的 RDBMS 中一样具有自我记录和描述性;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示例-3&#34;&gt;示例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;DATA
D1 # data1
WA # web args
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注意-1&#34;&gt;注意&lt;/h3&gt;
&lt;h4 id=&#34;列族的数量应控制在-1-3-个&#34;&gt;列族的数量应控制在 1-3 个&lt;/h4&gt;
&lt;p&gt;HBase 表不应该被设计成模拟 RDBMS 表，列族的数量在满足需求的情况下应该尽可能少。在存储时，一个列族会存储成一个 StoreFile，多个列族对应的多个文件在分裂时会对服务器造成更大的压力。&lt;/p&gt;
&lt;h2 id=&#34;列-qualifier&#34;&gt;列 (Qualifier)&lt;/h2&gt;
&lt;h3 id=&#34;命名规范-4&#34;&gt;命名规范&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;采用英文单词、阿拉伯数字、连接符（_）的组合形式，其中，单词必须 ** 小写 **，并且首字符必须为英文字符，不能是数字，可用连接符拼接多个单词;&lt;/li&gt;
&lt;li&gt;所有列名都应该是名词或者以 &lt;code&gt;is&lt;/code&gt; 开头的动宾短语 (表示判断)，不应该使用其他词性单词;&lt;/li&gt;
&lt;li&gt;允许使用前缀，不允许使用后缀;&lt;/li&gt;
&lt;li&gt;长度尽量限制在 1~16 字符之间;&lt;/li&gt;
&lt;li&gt;尽量采用具有明确意义的英文单词，而不建议采用汉字的拼音字母或者拼音首字母组合;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示例-4&#34;&gt;示例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;user_name
is_str
sound_type
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Palantir 一分钟印象</title>
      <link>https://szthanatos.github.io/post/palantir_intro/</link>
      <pubDate>Wed, 05 Dec 2018 17:09:21 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/palantir_intro/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#简介&#34;&gt;简介&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#最新情况&#34;&gt;最新情况&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#创始人&#34;&gt;创始人&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#发展历程&#34;&gt;发展历程&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#产品内容&#34;&gt;产品内容&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#官方主页-home--palantirhttpswwwpalantircom&#34;&gt;官方主页： &lt;a href=&#34;https://www.palantir.com/&#34;&gt;Home | Palantir&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#产品线&#34;&gt;产品线&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#解决方案&#34;&gt;解决方案&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Palantir 是全球第一大 &lt;code&gt;大数据公司&lt;/code&gt;。曾经的全球四大独角兽之一（其它三家是 Uber，Airbnb 和小米）。中文名帕兰提尔，源于《指环王》中邪恶巫师萨鲁曼使用的可穿越时空、洞悉世间一切的水晶球 (Palantiri)。主要客户为政府机构和金融机构。&lt;/p&gt;
&lt;p&gt;最出名的案例是以大数据技术帮助美国军方成功定位和击毙基地组织首脑本 · 拉登，以及协助多家银行追回了纳斯达克前主席麦道夫 Bernie Madoff 的庞氏骗局中所隐藏起来的数十亿美元巨款。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;最新情况&#34;&gt;最新情况&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2018 年 10 月 29 日&lt;/strong&gt;，Palantir 正在建立 ICE 的案例管理软件 —— &lt;a href=&#34;http://aldianews.com/articles/politics/immigration/technology-companies-are-ices-dark-allies/54287&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AL DIA News&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2018 年 10 月 23 日&lt;/strong&gt;，亚马逊、微软、Palantir 等科技公司在特朗普的移民法案中起到重要作用 —— &lt;a href=&#34;https://www.commondreams.org/news/2018/10/23/amazon-microsoft-and-palantir-among-tech-giants-making-huge-profits-trumps&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Common Dreams&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2018 年 10 月 19 日&lt;/strong&gt;，Palantir 或明年上市，估值达 410 亿美元 —— &lt;a href=&#34;https://www.vanityfair.com/news/2018/10/palantir-peter-thiels-all-seeing-eye-looks-to-a-41-billion-dollar-ipo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MAYA KOSOFF&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2018 年 09 月 14 日&lt;/strong&gt;，美国陆军决议中止对 Palantir2.06 亿美元的采购合同 —— &lt;a href=&#34;https://www.law360.com/articles/1082813/army-wrongly-ignored-palantir-in-206m-deal-fed-circ-says&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LAW 360&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2018 年 03 月 14 日&lt;/strong&gt;，雷神、Palantir 拿下美国陆军 8.76 亿美元合同 —— &lt;a href=&#34;https://www.reuters.com/article/us-raytheon-pentagon/raytheon-palantir-win-876-million-u-s-defense-contract-pentagon-idUSKCN1GL2HR&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;reuters&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2018 年 03 月 02 日&lt;/strong&gt;，传 Palantir 在新奥尔良秘密测试犯罪预测技术，最神秘的独角兽再陷隐私风波 —— &lt;a href=&#34;https://www.lieyunwang.com/archives/416481&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;猎云网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Palantir 发布 &lt;a href=&#34;https://www.palantir.com/philanthropy-engineering/annual-report/2017/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2017 年度报告&lt;/a&gt; 重点提到在哈维飓风的救援以及灾后重建工作，以及帮助世界粮食计划署运输食品以对抗饥饿的工作中所起到的作用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;创始人&#34;&gt;创始人&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Peter Thiel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;斯坦福本科及法学院 JD 的高材生，《从 0 到 1》的作者。创立了 Clarium Capital、Founders Fund、Valar Ventures、、Mithril Capital Management 等多支基金。Paypal 创始人之一并出任 CEO。2002 年 paypal 被收购之后，以投资人身份投资包括 Facebook、Asana、Quora、LinkedIn、Yelp、Yammer 在内的诸多当今一线公司。号称硅谷创投教父。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Alex Karp&lt;/strong&gt; (CEO)&lt;/p&gt;
&lt;p&gt;哈佛本科毕业，斯坦福法学 JD 学位，德国法兰克福大学新古典社会理论方向博士学位，师从本世纪最伟大的哲学家之一哈贝马斯。早年继承家产后成为硅谷著名投资人，并在伦敦创立 Caedmon Group 基金管理投资。目前坚持保持单身，热爱气功、游泳以及与员工讲马克思还有带领员工在硅谷打太极。Peter Thiel 在斯坦福的室友。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Joe Lonsdale&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;斯坦福计算机系毕业。除 Palantir 外，还曾创办另外两家高科技公司，和硅谷最大的面向亚洲的风投基金 Formation8、 8vc。管理着 5000 亿美元财富。此外，还是《福布斯》评选出的 12 位行业未来之星之一，还被美国媒体评为硅谷排名第二的天使投资人。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Stephen Cohen&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;毕业于斯坦福计算机系的高级工程师。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Nathan Gettings&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来自于 PayPal 的的高级工程师。在 PayPal 负责风险和研发的总监，曾以开发了反欺诈的系统而闻名于世。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;发展历程&#34;&gt;发展历程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2004 年 Palantir 公司创立于加利福尼亚州帕洛阿尔托。创业初期 Palantir 并不被人看好，融资过程也是屡屡受阻，包括红杉资本，凯鹏华盈两大 VC 基金都不看好 Palantir 的发展。经过多次奔走博弈，最终，Palantir 赢得了 CIA 的创投基金的 2 轮投资，从而走上了发展的正轨。&lt;/li&gt;
&lt;li&gt;2004 到 2009 年，Palantir 主要业务还是服务于美国政府部门，提供情报分析，防欺诈、反恐等服务。&lt;/li&gt;
&lt;li&gt;2010 年，Palantir 开始提供企业服务，实现业务多元化。&lt;/li&gt;
&lt;li&gt;2010 年 7 月，当时已经拥有 250 位工程师的 Palantir 完成 9000 万美元的 D 轮融资，估值达到 7.35 亿美元。&lt;/li&gt;
&lt;li&gt;2011 年 5 月 6 日，融资 5000 万美元，累计融资额达到了 1.75 亿美元。&lt;/li&gt;
&lt;li&gt;2011 年 10 月 7 日，融资 7000 万美元，估值 25 亿美元。&lt;/li&gt;
&lt;li&gt;2013 年 9 月 29 日，融资 1.96 亿美元，估值 60 亿美元。&lt;/li&gt;
&lt;li&gt;2013 年 12 月，Palantir 新一轮融资 1.075 亿美元，同时估值达到 90 亿美元。此时 Palantir 的年收入已经超过 4.5 亿美元。&lt;/li&gt;
&lt;li&gt;2014 年 11 月，Palantir 再拿到 5 亿美元投资，企业用户突破 14000 家，估值达到了 150 亿美元。&lt;/li&gt;
&lt;li&gt;2015 年年底，Palantir 获得 8.8 亿美元的融资，市值达到 200 亿美元。成为继 Uber、小米、Airbnb 之后，全球估值第四高的创业公司。（截至 2018 年 11 月最后一笔融资）&lt;/li&gt;
&lt;li&gt;2016 年 2 月，收购 Kimono Labs&lt;/li&gt;
&lt;li&gt;2016 年 5 月，Buzzfeed 爆料, 数司百名员工离职，多个重要客户不再续约。&lt;/li&gt;
&lt;li&gt;2016 年 8 月，Palantir 收购数据可视化公司 Silk。&lt;/li&gt;
&lt;li&gt;2018 年 10 月，Palantir 预备明年下半年上市，公司估值或将达 410 亿美元&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;产品内容&#34;&gt;产品内容&lt;/h2&gt;
&lt;h3 id=&#34;官方主页-home--palantirhttpswwwpalantircom&#34;&gt;官方主页： &lt;a href=&#34;https://www.palantir.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Home | Palantir&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;产品线&#34;&gt;产品线&lt;/h3&gt;
&lt;p&gt;目前 Palantir 仅保留两条产品线：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/palantir-gotham/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Palantir Gotham&lt;/a&gt;&lt;/strong&gt; 一个集成，管理，保护和分析多来源的企业数据的复合平台。命名来源于蝙蝠侠所在的哥谭市。作为后端，Gotham 平台可用于集成许多不同的数据源，以进行安全的协作分析；也可以存储企业的各类建模分析数据，充当企业知识库。而在前端, Gotham 平台提供了一套针对语义，时间，地理空间和全文分析的分析工具集合。为 Gotham 提供支撑的子产品包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PHOENIX&lt;/strong&gt; 支持 PB 级的数万亿条记录进行亚秒级查询的集群数据库；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RAPTOR&lt;/strong&gt; 提供对外部数据源进行联合查询, 并实时加入数据库的检索工具；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SEARCH&lt;/strong&gt; 提供对系统中结构化和非结构化数据的全文检索的搜索引擎；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HORIZON&lt;/strong&gt; 允许用户在数十亿个对象中查询并在约 10 秒内收到结果的, 类 Spark 设计的内存数据库；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DYNAMIC ONTOLOGY&lt;/strong&gt; 高度灵活和动态的数据建模工具；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;REVISIONING DATABASE&lt;/strong&gt; RevDB 是 Gotham 平台的持久化数据管理工具，类似 Zookeeper 之于 Hadoop；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ATLASDB&lt;/strong&gt; 作为 RevDB 的具体数据存储单元，结合了 NoSQL 数据存储的简单性和可扩展性与传统 SQL 数据库的事务安全性和一致性；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NEXUS PEERING&lt;/strong&gt; 分布式系统平台，上面的各个组件都建立在这个平台之上；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/palantir-foundry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Palantir Foundry&lt;/a&gt;&lt;/strong&gt; ：数据集成 / 分析平台，将后端的数据存储和前端的数据分析打通，让任何人都能连接到不同数据源轻松进行建模分析。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解决方案&#34;&gt;解决方案&lt;/h3&gt;
&lt;p&gt;Palantir 面向以下领域直接提供解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/automotive&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;汽车制造业&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/cyber/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;网络安全&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/financial-compliance/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;金融合规&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/insider-threat/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;企业内部信息安全&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/intelligence/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;商业情报分析&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/legal-intelligence/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;法律诉讼&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/mergers-and-acquisitions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;并购支持&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/revenue-maximization/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;收入最大化&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/case-management/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数据组织&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/defense/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;国土防卫&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/gdpr/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;欧盟通用数据保护监管&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/insurance-analytics&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;保险分析&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/law-enforcement/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公共执法&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/manufacturing/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;制造业&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/pharma/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;医药研发&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/skywise&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;航空业&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 安装最新版本 Python</title>
      <link>https://szthanatos.github.io/post/python/python_install_on_ubuntu/</link>
      <pubDate>Sat, 01 Dec 2018 15:59:04 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/python/python_install_on_ubuntu/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;添加 ppa 源：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 死蛇的源
sudo add-apt-repository ppa:deadsnakes/ppa
# 或者，jonathonf 的源
sudo add-apt-repository ppa:jonathonf/python-3.x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果提示没有 add-apt-repository 的话执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt install software-properties-common
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新源并安装 python3.x，&lt;code&gt;3.x&lt;/code&gt; 以你要安装的版本号为准：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt update
sudo apt install python3.x
# 可选
sudo apt install python3.x-dev
sudo apt install python3.x-venv
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装 pip:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://bootstrap.pypa.io/get-pip.py
sudo python3.x get-pip.py
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 python 和 pip 版本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 也可以用 - V
python --version
python3 --version
pip --version
pip3 --version
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果关联版本不正确，备份 usr/bin 的软链接，重建软链接：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 设置默认 python3 对应 python 版本
sudo ln -s /usr/bin/python3.x /usr/bin/python3
# 设置默认 pip3 使用 pip 版本
sudo ln -s /usr/local/bin/pip3.x /usr/bin/pip3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意 python 默认安装位置在 &lt;code&gt;/usr/bin&lt;/code&gt; 下，pip 默认安装位置在 &lt;code&gt;/usr/local/bin&lt;/code&gt; 下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pip 初始化设置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir ~/.pip
touch ~/.pip/pip.conf
# python3.6/pip18 之后无需配置这个
echo [list]&amp;gt;&amp;gt;~/.pip/pip.conf
echo format=columns&amp;gt;&amp;gt;~/.pip/pip.conf
# 设置默认 pip 源为清华大学开源镜像
echo [global]&amp;gt;&amp;gt;~/.pip/pip.conf
echo index-url = https://pypi.tuna.tsinghua.edu.cn/simple&amp;gt;&amp;gt;~/.pip/pip.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(可选) 一键升级所有过期的包：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo pip freeze --local | grep -v &#39;^\-e&#39; | cut -d = -f 1  | xargs pip install -U
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>欢迎来到氪石实验室</title>
      <link>https://szthanatos.github.io/post/0x00/</link>
      <pubDate>Sat, 01 Dec 2018 12:00:24 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/0x00/</guid>
      <description>&lt;p&gt;这是我第四次，也可能是我最后一次博客迁移 (flag 已立←_←)。&lt;/p&gt;
&lt;p&gt;从大学时代开始，找个地方写点什么的蠢动心思就没消停过，但是也都消磨在了无关文字的地方。有一个 Geek 圈子的说法，&lt;code&gt;yak-shaving&lt;/code&gt;，剪牦牛毛，放我身上非常合适——本来只是想写点什么，却发现不知道写哪好，就开始研究市面上的博客服务，又发现都不太好用不如自己搭，又开始研究自建网站，自建网站的过程中又发现自己需要一个服务器，又开始折腾主机&amp;hellip; 折腾个人域名&amp;hellip; 折腾 Linux&amp;hellip; 折腾 LAMP 环境&amp;hellip;——总之折腾到最后，走马观花的东西很多，写出来的东西寥寥无几。&lt;/p&gt;
&lt;p&gt;yak-shaving 的得失不提，到了现在的这个阶段，折腾的心思已经熄了很多，但是已经写出来的东西零零散散还是会难以忍受。也有一部分内容已经过时，或者回头再看理解已经完全不同&amp;hellip; 总而言之，借此机会，旧的内容安置妥当，咱们就此别过。未来的文章，短时间内也无虞搬迁之苦，踏踏实实的呆在实验室档案柜吧。&lt;/p&gt;
&lt;p&gt;以后笔记只分两部分存储：未经整理的内容继续保存在 OneNote 里，相对完整的东西再放到这里来。&lt;/p&gt;
&lt;p&gt;旧的博客文章大概 200 篇不到，但是想到要挨个过一遍还得翻新到 Hugo 的模板&amp;hellip;.. 就感觉&amp;hellip;&amp;hellip; 啊，还是鸽了吧&amp;hellip;&amp;hellip;（不过自己立的 flag 哭着也要做完的）&lt;/p&gt;
&lt;p&gt;说回个人博客。&lt;/p&gt;
&lt;p&gt;上一个博客的灵感是万智牌 &lt;font color=#F8F8FF&gt;（和长者）&lt;/font&gt;，为自己设定的身份是掌握了东方神秘膜法的旅法师&amp;hellip; 所以取名叫做 &amp;ldquo;黑膜法师营地&amp;rdquo;，不过旅法师对决之后也已经好久没玩了。&lt;/p&gt;
&lt;p&gt;至于现在博客的设定，起源于最近重温 &lt;a href=&#34;https://www.bilibili.com/bangumi/play/ep257474/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;守望者&lt;/a&gt;。看到罗夏(罗夏帅爆!) 就想到老爷，看到笑匠就想到小丑(罗夏：致命玩笑←_←)，看到法老王&amp;hellip; 唔&amp;hellip; 蝙蝠侠对抗的智商爆表而且 ** 精神正常 ** 的反派&amp;hellip; 阿卡姆疯人院:&amp;ldquo;外面的都是神经病啊，不要放进来！&amp;quot;。&lt;/p&gt;
&lt;p&gt;脑洞扩展到 DCEU，嗯，超人，嗯，卢瑟，嗯，巴别塔&amp;hellip; 老爷不会只靠定情小氪石的，一定有后备方案，嗯，Lex Wayne，就这么定了。&lt;/p&gt;
&lt;p&gt;顺理成章，细节设定就是严肃的考 (wan) 证(geng)啦。&lt;/p&gt;
&lt;h2 id=&#34;kryptonite-lab&#34;&gt;Kryptonite Lab&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://szthanatos.github.io/media/kryptonite.jpg&#34; alt=&#34;kryptonite&#34;&gt;&lt;/p&gt;
&lt;p&gt;氪石实验室，没什么好说的，名字都是 Lex Wayne 了肯定患有氪石狂热啦 (雾！)，什么住在全是氪石的实验室啦，爱嚼氪石口香糖啦，肯定都是基本设定啦 (大雾！)。&lt;/p&gt;
&lt;p&gt;42 这个倒和 DCEU 没关——《银河系漫游指南》里宇宙的终极答案啊！十六进制的 ASCII 码 &lt;code&gt;*&lt;/code&gt;，&lt;code&gt;&#39;the&lt;/code&gt;&lt;strong&gt;&lt;code&gt;Answer&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;to&lt;/code&gt;&lt;strong&gt;&lt;code&gt;Life&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;the&lt;/code&gt;&lt;strong&gt;&lt;code&gt;Universe&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;and&lt;/code&gt;&lt;strong&gt;&lt;code&gt;Everything&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;is&#39;&lt;/code&gt; 问题本身的长度，感觉没有更赞的了 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。已经想好了，如果以后完善 Lab 的设定，里面的超算肯定叫深思 (Deep Thought)。&lt;/p&gt;
&lt;h2 id=&#34;wayne-manor-b3-1007-mountain-drive-gotham-nj-12345-usa&#34;&gt;Wayne Manor B3, 1007 Mountain Drive, Gotham, NJ 12345, USA&lt;/h2&gt;
&lt;p&gt;一段一段说，&lt;/p&gt;
&lt;h3 id=&#34;wayne-manor-b3&#34;&gt;Wayne Manor B3&lt;/h3&gt;
&lt;p&gt;地下三层取自这个蝙蝠洞的设计图：&lt;img src=&#34;https://szthanatos.github.io/media/batcave_design.jpg&#34; alt=&#34;蝙蝠洞设计图&#34;&gt;&lt;/p&gt;
&lt;p&gt;放大可以看到地下从上往下数分别是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-1 &lt;code&gt;Main Level&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;-2 &lt;code&gt;Additional Hangar Aeras&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;-3 &lt;code&gt;Sub Level 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Sub Level 1&lt;/code&gt; 放的就是 &lt;code&gt;Labs/Workshops/Library&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1007-mountain-drive-gotham&#34;&gt;1007 Mountain Drive, Gotham&lt;/h3&gt;
&lt;p&gt;韦恩庄园所在的 &lt;code&gt;1007 Mountain Drive&lt;/code&gt; 这个地址来源于 92-95 年的蝙蝠侠动画 &lt;code&gt;Batman: The Animated Series&lt;/code&gt; 第一季中的 &lt;code&gt;The Demon&#39;s Quest&lt;/code&gt; 故事，应该也是目前蝙蝠侠相关作品中唯一正面出现的庄园地址。&lt;/p&gt;
&lt;p&gt;具体坐落在哥谭的什么位置可以参考 1999 年 Eliot R. Brown 制作的地图：&lt;img src=&#34;https://szthanatos.github.io/media/gotham-city-eliot.jpg&#34; alt=&#34;Eliot R. Brown 版本&#34;&gt;&lt;/p&gt;
&lt;p&gt;而更新一点的设定可以参考诺兰的黑暗骑士的周边 &lt;a href=&#34;https://www.amazon.com/The-Dark-Knight-Manual-Documents/dp/1608871045?tag=thehuffingtop-20&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《黑暗骑士手册》&lt;/a&gt;：&lt;img src=&#34;https://szthanatos.github.io/media/gotham-city-nolan.jpg&#34; alt=&#34;Nolan 版本&#34;&gt;&lt;/p&gt;
&lt;p&gt;总之，都在右上角啦←_←。&lt;/p&gt;
&lt;h3 id=&#34;nj-12345-usa&#34;&gt;NJ 12345, USA&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;NJ&lt;/code&gt; 是新泽西的缩写，虽然哥谭给人的印象就是纽约（早于黑暗骑士的电影给人的感觉可能更像芝加哥），但新泽西的设定可以追溯到 1974 年的 DC 漫画惊奇世界 (详见维基)，&lt;img src=&#34;https://szthanatos.github.io/media/gotham_local.jpg&#34; alt=&#34;哥谭位置&#34;&gt;
&lt;code&gt;NJ 12345&lt;/code&gt; 也是出自 93 年的 &lt;code&gt;Batman: Shadow of the Bat&lt;/code&gt; 里的那个驾驶证：&lt;code&gt;72 Faxcol Dr Gotham City, NJ 12345&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;其他彩蛋&#34;&gt;其他彩蛋&lt;/h3&gt;
&lt;p&gt;其他的设定零零碎碎的，以后也会往里面填充更多内容啦。&lt;/p&gt;
&lt;h4 id=&#34;star-war&#34;&gt;Star War&lt;/h4&gt;
&lt;p&gt;比如我个人介绍的 &lt;code&gt;Python Knight &amp;amp; Go Padawan&lt;/code&gt;，这里的 &lt;code&gt;Knight&lt;/code&gt; 显然和黑暗骑士什么的无关——Jedi！星战好像已经是老年人爱好了&amp;hellip; 但当年真的迷过一段时间，桌面都是拿星战的设定集原画做的&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://szthanatos.github.io/media/star_war_grievous_wheel_bike.jpg&#34; alt=&#34;wheel bike&#34;&gt;&lt;/p&gt;
&lt;p&gt;另一方面是一时想不到 DCEU 里面和等级相关的设定了&amp;hellip; 星战就很明确啊，
&lt;code&gt;youngling&lt;/code&gt; 是幼徒，&lt;code&gt;Padawan&lt;/code&gt; 是学徒，&lt;code&gt;Knight&lt;/code&gt; 是武士，&lt;code&gt;Master&lt;/code&gt; 是大师，简单明了~&lt;/p&gt;
&lt;p&gt;再有就是，&lt;code&gt;Kryptonitesaber&lt;/code&gt; 什么的想想就很带感啊&amp;hellip; 以后绝对要补充这方面设定的！&lt;/p&gt;
&lt;p&gt;嗯&amp;hellip; 上面都是写给自己看的，&lt;/p&gt;
&lt;h1 id=&#34;陌生人p-欢迎翻阅氪石实验室-42-号档案柜&#34;&gt;陌生人，&lt;p&gt; 欢迎翻阅氪石实验室 42 号档案柜。&lt;/h1&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;《蜘蛛侠: 平行宇宙》也是 42 的梗，大家真的是很爱 42 啊&amp;hellip;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>python 单元测试标准及实现</title>
      <link>https://szthanatos.github.io/post/python/unit_testing/</link>
      <pubDate>Mon, 20 Aug 2018 10:49:50 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/python/unit_testing/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#什么是单元测试&#34;&gt;什么是单元测试&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#为什么要写单元测试&#34;&gt;为什么要写单元测试&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#怎么写单元测试&#34;&gt;怎么写单元测试&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#原生测试框架-unittestunittest2&#34;&gt;原生测试框架 unittest/unittest2&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#第三方测试框架-pytest&#34;&gt;第三方测试框架 py.test&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#单元测试标准&#34;&gt;单元测试标准&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#代码覆盖指标&#34;&gt;代码覆盖指标&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#代码覆盖率&#34;&gt;代码覆盖率&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#小结&#34;&gt;小结&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    这是写给我组里的人看的，顺手粘过来
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;什么是单元测试&#34;&gt;什么是单元测试&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;单元测试 (Unit Testing) 又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一句话概括，单元测试也就是校验代码中具体的类 (甚至函数) 的输出值是否符合预期。&lt;/p&gt;
&lt;h2 id=&#34;为什么要写单元测试&#34;&gt;为什么要写单元测试&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;“可能出错的事情最终一定会出错”&lt;/p&gt;
&lt;p&gt;——墨菲定律&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码随着时间的累计而增长，出现意想不到的问题的可能性也在指数级上升。代码的正确与否不应该靠人来保证，因为人是会犯错并且一定犯错的。如果每次新功能上线时不能回答 “所有功能都测试过了么” 的问题，那么最终整个项目的可靠性都将被摧毁。单元测试的意义就在于让你能够回答这个问题，并且，回答的更自动化。&lt;/p&gt;
&lt;h2 id=&#34;怎么写单元测试&#34;&gt;怎么写单元测试&lt;/h2&gt;
&lt;h3 id=&#34;原生测试框架-unittestunittest2&#34;&gt;原生测试框架 unittest/unittest2&lt;/h3&gt;
&lt;p&gt;在 python 语境中，官方提供 unittest 标准库完成单元测试。&lt;/p&gt;
&lt;h4 id=&#34;基础&#34;&gt;基础&lt;/h4&gt;
&lt;p&gt;需要理解的概念有如下四个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;test fixture&lt;/code&gt;：单元测试所需上下文环境，比如临时数据库 / 网络连接等；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test case&lt;/code&gt;：一个独立的单元测试最小单位；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test suite&lt;/code&gt;：test case 的集合；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test runner&lt;/code&gt;：执行并输出单元测试的程序；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细定义请自行查阅 &lt;a href=&#34;https://docs.python.org/3/library/unittest.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官网文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;官方单元测试用例如下，我们对 upper(将 string 转换为大写)、isupper(判断 string 是否全部为大写)、split(对 string 按空格切分为 list) 函数的功能进行校验&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import unittest

class TestStringMethods(unittest.TestCase):

    def test_upper(self):
        self.assertEqual(&#39;foo&#39;.upper(), &#39;FOO&#39;)

    def test_isupper(self):
        self.assertTrue(&#39;FOO&#39;.isupper())
        self.assertFalse(&#39;Foo&#39;.isupper())

    def test_split(self):
        s = &#39;hello world&#39;
        self.assertEqual(s.split(), [&#39;hello&#39;, &#39;world&#39;])
        # check that s.split fails when the separator is not a string
        with self.assertRaises(TypeError):
            s.split(2)

if __name__ == &#39;__main__&#39;:
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;断言&#34;&gt;断言&lt;/h4&gt;
&lt;p&gt;可以从上面的例子看出，单元测试判断结果是否符合预期的主要方式是通过断言 (assert)  实现。
以下是常见断言：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Checks that&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;assertEqual(a, b)&lt;/td&gt;
&lt;td&gt;a == b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertNotEqual(a, b)&lt;/td&gt;
&lt;td&gt;a != b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertGreater(a, b)&lt;/td&gt;
&lt;td&gt;a &amp;gt; b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertGreaterEqual(a, b)&lt;/td&gt;
&lt;td&gt;a &amp;gt;= b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertLess(a, b)&lt;/td&gt;
&lt;td&gt;a &amp;lt; b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertLessEqual(a, b)&lt;/td&gt;
&lt;td&gt;a &amp;lt;= b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertAlmostEqual(a, b)&lt;/td&gt;
&lt;td&gt;round(a-b, 7) == 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertNotAlmostEqual(a, b)&lt;/td&gt;
&lt;td&gt;round(a-b, 7) != 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertRegex(s, r)&lt;/td&gt;
&lt;td&gt;r.search(s)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertNotRegex(s, r)&lt;/td&gt;
&lt;td&gt;not r.search(s)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertTrue(x)&lt;/td&gt;
&lt;td&gt;bool(x) is True&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertFalse(x)&lt;/td&gt;
&lt;td&gt;bool(x) is False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertIs(a, b)&lt;/td&gt;
&lt;td&gt;a is b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertIsNot(a, b)&lt;/td&gt;
&lt;td&gt;a is not b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertIsNone(x)&lt;/td&gt;
&lt;td&gt;x is None&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertIsNotNone(x)&lt;/td&gt;
&lt;td&gt;x is not None&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertIn(a, b)&lt;/td&gt;
&lt;td&gt;a in b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertNotIn(a, b)&lt;/td&gt;
&lt;td&gt;a not in b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertIsInstance(a, b)&lt;/td&gt;
&lt;td&gt;isinstance(a, b)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertNotIsInstance(a, b)&lt;/td&gt;
&lt;td&gt;not isinstance(a, b)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;setup-和-teardown&#34;&gt;setUp 和 tearDown&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;test fixture&lt;/code&gt; 是通过 &lt;code&gt;setUp&lt;/code&gt; 和 &lt;code&gt;tearDown&lt;/code&gt; 来具体实现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;setUp() 方法&lt;/strong&gt;：
在执行每个测试用例 (test case) 之前被执行，除了 unittest.SkipTest 和 AssertionError 以外的任何异常都会当做是 error 并终止当前测试用例；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tearDown() 方法&lt;/strong&gt;：
执行了 setUp()方法后，执行 tearDown()方法 (进行清理)。对异常的处理和 setUp() 类似；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;setUpClass(cls) 与 tearDownClass(cls) 类&lt;/strong&gt;：
可以将 setUp 和 tearDown 定义在基类中避免重复定义，定义 setUpClass(cls) 与 tearDownClass(cls) 类时必须加上 classmethod 装饰符；&lt;/p&gt;
&lt;p&gt;对上面的例子进行简单的改造以演示 setUp 和 tearDown 的效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import unittest

class TestStringMethods(unittest.TestCase):

    def setUp(self):
        print &#39;1. setUp here&#39;

    def tearDown(self):
        print &#39;2. tearDown here&#39;

    def test_upper(self):
        self.assertEqual(&#39;foo&#39;.upper(), &#39;FOO&#39;)

    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行后效果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;test_isupper (mytest.TestStringMethods) ... 1. setUp here
1. tearDown here
ok
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;缺点&#34;&gt;缺点&lt;/h4&gt;
&lt;p&gt;基本的一个单元测试可以用这四步概括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新建单元测试脚本&lt;/li&gt;
&lt;li&gt;导入单元测试依赖&lt;/li&gt;
&lt;li&gt;继承单元测试类&lt;/li&gt;
&lt;li&gt;实现单元测试方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而这个过程非常不 pythonic：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须新建单独的测试文件&lt;/li&gt;
&lt;li&gt;测试必须继承自 unittest 类，即使再简单的测试&lt;/li&gt;
&lt;li&gt;断言只能使用 unittest 的 Assertion&lt;/li&gt;
&lt;li&gt;最最关键和难以忍受的：unitunit 内的命名规则和 pep 8 相悖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;造成这些问题的原因一言以蔽之：python 的测试框架是完全仿照 Java 实现的。&lt;/p&gt;
&lt;h3 id=&#34;第三方测试框架-pytest&#34;&gt;第三方测试框架 py.test&lt;/h3&gt;
&lt;p&gt;实际上，通过使用 py.test，我们可以非常 pythonic 的实现单元测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# content of test_sample.py
def inc(x):
    return x + 1


def test_answer():
    assert inc(3) == 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接在测试文件所在目录执行 py.test 得到如下结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-3.x.y, py-1.x.y, pluggy-0.x.y
rootdir: $REGENDOC_TMPDIR, inifile:
collected 1 item

test_sample.py F                                                     [100%]

================================= FAILURES =================================
_______________________________ test_answer ________________________________

    def test_answer():
&amp;gt;       assert inc(3) == 5
E       assert 4 == 5
E        +  where 4 = inc(3)

test_sample.py:6: AssertionError
========================= 1 failed in 0.12 seconds =========================
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就是这么简单，更进一步的，py.test 支持自动生成对指定目录下所有测试文件的统一测试脚本，更具体的用法参见 &lt;a href=&#34;https://docs.pytest.org/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pytest 文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总的来说，py.test 具有如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非常容易上手，入门简单，文档丰富，文档中有很多实例可以参考&lt;/li&gt;
&lt;li&gt;能够支持简单的单元测试和复杂的功能测试&lt;/li&gt;
&lt;li&gt;支持参数化&lt;/li&gt;
&lt;li&gt;执行测试过程中可以将某些测试跳过，或者对某些预期失败的 case 标记成失败&lt;/li&gt;
&lt;li&gt;支持重复执行失败的 case&lt;/li&gt;
&lt;li&gt;支持运行由 nose , unittest 编写的测试 case&lt;/li&gt;
&lt;li&gt;具有很多第三方插件，并且可以自定义扩展&lt;/li&gt;
&lt;li&gt;方便的和持续集成工具集成&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;单元测试标准&#34;&gt;单元测试标准&lt;/h2&gt;
&lt;p&gt;业界通常使用代码覆盖 (率) 来评判测试的好坏。&lt;/p&gt;
&lt;h3 id=&#34;代码覆盖指标&#34;&gt;代码覆盖指标&lt;/h3&gt;
&lt;p&gt;单独的一两个测试完全无法体现测试的优势。而对所有可能的情况编写单元测试既不现实也无必要。所以明确测试覆盖哪些指标非常重要。&lt;strong&gt;我们在此指定以下四个指标必须被覆盖：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数覆盖（Function Coverage）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每一个函数都必须被测试；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;语句覆盖（Statement Coverage）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;被测代码中每个可执行语句都应该被执行测试。例如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def foo(x:int, y:int):
    z = 0
    if x&amp;gt;0 and y &amp;gt;0:
        z = x
    return z
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;中，如果测试为 assertEqualst(0, foo(2,-1))，则 if 内的代码就没有被覆盖到；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;决策覆盖（Decision Coverage）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指每一个逻辑分支都应该被测试覆盖。类似上面的例子，如果想要达到决策覆盖，我们起码应该执行两次测试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;assertEquals(2, foo(2, 2))  # 决策 1&lt;/li&gt;
&lt;li&gt;assertEqualst(0, foo(2,-1))  # 决策 2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;条件覆盖（Condition Coverage）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每一个逻辑分支的每一个条件都应该被覆盖。条件覆盖不需要满足条件表达式所有的排列组合，而只需将每个条件表达式的结果为 true/false 的情况进行测试就可以了。依旧使用上面的例子，如果想要达到条件覆盖，我们应该执行至少三次测试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;assertEquals(2, foo(2, 2))  # 决策 1 条件 true&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;assertEqualst(0, foo(2,-1))  # 决策 2(没有条件)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;assertEquals(0, foo(-1, -1))  # 决策 1 条件 false&lt;/p&gt;
&lt;p&gt;如果没有第三个测试，那么只能达到决策覆盖，不能达到条件覆盖。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;代码覆盖率&#34;&gt;代码覆盖率&lt;/h3&gt;
&lt;p&gt;在满足代码覆盖指标的基础上，只有保证一定的代码覆盖率才能保证测试的完整。满足代码覆盖指标相当于是 “质”，而代码覆盖率则是保证 “量”。&lt;strong&gt;目前要求代码覆盖率不应该低于 75%&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们选定 &lt;a href=&#34;https://pypi.org/project/coverage/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;coverage.py&lt;/a&gt; 来统计代码覆盖率。由于主要使用 py.test，需要额外安装 &lt;a href=&#34;https://github.com/pytest-dev/pytest-cov&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pytest-cov&lt;/a&gt; 插件。安装过程非常简单，对照文档直接 pip 安装即可，不多介绍。&lt;/p&gt;
&lt;p&gt;完成安装后，使用 py.test 的时候增加 &amp;ndash;cov=myproj 参数即可。
效果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;-------------------- coverage: ... ---------------------
Name                 Stmts   Miss  Cover
----------------------------------------
myproj/__init__          2      0   100%
myproj/myproj          257     13    94%
myproj/feature4286      94      7    92%
----------------------------------------
TOTAL                  353     20    94%
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;详细用法可参照 &lt;a href=&#34;http://pytest-cov.readthedocs.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;总结一下，通过对单元测试的必要性、编写方法、评判标准等一系列的介绍，确立了以下三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 py.test+unittest 编写单元测试，使用 coverage 统计、分析单元测试编写情况；&lt;/li&gt;
&lt;li&gt;单元测试应覆盖最基本的四项指标 (函数覆盖、语句覆盖、分支覆盖、条件覆盖)；&lt;/li&gt;
&lt;li&gt;在覆盖基本指标的基础上，需要达到 75% 的代码覆盖率；&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>not able to persist on disk</title>
      <link>https://szthanatos.github.io/topic/redis/05-troubleshooting/persist_on_disk/</link>
      <pubDate>Fri, 18 May 2018 11:42:50 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/redis/05-troubleshooting/persist_on_disk/</guid>
      <description>&lt;h2 id=&#34;报错信息&#34;&gt;报错信息&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;原因&#34;&gt;原因&lt;/h2&gt;
&lt;p&gt;绝大多数情况是写磁盘写满了，并且 redis 默认 &lt;code&gt;stop-writes-on-bgsave-error&lt;/code&gt; 配置为 &lt;code&gt;yes&lt;/code&gt;，无法正确的存储 rdb 文件的时候也就拒绝客户端的请求了。&lt;/p&gt;
&lt;h2 id=&#34;解决办法&#34;&gt;解决办法&lt;/h2&gt;
&lt;h3 id=&#34;解决-rdb-保存问题&#34;&gt;解决 rdb 保存问题&lt;/h3&gt;
&lt;p&gt;有重要数据的时候不能直接清空重来，先检查磁盘空间是否足够，然后指定一个新的 rdb 文件，重新 &lt;code&gt;bgsave&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 1. 更改工作目录位置
CONFIG SET dir /tmp/some/directory/other/than/var

# 2. 设置 rdb 文件名
CONFIG SET dbfilename temp.rdb

# 3. 保存新的 rdb 文件
BGSAVE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上修改会在重启 redis 后失效，根据实际情况处理吧。&lt;/p&gt;
&lt;h3 id=&#34;临时-解决无法写入问题&#34;&gt;(临时) 解决无法写入问题&lt;/h3&gt;
&lt;p&gt;关闭 rdb 保存失败拒绝写入的功能：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;config set stop-writes-on-bgsave-error no
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>可序列化类型和多进程 PicklingError</title>
      <link>https://szthanatos.github.io/post/python/pickled/</link>
      <pubDate>Tue, 20 Mar 2018 16:16:15 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/python/pickled/</guid>
      <description>&lt;p&gt;遇到一个报错：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;PicklingError: Can&#39;t pickle &amp;lt;type&#39;instancemethod&#39;&amp;gt;: attribute lookup __builtin__.instancemethod failed&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当时的情况是想写一个多进程的解析代码，爬虫爬到的内容给扔过来就不管了，差不多这个意思：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# !/usr/bin/env python
# -*- coding: utf-8 -*-

from concurrent.futures import ProcessPoolExecutor


class PageProcess(object):
    def __init__(self, worker):
        self.max_worker = worker

    def single_process(self, page):
        pass

    def multi_process(self, page_list):
        with ProcessPoolExecutor(max_workers=self.max_worker) as pp:
            result = pp.map(self.single_process, page_list)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个错误是这么造成的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在类中使用进程池；&lt;/li&gt;
&lt;li&gt;进程池使用 &lt;code&gt;Queue&lt;/code&gt; 管理任务队列；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Queue&lt;/code&gt; 要求传递的内容必须都是可以被序列化的；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么问题来了，哪些类型是可以被序列化的呢？&lt;/p&gt;
&lt;p&gt;根据 &lt;a href=&#34;https://docs.python.org/3/library/pickle.html#pickle-picklable&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;，可序列化的类型包括：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;原文&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;布尔型和空值&lt;/td&gt;
&lt;td&gt;&lt;code&gt;None&lt;/code&gt;, &lt;code&gt;True&lt;/code&gt;, and &lt;code&gt;False&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数字类型中的整数，浮点数和复数&lt;/td&gt;
&lt;td&gt;integers, floating point numbers, complex numbers&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串类型和二进制类型 (字节流，字节数组)&lt;/td&gt;
&lt;td&gt;strings, bytes, bytearrays&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;只包含可序列化对象的元组、集合、列表、字典&lt;/td&gt;
&lt;td&gt;tuples, lists, sets, and dictionaries containing only picklable objects&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;模块中最顶层声明的非匿名函数&lt;/td&gt;
&lt;td&gt;functions defined at the top level of a module (using def, not lambda)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;模块中最顶层声明的内置函数&lt;/td&gt;
&lt;td&gt;built-in functions defined at the top level of a module&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;模块中最顶层声明的类&lt;/td&gt;
&lt;td&gt;classes that are defined at the top level of a module&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__getstate__&lt;/code&gt; 的结果或 &lt;code&gt;__dict__&lt;/code&gt; 是可序列化的这样的类的实例&lt;/td&gt;
&lt;td&gt;instances of such classes whose &lt;code&gt;__dict__&lt;/code&gt; or the result of calling &lt;code&gt;__getstate__()&lt;/code&gt; is picklable&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;破案了，上面代码中，我们的进程池要序列化的是类中的函数，就不符合最顶层定义的函数的要求。&lt;/p&gt;
&lt;p&gt;所以最直接的解决办法也很简单，把要并行的函数抽外面去就行了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# !/usr/bin/env python
# -*- coding: utf-8 -*-

from concurrent.futures import ProcessPoolExecutor


def single_process(page):
    pass


class PageProcess(object):
    def __init__(self, worker):
        self.max_worker = worker

    def multi_process(self, page_list):
        with ProcessPoolExecutor(max_workers=self.max_worker) as pp:
            result = pp.map(single_process, page_list)

&lt;/code&gt;&lt;/pre&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;英文这种语序 / 标点我老是搞不懂，这个 &lt;code&gt;containing only picklable objects&lt;/code&gt; 到底是指 dictionaries 还是前面全部，就当是全部吧&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>列表原序去重性能测试</title>
      <link>https://szthanatos.github.io/post/python/unique_list_ordered/</link>
      <pubDate>Fri, 01 Sep 2017 18:08:57 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/python/unique_list_ordered/</guid>
      <description>&lt;p&gt;对列表的去重很简单，&lt;code&gt;set()&lt;/code&gt; 一下再 &lt;code&gt;list()&lt;/code&gt; 回来就可以了，但是如果要保留原始列表的顺序呢？&lt;/p&gt;
&lt;p&gt;举例，对 &lt;code&gt;[&amp;quot;b&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;]&lt;/code&gt; 这个列表进行原序去重，得到结果应该是 &lt;code&gt;[&#39;b&#39;, &#39;c&#39;, &#39;a&#39;]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;有下面这几种写法：&lt;/p&gt;
&lt;h4 id=&#34;二次排序&#34;&gt;二次排序&lt;/h4&gt;
&lt;p&gt;也就是对去重结果再按原列表 sort 一次：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sort_1(list_in):
    return sorted(list(set(list_in)), key=list_in.index)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;匿名函数&#34;&gt;匿名函数&lt;/h4&gt;
&lt;p&gt;使用匿名函数将列表里不重复的元素累加到一个新列表中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sort_2(list_in):
    return reduce(lambda x, y: x if y in x else x + [y], [[], ] + list_in)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;借用字典&#34;&gt;借用字典&lt;/h4&gt;
&lt;h5 id=&#34;有序字典&#34;&gt;有序字典&lt;/h5&gt;
&lt;p&gt;使用 &lt;code&gt;OrderedDict&lt;/code&gt; 排序：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sort_3(list_in):
    return list(collections.OrderedDict.fromkeys(list_in).keys())
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;defaultdict&#34;&gt;defaultdict&lt;/h4&gt;
&lt;p&gt;类似的, 我们使用 &lt;code&gt;defaultdict&lt;/code&gt; 进行排序：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sort_4(list_in):
    return list(collections.defaultdict.fromkeys(list_in).keys())
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;直接使用-dict&#34;&gt;直接使用 dict&lt;/h4&gt;
&lt;p&gt;在 python3.6 之前， &lt;code&gt;dict&lt;/code&gt; 的 &lt;code&gt;key&lt;/code&gt; 的顺序并不保证一定是插入顺序，所以只有在 python3.6 之后才可以直接用 &lt;code&gt;dict&lt;/code&gt; 实现这个操作；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sort_5(list_in):
    return list(dict.fromkeys(list_in).keys())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完整性能测试代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# !/usr/bin/env python
# encoding: utf-8

from timeit import repeat
from functools import reduce
from collections import defaultdict, OrderedDict

example = [&amp;quot;b&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;]


def sort_1(list_in):
    return sorted(list(set(list_in)), key=list_in.index)


def sort_2(list_in):
    return reduce(lambda x, y: x if y in x else x + [y], [[], ] + list_in)


def sort_3(list_in):
    return list(OrderedDict.fromkeys(list_in).keys())


def sort_4(list_in):
    return list(defaultdict.fromkeys(list_in).keys())


def sort_5(list_in):
    return list(dict.fromkeys(list_in).keys())


if __name__ == &#39;__main__&#39;:
    # time usage: t5&amp;lt; t4 &amp;lt; t3 &amp;lt; t2 &amp;lt; t1
    result = {}
    for i in range(1, 6):
        result[&#39;sort_{}&#39;.format(i)] = repeat(&#39;sort_{}(example)&#39;.format(i),
                                             &#39;from __main__ import sort_{}, example&#39;.format(i),
                                             number=1000000,
                                             repeat=5)
    for k, v in result.items():
        avg_v = round(sum(v) / len(v), 3)
        print(k, avg_v)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在我的苏菲婆上的结果仅供参考：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;排序&lt;/th&gt;
&lt;th&gt;平均时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;sort_1&lt;/td&gt;
&lt;td&gt;1.477&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sort_2&lt;/td&gt;
&lt;td&gt;1.305&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sort_3&lt;/td&gt;
&lt;td&gt;0.957&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sort_4&lt;/td&gt;
&lt;td&gt;0.734&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sort_5&lt;/td&gt;
&lt;td&gt;0.698&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可见，python3.6 之后 dict 是最好的原序去重办法，3.6 之前用 defaultdict 吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://szthanatos.github.io/admin/config.yml</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://szthanatos.github.io/admin/config.yml</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
