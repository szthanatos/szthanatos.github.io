<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | Kryptonite Lab</title>
    <link>https://szthanatos.github.io/post/</link>
      <atom:link href="https://szthanatos.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh-Hans</language><copyright>© 2021 szthanatos</copyright><lastBuildDate>Mon, 28 Dec 2020 19:03:14 +0800</lastBuildDate>
    <image>
      <url>https://szthanatos.github.io/media/icon_hu638af3a55c65206eddec4e3c4c13a753_187410_512x512_fill_lanczos_center_2.png</url>
      <title>Posts</title>
      <link>https://szthanatos.github.io/post/</link>
    </image>
    
    <item>
      <title>使用 Gitalk 作为 Academic 的评论插件</title>
      <link>https://szthanatos.github.io/post/academic/gitalk_as_comments/</link>
      <pubDate>Wed, 17 Jun 2020 23:21:08 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/academic/gitalk_as_comments/</guid>
      <description>&lt;p&gt;Academic(Wowchemy) 作为我 GitHub Pages 博客主题，默认提供3种类型的评论(comments)插件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Twitter——需要跳转到外部页面&lt;/li&gt;
&lt;li&gt;Disqus——收费 or 广告&lt;/li&gt;
&lt;li&gt;Commento——收费 or 自建&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总之，都不完美。&lt;/p&gt;
&lt;p&gt;所以我这边使用 &lt;a href=&#34;https://gitalk.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gitalk&lt;/a&gt; ——一个基于 GitHub Issues 的开源评论系统，提供评论功能。&lt;/p&gt;
&lt;p&gt;具体替换步骤如下：&lt;/p&gt;
&lt;h2 id=&#34;0-开启评论功能&#34;&gt;0. 开启评论功能&lt;/h2&gt;
&lt;p&gt;在项目 &lt;code&gt;config/_default/params.yaml&lt;/code&gt; 文件中，评论相关配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;comments:
  provider: &#39;&#39;
  commentable:
    post: true
    book: true
    project: true
    publication: true
    event: true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1-获取-github-application-密钥对&#34;&gt;1. 获取 GitHub Application 密钥对&lt;/h2&gt;
&lt;p&gt;点击链接 &lt;a href=&#34;https://github.com/settings/applications/new&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;创建 GitHub Application&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2021/06/17/vqWohkOplCwIx7N.png&#34; alt=&#34;创建 GitHub Application&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;保存好 &lt;code&gt;Client ID&lt;/code&gt; 和 &lt;code&gt;Client Secret&lt;/code&gt; 以待下一步使用。&lt;/p&gt;
&lt;h2 id=&#34;2-创建-gitalk-插件&#34;&gt;2. 创建 Gitalk 插件&lt;/h2&gt;
&lt;p&gt;创建 &lt;code&gt;gitalk.html&lt;/code&gt; 如下，放置到项目 &lt;code&gt;layouts/partials/comments/&lt;/code&gt; 目录下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;gitalk-container&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;

&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&amp;quot;&amp;gt;
&amp;lt;script src=&amp;quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;https://cdn.jsdelivr.net/npm/blueimp-md5@2.18.0/js/md5.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    var gitalk = new Gitalk({
        clientID: &#39;【你的 Client ID】&#39;,
        clientSecret: &#39;【你的 Client Secret】&#39;,
        repo: &#39;【你的博客地址】&#39;,
        owner: &#39;{{ .Site.Params.Gitalk.owner }}&#39;,   // GitHub repo 所有者
        admin: [&#39;{{ .Site.Params.Gitalk.owner }}&#39;], // GitHub repo 所有者和合作者，对这个 repo 有写权限
        id: md5(location.pathname),                 // 页面唯一标识，以 GitHub issue tag 形式存在
        distractionFreeMode: false                  // 评论框的全屏遮罩效果
    })
    gitalk.render(&#39;gitalk-container&#39;)
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    注意这里使用的是 &lt;a href=&#34;https://cdn.jsdelivr.net&#34;&gt;jsdelivr&lt;/a&gt; 提供的 CDN 服务，你也可以选择更适合你情况的供应商。
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;gitalk id 被设置为 MD5 化的 URL 的路径，这是因为 GitHub tag 限制长度不能超过50，如果路径过长会无法正确创建 issue；&lt;/p&gt;
&lt;p&gt;不过这样会让 issue tag 都是一串串 MD5 码&amp;hellip;&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;3-覆盖原生评论插件&#34;&gt;3. 覆盖原生评论插件&lt;/h2&gt;
&lt;p&gt;原生 &lt;a href=&#34;https://github.com/wowchemy/wowchemy-hugo-modules/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;academic 主题&lt;/a&gt;控制使用哪种评论的文件是
&lt;code&gt;wowchemy-hugo-modules/wowchemy/layouts/partials/comments.html&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们在项目路径下直接创建 &lt;code&gt;layouts/partials/comments.html&lt;/code&gt; 覆盖它的效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ if index site.Params.comments.commentable .Type | and (ne .Params.commentable false) | or .Params.commentable }}
&amp;lt;section id=&amp;quot;comments&amp;quot;&amp;gt;
    {{ partial &amp;quot;comments/gitalk&amp;quot; . }}
&amp;lt;/section&amp;gt;
{{ end }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样只要是能评论的页面，就都会在底部出现评论框了。&lt;/p&gt;
&lt;h2 id=&#34;4-初始化-issue&#34;&gt;4. 初始化 issue&lt;/h2&gt;
&lt;p&gt;配置完成后，本地启动验证一下，出现下图效果就说明已经基本成功了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2021/06/18/dbYk1IVvtjDqazP.jpg&#34; alt=&#34;本地效果&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当然，你现在点开 &lt;code&gt;使用 GitHub 登录&lt;/code&gt; 是没用的，因为项目在你本地。&lt;/p&gt;
&lt;p&gt;Gitalk 不会自动创建 issue，手动初始化的方式就是部署完，在页面登录 GitHub 然后挨个点开你所有文章。&lt;/p&gt;
&lt;p&gt;自动化方式可以网上搜一下相关教程，基本都需要 node 环境，我这边打算写个 Python 的&amp;hellip;立个 Flag &lt;code&gt;_(:з」∠)_&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>加速 ssh 连接</title>
      <link>https://szthanatos.github.io/post/ssh_speed_up/</link>
      <pubDate>Fri, 15 Nov 2019 17:18:05 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/ssh_speed_up/</guid>
      <description>&lt;h2 id=&#34;报错信息&#34;&gt;报错信息&lt;/h2&gt;
&lt;p&gt;之前运维给做了几台测试服务器，远程连接的时候速度特别慢，ssh 之后需要接近 1 分钟才能连上。&lt;/p&gt;
&lt;h2 id=&#34;原因&#34;&gt;原因&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;ssh -v &amp;lt;服务器&amp;gt;&lt;/code&gt; 显示连接过程：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ssh -v 123.456.789.0
OpenSSH_6.6.1, OpenSSL 1.0.1e-fips 11 Feb 2013
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: /etc/ssh/ssh_config line 56: Applying options for *
debug1: Connecting to 123.456.789.0 [123.456.789.0] port 22.
debug1: Connection established.
debug1: permanently_set_uid: 0/0
debug1: identity file /root/.ssh/id_rsa type -1
debug1: identity file /root/.ssh/id_rsa-cert type -1
debug1: identity file /root/.ssh/id_dsa type -1
debug1: identity file /root/.ssh/id_dsa-cert type -1
debug1: identity file /root/.ssh/id_ecdsa type -1
debug1: identity file /root/.ssh/id_ecdsa-cert type -1
debug1: identity file /root/.ssh/id_ed25519 type -1
debug1: identity file /root/.ssh/id_ed25519-cert type -1
debug1: Enabling compatibility mode for protocol 2.0
debug1: Local version string SSH-2.0-OpenSSH_6.6.1
debug1: Remote protocol version 2.0, remote software version OpenSSH_6.6.1
debug1: match: OpenSSH_6.6.1 pat OpenSSH_6.6.1* compat 0x04000000
debug1: SSH2_MSG_KEXINIT sent
debug1: SSH2_MSG_KEXINIT received
debug1: kex: server-&amp;gt;client aes128-ctr hmac-md5-etm@openssh.com none
debug1: kex: client-&amp;gt;server aes128-ctr hmac-md5-etm@openssh.com none
debug1: kex: curve25519-sha256@libssh.org need=16 dh_need=16
debug1: kex: curve25519-sha256@libssh.org need=16 dh_need=16
debug1: sending SSH2_MSG_KEX_ECDH_INIT
debug1: expecting SSH2_MSG_KEX_ECDH_REPLY
debug1: Server host key: ECDSA 3f:00:c1:54:09:7a:aa:50:93:a2:53:83:74:b5:07:8f
debug1: Host &#39;123.456.789.0&#39; is known and matches the ECDSA host key.
debug1: Found key in /root/.ssh/known_hosts:2
debug1: ssh_ecdsa_verify: signature correct
debug1: SSH2_MSG_NEWKEYS sent
debug1: expecting SSH2_MSG_NEWKEYS
debug1: SSH2_MSG_NEWKEYS received
debug1: Roaming not allowed by server
debug1: SSH2_MSG_SERVICE_REQUEST sent
debug1: SSH2_MSG_SERVICE_ACCEPT received
debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mic,password
debug1: Next authentication method: gssapi-keyex # 0
debug1: No valid Key exchange context
debug1: Next authentication method: gssapi-with-mic # 1
debug1: Unspecified GSS failure.  Minor code may provide more information
No Kerberos credentials available

debug1: Unspecified GSS failure.  Minor code may provide more information
No Kerberos credentials available

debug1: Unspecified GSS failure.  Minor code may provide more information


debug1: Unspecified GSS failure.  Minor code may provide more information
No Kerberos credentials available

debug1: Next authentication method: publickey # 2
debug1: Trying private key: /root/.ssh/id_rsa
debug1: Trying private key: /root/.ssh/id_dsa
debug1: Trying private key: /root/.ssh/id_ecdsa
debug1: Trying private key: /root/.ssh/id_ed25519
debug1: Next authentication method: password # 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现卡住的位置是 &lt;code&gt;debug1: Next authentication method: gssapi-with-mic&lt;/code&gt; 附近。&lt;/p&gt;
&lt;p&gt;证明是由于 &lt;code&gt;gssapi&lt;/code&gt; 认证带来的问题。&lt;/p&gt;
&lt;p&gt;从网上找到相关的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;GSSAPI(Generic Security Services Application Programming Interface) 是一套通用网络安全系统接口。
该接口是对各种不同的客户端服务器安全机制的封装，以消除安全接口的不同，降低编程难度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenSSH 在用户登录的时候会验证 IP，它根据用户的 IP 使用反向 DNS 找到主机名，再使用 DNS 找到 IP 地址，最后匹配一下登录的 IP 是否合法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;进行身份认证的时候，OpenSSH 虽然说的是 &lt;code&gt;publickey,gssapi-keyex,gssapi-with-mic,password&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;但默认顺序是：&lt;code&gt;gssapi-with-mic&lt;/code&gt; → &lt;code&gt;hostbased&lt;/code&gt; → &lt;code&gt;publickey&lt;/code&gt; → &lt;code&gt;keyboard-interactive&lt;/code&gt; → &lt;code&gt;password&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上面连接过程我也标出了 0123，实际顺序的确如此。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gssapi&lt;/code&gt; 的认证是基于 &lt;code&gt;Kerberos&lt;/code&gt; 的，没见到人用过，&lt;/p&gt;
&lt;p&gt;另一方面，客户端反向 DNS 的过程也会在连接 DNS 服务器 / 查询客户端域名 (没域名可就会一层层 DNS 查上去) 上花费时间。&lt;/p&gt;
&lt;h2 id=&#34;解决办法&#34;&gt;解决办法&lt;/h2&gt;
&lt;p&gt;客户端，编辑 &lt;code&gt;/etc/ssh/ssh_config&lt;/code&gt; 文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方式 1：将 &lt;code&gt;GSSAPIAuthentication&lt;/code&gt; 改为 no；&lt;/li&gt;
&lt;li&gt;方式 2：编辑 / 新增 &lt;code&gt;PreferredAuthentications&lt;/code&gt; 为 publickey 或者 password，改变认证优先度;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务端，编辑 &lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt; 文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将 &lt;code&gt;UseDNS&lt;/code&gt; 改为 no；&lt;/li&gt;
&lt;li&gt;(可选) 将 &lt;code&gt;GSSAPIAuthentication&lt;/code&gt; 改为 no(所有连接都不做 gssapi 认证了)；&lt;/li&gt;
&lt;li&gt;重启 sshd 服务；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实际效果，关闭 &lt;code&gt;GSSAPIAuthentication&lt;/code&gt; 让连接时间从 1 分钟下降到 8 秒左右，关闭 &lt;code&gt;UseDNS&lt;/code&gt; 后几乎接近秒连。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>基于 Rancher HA 搭建容器云平台</title>
      <link>https://szthanatos.github.io/post/rancher_ha/</link>
      <pubDate>Thu, 26 Sep 2019 22:58:39 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/rancher_ha/</guid>
      <description>&lt;h2 id=&#34;硬件需求&#34;&gt;硬件需求&lt;/h2&gt;
&lt;p&gt;rancher ha 推荐的架构是单独搭建一个 K8s 集群部署 Rancher，然后再用这个 Rancher 去管理其他的 K8s 集群。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2021/06/17/lD9wLiNnOgrVhIs.png&#34; alt=&#34;推荐架构&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;rancher 集群的配置和能管理的集群规模之间的关系如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;规模&lt;/th&gt;
&lt;th&gt;集群&lt;/th&gt;
&lt;th&gt;节点&lt;/th&gt;
&lt;th&gt;虚拟 CPU 核数&lt;/th&gt;
&lt;th&gt;内存&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;S&lt;/strong&gt;mall&lt;/td&gt;
&lt;td&gt;最多 5 个&lt;/td&gt;
&lt;td&gt;最多 50 个&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;8 GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;M&lt;/strong&gt;iddle&lt;/td&gt;
&lt;td&gt;最多 15 个&lt;/td&gt;
&lt;td&gt;最多 200 个&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;16 GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;L&lt;/strong&gt;arge&lt;/td&gt;
&lt;td&gt;最多 50 个&lt;/td&gt;
&lt;td&gt;最多 500 个&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;32 GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;X-L&lt;/strong&gt;arge&lt;/td&gt;
&lt;td&gt;最多 100 个&lt;/td&gt;
&lt;td&gt;最多 1000 个&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;128 GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;XX-L&lt;/strong&gt;arge&lt;/td&gt;
&lt;td&gt;100+&lt;/td&gt;
&lt;td&gt;1000+&lt;/td&gt;
&lt;td&gt;联系 Rancher&lt;/td&gt;
&lt;td&gt;联系 Rancher&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;单节点部署的 Rancher 只支持中小规模 (&lt;strong&gt;S&lt;/strong&gt;,&lt;strong&gt;M&lt;/strong&gt;) 的集群。&lt;/p&gt;
&lt;p&gt;我这次部署的机器配置如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;虚拟 CPU 核数&lt;/th&gt;
&lt;th&gt;内存&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;loadbalance&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;8G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;server-01&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;16 GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;server-02&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;16 GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;server-03&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;16 GB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一个负载均衡服务器，3 个服务器组成 K8S 集群。&lt;/p&gt;
&lt;p&gt;操作系统均为 &lt;code&gt;RancherOS 1.54&lt;/code&gt;(&lt;code&gt;Console&lt;/code&gt; 是 &lt;code&gt;Ubuntu&lt;/code&gt;，因为 &lt;code&gt;Longhorn&lt;/code&gt; 只支持这个)，Docker 版本 &lt;code&gt;18.09&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;0-工具准备&#34;&gt;0. 工具准备&lt;/h2&gt;
&lt;p&gt;在任意一节点 (我这里都是在 &lt;code&gt;server-01&lt;/code&gt; 上) 上准备以下工具：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;工具&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;kubectl&lt;/td&gt;
&lt;td&gt;Kubernetes 命令行工具&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.16.md#v1160&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kubernetes-v1.16.0&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rke&lt;/td&gt;
&lt;td&gt;Rancher 出品的用于构建 Kubernetes 集群的命令行工具&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/rancher/rke/releases/tag/v0.2.8&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Release v0.2.8&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;helm&lt;/td&gt;
&lt;td&gt;Kubernetes 包管理工具&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/helm/helm/releases/tag/v2.14.3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Helm v2.14.3&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;kubectl&lt;/code&gt; 安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://dl.k8s.io/v1.16.0/kubernetes-client-linux-amd64.tar.gz
tar -zxvf kubernetes-client-linux-amd64.tar.gz
sudo ln -s $(pwd)/kubernetes/client/bin/kubectl /usr/local/bin/kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;rke&lt;/code&gt; 安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://github.com/rancher/rke/releases/download/v0.2.8/rke_linux-arm64
sudo ln -s $(pwd)/rke_linux-amd64 /usr/local/bin/rke
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;helm&lt;/code&gt; 安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://get.helm.sh/helm-v3.0.0-beta.3-linux-amd64.tar.gz
tar -zxvf helm-v2.14.3-linux-amd64.tar.gz
sudo ln -s $(pwd)/linux-amd64/helm /usr/local/bin/helm
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-配置-nginx-负载均衡&#34;&gt;1. 配置 Nginx 负载均衡&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;loadbalance&lt;/code&gt; 主机上编写 nginx.conf 配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;worker_processes 4;
worker_rlimit_nofile 40000;

events {
    worker_connections 8192;
}

stream {
    upstream rancher_servers_http {
        least_conn;
        server &amp;lt;IP_NODE_1&amp;gt;:80 max_fails=3 fail_timeout=5s;
        server &amp;lt;IP_NODE_2&amp;gt;:80 max_fails=3 fail_timeout=5s;
        server &amp;lt;IP_NODE_3&amp;gt;:80 max_fails=3 fail_timeout=5s;
    }
    server {
        listen     80;
        proxy_pass rancher_servers_http;
    }

    upstream rancher_servers_https {
        least_conn;
        server &amp;lt;IP_NODE_1&amp;gt;:443 max_fails=3 fail_timeout=5s;
        server &amp;lt;IP_NODE_2&amp;gt;:443 max_fails=3 fail_timeout=5s;
        server &amp;lt;IP_NODE_3&amp;gt;:443 max_fails=3 fail_timeout=5s;
    }
    server {
        listen     443;
        proxy_pass rancher_servers_https;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即使用 stream 方式让 nginx 转发 80/443 端口的 http/https 流量。&lt;/p&gt;
&lt;p&gt;启动 nginx：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -d \
       --name lb-nginx \
       --restart =unless-stopped \
       -p 80:80 \
       -p 443:443 \
       -v /nginx.conf:/etc/nginx/nginx.conf \
       nginx:1.14
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-使用-rke-安装-k8s&#34;&gt;2. 使用 RKE 安装 K8S&lt;/h2&gt;
&lt;p&gt;三个作为 rancher-server 的服务器需要配置相互免密。&lt;code&gt;ssh-keygen&lt;/code&gt; 生成密钥附加到 &lt;code&gt;authorized_keys&lt;/code&gt; 上，不赘述。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;server-01&lt;/code&gt; 节点，编写 &lt;code&gt;rancher-cluster.yml&lt;/code&gt;，告诉 rke 要如何创建集群：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;nodes:
  - address: &amp;lt;IP_NODE_1&amp;gt;
    internal_address: &amp;lt;IP_NODE_1&amp;gt;
    user: rancher
    role: [controlplane,worker,etcd]
  - address: &amp;lt;IP_NODE_2&amp;gt;
    internal_address: &amp;lt;IP_NODE_2&amp;gt;
    user: rancher
    role: [controlplane,worker,etcd]
  - address: &amp;lt;IP_NODE_3&amp;gt;
    internal_address: &amp;lt;IP_NODE_3&amp;gt;
    user: rancher
    role: [controlplane,worker,etcd]

services:
  etcd:
    snapshot: true
    creation: 6h
    retention: 24h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;节点的配置项中，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;internal_address&lt;/code&gt; 非必填，如果没有内网 IP 的话可以删去。&lt;/p&gt;
&lt;p&gt;如果没有配置 &lt;code&gt;ssh_key_path&lt;/code&gt;，则会默认使用 &lt;code&gt;$HOME/.ssh/id_rsa&lt;/code&gt; 建立连接。&lt;/p&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rke up --config ./rancher-cluster.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成创建，中间如果失败了可以多执行几次，直到最后看到消息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Finished building Kubernetes cluster successfully.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;说明安装完毕。&lt;/p&gt;
&lt;p&gt;K8S 创建成功后会在根目录生成集群信息 &lt;code&gt;rancher-cluster.rkestate&lt;/code&gt; 和配置文件 &lt;code&gt;kube_config_rancher-cluster.yml&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;这两个文件包含访问 K8S 的凭据。&lt;/p&gt;
&lt;h2 id=&#34;3-初始化-helm&#34;&gt;3. 初始化 helm&lt;/h2&gt;
&lt;p&gt;helm 是由客户端 helm 和服务端 tiller 组成，我们之前安装了 helm 可以调用 helm 命令了。&lt;/p&gt;
&lt;p&gt;为了保存和管理 helm 软件包 (helm charts)，我们还需要在本地启动一个服务端。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 创建名为 tiller 的 serviceaccount
kubectl -n kube-system create serviceaccount tiller

# 授予 tiller 帐户对集群的访问权限
kubectl create clusterrolebinding tiller \
  --clusterrole=cluster-admin \
  --serviceaccount=kube-system:tiller

# 安装 tiller，官方国内用的是阿里的源
# helm init --service-account tiller --tiller-image registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:&amp;lt;tag&amp;gt;
helm init \
     --service-account tiller \
     --upgrade \
     --tiller-image gcr.azk8s.cn/kubernetes-helm/tiller:v2.14.3 \
     --stable-repo-url https://mirror.azure.cn/kubernetes/charts/

# 测试是否安装成功
kubectl -n kube-system rollout status deploy/tiller-deploy
helm version
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-配置-ca-证书&#34;&gt;4. 配置 ca 证书&lt;/h2&gt;
&lt;p&gt;rancher 支持三种来源的证书，rancher 自生成 / 来自 Let’s Encrypt 的 / 来自文件的。&lt;/p&gt;
&lt;p&gt;前两种都需要额外安装 CERT-MANAGER。&lt;/p&gt;
&lt;p&gt;这里我们采用第一种方式，依据 &lt;a href=&#34;https://docs.cert-manager.io/en/latest/getting-started/install/kubernetes.html#installing-with-helm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cert-manager 官方文档&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Install the CustomResourceDefinition resources separately
kubectl apply --validate=false -f https://raw.githubusercontent.com/jetstack/cert-manager/release-0.11/deploy/manifests/00-crds.yaml

# Create the namespace for cert-manager
kubectl create namespace cert-manager

# Add the Jetstack Helm repository
helm repo add jetstack https://charts.jetstack.io

# Update your local Helm chart repository cache
helm repo update

# Install the cert-manager Helm chart
helm install \
  --name cert-manager \
  --namespace cert-manager \
  --version v0.11.0 \
  jetstack/cert-manager
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;kubectl get pods --namespace cert-manager&lt;/code&gt; 测试是否安装成功，&lt;/p&gt;
&lt;p&gt;应该能看到 &lt;code&gt;cert-manager&lt;/code&gt;，&lt;code&gt;cert-manager-webhook&lt;/code&gt;，&lt;code&gt;cert-manager-cainjector&lt;/code&gt; 运行中。&lt;/p&gt;
&lt;p&gt;注意 cert-manager 使用的镜像来自 &lt;code&gt;quay.io&lt;/code&gt;，可以编辑 charts 中的 &lt;code&gt;values.yaml&lt;/code&gt; 来修改镜像源，或者提前从国内源下载好镜像放到服务器上。&lt;/p&gt;
&lt;h2 id=&#34;5-安装-rancher&#34;&gt;5. 安装 rancher&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 在 helm 中添加 rancher 源，建议使用 stable
helm repo add rancher-stable https://releases.rancher.com/server-charts/stable
helm repo update

# 安装 rancher
helm install rancher-stable/rancher \
  --name rancher \
  --namespace cattle-system \
  --set hostname=&amp;lt;你的域名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等待一段时间，可以运行 &lt;code&gt;kubectl -n cattle-system rollout status deploy/rancher&lt;/code&gt; 查看安装进度。&lt;/p&gt;
&lt;h2 id=&#34;6-添加主机别名&#34;&gt;6. 添加主机别名&lt;/h2&gt;
&lt;p&gt;由于没有内部 DNS 服务器，我们还需要为 Agent Pod 添加主机别名 (/etc/hosts)。&lt;/p&gt;
&lt;p&gt;不然&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;K8S 集群运行起来之后，因为 &lt;code&gt;cattle-cluster-agent Pod&lt;/code&gt; 和 &lt;code&gt;cattle-node-agent&lt;/code&gt; 无法通过 DNS 记录找到 &lt;code&gt;Rancher Server URL&lt;/code&gt;, 最终导致无法通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我们需要 (以下步骤直接复制于 &lt;a href=&#34;https://www.rancher.cn/docs/rancher/v2.x/cn/installation/ha-install/helm-rancher/tcp-l4/rancher-install/#6-%E5%8F%AF%E9%80%89-%E4%B8%BAagent-pod%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA%E5%88%AB%E5%90%8D-etc-hosts&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Rancher2.0-CN 文档&lt;/a&gt;)：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cattle-cluster-agent Pod&lt;/code&gt; 和 &lt;code&gt;cattle-node-agent&lt;/code&gt; 需要在 &lt;code&gt;LOCAL&lt;/code&gt; 集群初始化之后才会部署，所以先通过 &lt;code&gt;Rancher Server URL&lt;/code&gt; 访问 Rancher Web UI 进行初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行以下命令为 Rancher Server 容器配置 hosts:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#指定 kubectl 配置文件
export kubeconfig=xxx/xxx/xx.kubeconfig.yml

kubectl --kubeconfig=$kubeconfig -n cattle-system \
    patch deployments rancher --patch &#39;{
        &amp;quot;spec&amp;quot;: {
            &amp;quot;template&amp;quot;: {
                &amp;quot;spec&amp;quot;: {
                    &amp;quot;hostAliases&amp;quot;: [
                        {
                            &amp;quot;hostnames&amp;quot;:
                            [
                                &amp;quot;xxx.cnrancher.com&amp;quot;
                            ],
                                &amp;quot;ip&amp;quot;: &amp;quot;192.168.1.100&amp;quot;
                        }
                    ]
                }
            }
        }
    }&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code&gt;Rancher Server URL&lt;/code&gt; 访问 Rancher Web UI，设置用户名密码和 &lt;code&gt;Rancher Server URL&lt;/code&gt; 地址，然后会自动登录 Rancher Web UI；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Rancher Web UI 中依次进入 &lt;code&gt;local 集群 / system 项目&lt;/code&gt;，在 &lt;code&gt;cattle-system&lt;/code&gt; 命名空间中查看是否有 &lt;code&gt;cattle-cluster-agent Pod&lt;/code&gt; 和 &lt;code&gt;cattle-node-agent&lt;/code&gt; 被创建。如果有创建则进行下面的步骤，没有创建则等待；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cattle-cluster-agent pod&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export kubeconfig=xxx/xxx/xx.kubeconfig.yml

kubectl --kubeconfig=$kubeconfig -n cattle-system \
patch deployments cattle-cluster-agent --patch &#39;{
    &amp;quot;spec&amp;quot;: {
        &amp;quot;template&amp;quot;: {
            &amp;quot;spec&amp;quot;: {
                &amp;quot;hostAliases&amp;quot;: [
                    {
                        &amp;quot;hostnames&amp;quot;:
                        [
                            &amp;quot;demo.cnrancher.com&amp;quot;
                        ],
                            &amp;quot;ip&amp;quot;: &amp;quot;192.168.1.100&amp;quot;
                    }
                ]
            }
        }
    }
}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cattle-node-agent pod&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export kubeconfig=xxx/xxx/xx.kubeconfig.yml

kubectl --kubeconfig=$kubeconfig -n cattle-system \
patch  daemonsets cattle-node-agent --patch &#39;{
    &amp;quot;spec&amp;quot;: {
        &amp;quot;template&amp;quot;: {
            &amp;quot;spec&amp;quot;: {
                &amp;quot;hostAliases&amp;quot;: [
                    {
                        &amp;quot;hostnames&amp;quot;:
                        [
                            &amp;quot;xxx.rancher.com&amp;quot;
                        ],
                            &amp;quot;ip&amp;quot;: &amp;quot;192.168.1.100&amp;quot;
                    }
                ]
            }
        }
    }
}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;这几步花的时间比较长，需要耐心等待。安装过程到此结束。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RancherOS 初步使用小结</title>
      <link>https://szthanatos.github.io/post/rancheros/</link>
      <pubDate>Sun, 01 Sep 2019 15:39:50 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/rancheros/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;RancherOS&lt;/code&gt; 是 Rancher 推出的一个轻量级的 Linux 内核操作系统，专为容器环境而设计。&lt;/p&gt;
&lt;p&gt;按官网的说法，它具有如下特性：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;官方说法&lt;/th&gt;
&lt;th&gt;瞎翻译&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Minimalist OS&lt;/td&gt;
&lt;td&gt;极简系统 ——当前版本 (v1.5.4) 镜像也只有 146M，还内置了各类虚拟机工具和 N 个版本的 Docker 环境&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Comprehensive System Services&lt;/td&gt;
&lt;td&gt;综合系统服务——所有的系统服务都可以通过 Compose 文件声明和启动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Improved Security&lt;/td&gt;
&lt;td&gt;更安全——没有额外的工具 / 代码，所有应用都跑在容器里，当然更安全&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Up-to-Date Version of Docker &amp;amp; Linux&lt;/td&gt;
&lt;td&gt;集成最新的 Docker&amp;amp;Linux 发行版——装完系统直接就有 Docker 用，还是最新的，美滋滋&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Automated OS Configuration&lt;/td&gt;
&lt;td&gt;自动化系统配置——使用 cloud-init 工具解析 &lt;code&gt;cloud-config&lt;/code&gt; 文件，统一管理系统级的所有配置，比如网络，docker 源&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;24x7 Enterprise-level Support&lt;/td&gt;
&lt;td&gt;不解释&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;简单的来说，当我们开始使用容器化的方式来管理应用和服务的时候，我们自然而然的会发现，我们对操作系统其实没什么需求了
——环境依赖和工具链由镜像提供，GUI 界面或者浏览器毫无作用，系统内置的各种工具也就是启动一个容器的事&amp;hellip;&lt;/p&gt;
&lt;p&gt;把这些七七八八的都去掉，最后剩下：一个 Linux 内核 + Docker 环境 + 精简但是统一的配置管理 = RancherOS&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2021/06/17/AZIUHLks7Jm1Mqc.png&#34; alt=&#34;RancherOS 架构&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;RancherOS 的架构也非常简单，除了内核，就是两个 Docker。&lt;/p&gt;
&lt;p&gt;一个系统级的 Docker(&lt;code&gt;system-docker&lt;/code&gt;) 接管了系统的绝大部分功能，比如在一般 Linux 上你会用 &lt;code&gt;systemctl restart&lt;/code&gt; 重启服务，在这里就是用 &lt;code&gt;system-docker restart&lt;/code&gt; 重启一个容器了。&lt;/p&gt;
&lt;p&gt;用户级别的 Docker 也作为一个服务运行在 &lt;code&gt;system-docker&lt;/code&gt; 之上，也就是我们一般意义上跑应用的 docker，正常使用。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;a href=&#34;https://github.com/rancher/os/releases/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RancherOS Gitlab 页面&lt;/a&gt; 下载对应版本镜像。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建虚拟机，加载 ISO 镜像，默认会以 &lt;code&gt;rancher&lt;/code&gt; 用户身份进入一个运行在内存之上的临时 RancherOS，所以建虚拟机的时候内存可以适当大一点，比如 2G&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建 / 上传一个 &lt;code&gt;cloud-config.yml&lt;/code&gt; 文件，主要内容就是写入你的 ssh 公钥，因为 RancherOS 安装之后就只能通过 ssh + 公钥的方式登陆 (是的，你在虚拟机控制台都进不去)，一个最简单的示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# cloud-config
ssh_authorized_keys:
- ssh-rsa AAA...
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有其他配置了的话，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo ros config valicate -i cloud-config.yml&lt;/code&gt; 校验没有格式错误，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo ros install -c cloud-config.yml -d /dev/sda&lt;/code&gt; 将 RancherOS 安装到硬盘。&lt;/p&gt;
&lt;p&gt;一路只有 2 个选项，是否要安装？Y，是否要重启？N，因为重启比你卸载光驱还快&amp;hellip; 直接就又进入一个新的临时 RancherOS 了&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;手动 &lt;code&gt;sudo poweroff&lt;/code&gt;，卸载光驱，重启，看到熟悉的牛头 LOGO，恭喜完成~&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;如果一定要为 rancher 设置一个密码的话，将安装命令替换为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo ros install -c cloud-config.yml -d /dev/sda --append=rancher.password = 密码&lt;/code&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;我遇到的一个情况，在 Vmware 上安装时，临时 RancherOS 默认没有网，
需要手动配置网卡：&lt;/p&gt;
&lt;p&gt;修改 &lt;code&gt;/etc/network/interfaces&lt;/code&gt; 文件，在末尾添加：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;auto eth0
iface eth0 inet static
# IP
address             xxx.xxx.xxx.xxx
# 子网掩码
netmask             xxx.xxx.xxx.xxx
# 广播地址 (可选)
broadcast           xxx.xxx.xxx.xxx
# 所在网段 (可选)
network             xxx.xxx.xxx.xxx
# 网关
gateway             xxx.xxx.xxx.xxx
# dns 服务器
dns-nameservers     xxx.xxx.xxx.xxx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置好执行 &lt;code&gt;sudo ifup eth0&lt;/code&gt; 即可连上网络。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;p&gt;整个 RancherOS 自底向上分三个层面进行管理&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;层面&lt;/th&gt;
&lt;th&gt;工具&lt;/th&gt;
&lt;th&gt;管理&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;系统管理&lt;/td&gt;
&lt;td&gt;ros&lt;/td&gt;
&lt;td&gt;cloud-config.yml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务管理&lt;/td&gt;
&lt;td&gt;system-docker&lt;/td&gt;
&lt;td&gt;类 Compose 文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;应用管理&lt;/td&gt;
&lt;td&gt;docker&lt;/td&gt;
&lt;td&gt;直接 run&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;ros&#34;&gt;ros&lt;/h3&gt;
&lt;p&gt;ros 是对系统进行管理的工具，所以必须要以 root 权限执行，具体用法可以 help 看一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo ros help
NAME:
   ros - Control and configure RancherOS
built: &#39;2019-08-22T07:44:10Z&#39;

USAGE:
   ros [global options] command [command options] [arguments...]

VERSION:
   v1.5.4

AUTHOR(S):
   Rancher Labs, Inc.

COMMANDS:
     config, c   configure settings                               # 配置管理
     console     manage which console container is used           # 切换命令行
     engine      manage which Docker engine is used               # 切换 Docker 版本
     service, s                                                   # 系统服务管理
     os          operating system upgrade/downgrade               # 内核管理
     tls         setup tls configuration                          # tls 管理
     install     install RancherOS to disk                        # 安装系统
     help, h     Shows a list of commands or help for one command

GLOBAL OPTIONS:
   --help, -h     show help
   --version, -v  print the version

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ros-config&#34;&gt;&lt;code&gt;ros config&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ros config
NAME:
   ros config - configure settings

USAGE:
   ros config command [arguments...]

COMMANDS:
     get       get value                                            # 获取配置
     set       set a value                                          # 设定配置
     images    List Docker images for a configuration from a file   # 没用过
     generate  Generate a configuration file from a template        # 没用过
     export    export configuration                                 # 输出配置，比直接看 cloud-config.yml 全面
     merge     merge configuration from stdin                       # 合并配置文件
     syslinux  edit Syslinux boot global.cfg                        # 没用过
     validate  validate configuration from stdin                    # 校验配置文件格式
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有面向系统的设置都是通过 &lt;code&gt;ros config&lt;/code&gt; 进行管理的，默认的配置存放在 &lt;code&gt;/var/lib/rancher/conf/cloud-config.yml&lt;/code&gt; 中。未记录的配置修改都会在重启后失效 (是的，&lt;code&gt;sudo passwd&lt;/code&gt; 也不能让你下次直接用户名密码登陆，不过有别的办法)&lt;/p&gt;
&lt;p&gt;简单的修改配置可以直接执行 &lt;code&gt;ros config set &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;，比如&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ros config set rancher.docker.tls true&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;多个值写成列表，比如&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ros config set rancher.network.dns.nameservers &amp;quot;[&#39;8.8.8.8&#39;,&#39;8.8.4.4&#39;]&amp;quot;&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;复杂一点的可以写一个小的 yml，然后执行 &lt;code&gt;ros config merge -i &amp;lt;文件&amp;gt;&lt;/code&gt; 进行合并，
理论上也可以手动添加到 &lt;code&gt;/var/lib/rancher/conf/cloud-config.yml&lt;/code&gt; 中。
但是个人不推荐这样做，因为现在版本的 cloud-config.yml 和 &lt;code&gt;ros config export&lt;/code&gt; 输出的不是一回事，待研究。&lt;/p&gt;
&lt;h4 id=&#34;ros-service&#34;&gt;&lt;code&gt;ros service&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$  ros service
NAME:
   ros service -

USAGE:
   ros service command [command options] [arguments...]

COMMANDS:
     enable   turn on an service              # 启用服务
     disable  turn off an service             # 禁止服务
     list     list services and state         # 服务列表
     delete   delete a service                # 删除服务
     build    Build or rebuild services       # 构建 / 重构服务
     create   Create services                 # 创建服务
     up       Create and start containers     # 创建并启动服务
     start    Start services                  # 启动服务
     logs     View output from containers     # 查看服务日志
     restart  Restart services                # 重启服务
     stop     Stop services                   # 停止服务
     rm       Delete services                 # 删除服务及镜像
     pull     Pulls service images            # pull 服务镜像
     kill     Kill containers                 # 杀死服务容器
     ps       List containers                 # 列出服务容器

OPTIONS:
   --tls               Use TLS; implied by --tlsverify
   --tlsverify         Use TLS and verify the remote [$DOCKER_TLS_VERIFY]
   --tlscacert value   Trust certs signed only by this CA
   --tlscert value     Path to TLS certificate file
   --tlskey value      Path to TLS key file
   --configdir value   Path to docker config dir, default ${HOME}/.docker
   --verbose, --debug
   --help, -h          show help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;控制的是随系统启动的服务，用法包括声明文件的写法基本和 Docker Compose 一样，把它理解成 Docker Compose 的替代品就对了。&lt;/p&gt;
&lt;p&gt;别的命令不解释了&amp;hellip;&lt;/p&gt;
&lt;h3 id=&#34;系统服务&#34;&gt;系统服务&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ros s list
disabled amazon-ecs-agent
disabled container-cron
disabled open-iscsi
disabled zfs
disabled kernel-extras
disabled kernel-headers
disabled kernel-headers-system-docker
enabled  open-vm-tools
disabled hyperv-vm-tools
disabled qemu-guest-agent
disabled rancher-server
disabled rancher-server-stable
disabled amazon-metadata
disabled volume-cifs
disabled volume-efs
disabled volume-nfs
disabled modem-manager
disabled waagent
disabled virtualbox-tools
disabled pingan-amc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面说到系统级的服务都是用 &lt;code&gt;ros s&lt;/code&gt; 控制启停，而想要自定义一个系统级的服务的话:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用 Docker Compose 语法编写服务的 &lt;code&gt;xxx.yml&lt;/code&gt; 文件，一般存放到 &lt;code&gt;/var/lib/rancher/conf/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ros service enable /var/lib/rancher/conf/xxx.yml&lt;/code&gt; 启用该服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ros service up &amp;lt;serviceName&amp;gt;&lt;/code&gt; 启动服务，如果一个 Compose 里定义了多个服务，那么需要
&lt;code&gt;ros service up &amp;lt;serviceName1&amp;gt; &amp;lt;serviceName2&amp;gt; &amp;lt;serviceName3&amp;gt; ...&lt;/code&gt; 来同时启动&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;docker&#34;&gt;docker&lt;/h3&gt;
&lt;p&gt;没啥好说的&amp;hellip;Just use it.&lt;/p&gt;
&lt;h2 id=&#34;cloud-config&#34;&gt;cloud-config&lt;/h2&gt;
&lt;p&gt;额外说一下这个 cloud-config。&lt;/p&gt;
&lt;p&gt;现有的公有云 / 虚拟化厂商大多支持 &lt;code&gt;cloud-init&lt;/code&gt; 工具进行系统配置初始化 (某种意义上的事实标准)。cloud-config 就是为 &lt;code&gt;cloud-init&lt;/code&gt; 服务的。RancherOS 在 &lt;code&gt;system-docker&lt;/code&gt; 中运行了一个 &lt;code&gt;cloud-init&lt;/code&gt; 容器，它会在启动时查找可能位置上的 cloud-config 文件并依此配置系统配置项。&lt;/p&gt;
&lt;p&gt;cloud-config 的语法格式就是标准的 YAML 语法，一个我在用的、比较完整的 cloud-config 的示例如下：&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    使用时请删除掉中文注释&amp;hellip; 给别人演示的时候懒得删注释结果 validate 没问题，但是配置就是不生效&amp;hellip;
  &lt;/div&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# 主机名
hostname: ros-test

# 系统配置
rancher:
  # 替换控制台为 alpine，也可以是 ubuntu/centos/debian...
  console: alpine

  # 初始 Docker 源
  bootstrap_docker:
    registry_mirror: &amp;quot;http://dockerhub.azk8s.cn/&amp;quot;
  # 系统 Docker 源
  system_docker:
    registry_mirror: &amp;quot;http://dockerhub.azk8s.cn/&amp;quot;
  # 用户 Docker 源
  docker:
    registry_mirror: &amp;quot;http://dockerhub.azk8s.cn/&amp;quot;

  # 网络
  network:
    interfaces:
      eth0:
        # IP 要是 CIDR 格式，要是和子网掩码对不上就上不了网
        address: 192.168.0.1/24
        # netmask: 255.255.255.0
        # broadcast: 192.168.0.255
        gateway: 192.168.0.254
        mtu: 1500
        dhcp: false
    dns:
      nameservers:
        - 114.114.114.114
        - 8.8.8.8

  # # 扩容现有磁盘不要用 fdisk，除非你想把系统格式化了，用这个就能调整磁盘大小
  # resize_device: /dev/sda

# 可登录的机器公钥
ssh_authorized_keys:
  - ssh-rsa ...
  - ssh-rsa ...

# # 挂载新磁盘
# mounts:
# - [&amp;quot;/dev/vdb&amp;quot;, &amp;quot;/mnt/s&amp;quot;, &amp;quot;ext4&amp;quot;, &amp;quot;&amp;quot;]

# 写文件
write_files:
  # 修改 apk 使用国内镜像
  - path: /etc/apk/repositories
    permissions: &amp;quot;0755&amp;quot;
    owner: root
    content: |
      https://mirrors.ustc.edu.cn/alpine/latest-stable/main
      https://mirrors.ustc.edu.cn/alpine/latest-stable/community

  # 设置 CST 时区
  - path: /etc/profile
    permissions: &amp;quot;0755&amp;quot;
    owner: root
    content: |
      export CHARSET=UTF-8
      export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
      export PAGER=less
      # 显示样式
      export PS1=&amp;quot;\[\e[37m\][\[\e[32m\]\u\[\e[37m\]@\h \[\e[36m\]\w\[\e[0m\]]\\$&amp;quot;
      # 时区
      export TZ=&#39;CST-8&#39;
      umask 022

      for script in /etc/profile.d/*.sh ; do
              if [-r $script] ; then
                      . $script
              fi
      done

  # 确保 ssh 连接时会读取. bashrc
  - path: /home/rancher/.bash_profile
    permissions: &amp;quot;0755&amp;quot;
    owner: rancher
    content: |
      # If the shell is interactive and .bashrc exists, get the aliases and functions
      if [[$- == *i* &amp;amp;&amp;amp; -f ~/.bashrc]]; then
          . ~/.bashrc
      fi

  # 配置. bashrc
  - path: /home/rancher/.bashrc
    permissions: &amp;quot;0755&amp;quot;
    owner: rancher
    content: |
      # .bashrc
      # User specific aliases and functions
      alias  d=&amp;quot;docker&amp;quot;
      alias di=&amp;quot;docker image&amp;quot;
      alias dc=&amp;quot;docker container&amp;quot;
      alias dv=&amp;quot;docker volumn&amp;quot;
      alias dn=&amp;quot;docker netwrok&amp;quot;

      # Source global definitions
      if [-f /etc/bashrc]; then
              . /etc/bashrc
      fi

# 启动时执行命令
runcmd:
  #   # 两种写法
  #   - [touch, /home/rancher/test1]
  #   - echo &amp;quot;test&amp;quot; &amp;gt; /home/rancher/test2
  # 开机更新 apk 源
  - apk update
  # 启动定时任务服务
  - crond

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JanusGraph 搭建及简单使用</title>
      <link>https://szthanatos.github.io/post/janusgraph/</link>
      <pubDate>Sun, 17 Mar 2019 21:50:19 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/janusgraph/</guid>
      <description>&lt;h2 id=&#34;基本环境&#34;&gt;基本环境&lt;/h2&gt;
&lt;p&gt;底层数据库基于 HBase，检索服务基于 Elasticserach。&lt;/p&gt;
&lt;p&gt;系统运行服务大致如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@xnode208 ~] jps
21584 GremlinServer
27857 DataNode
23218 Jps
3251 HMaster
27283 NameNode
21707 Console
17131 Elasticsearch
29503 SecondaryNameNode
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;下载 &lt;a href=&#34;https://github.com/JanusGraph/janusgraph/releases/download/v0.2.2/janusgraph-0.2.2-hadoop2.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;janusgraph0.22 安装包&lt;/a&gt; 并解压&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://github.com/JanusGraph/janusgraph/releases/download/v0.2.2/janusgraph-0.2.2-hadoop2.zip
unzip janusgraph-0.2.2-hadoop2.zip
cd janusgraph-0.2.2-hadoop2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;在这里我们采用的是启动 gremlin-server 服务时，加载指定配置文件的方法创建图表，所以需要设置 gremlin-server 端以及图表的配置文件。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 gremlin-server 端配置文件 &lt;code&gt;janusgraph-0.2.2-hadoop2/conf/gremlin-server/socket-gremlin-server.yaml&lt;/code&gt;，这里我们复制 gremlin 服务默认的配置文件，在此基础上进行修改&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cp conf/gremlin-server/gremlin-server.yaml conf/gremlin-server/socket-gremlin-server.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 &lt;code&gt;socket-gremlin-server.yaml&lt;/code&gt;：在配置文件中添加 graphManager; 并在 graphs 项中添加 graph 键及其值，一个键值代表一个图表，值表示对图表的设置 (可添加多个图表，每一个图表都有自己的配置文件)，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;graphManager: org.janusgraph.graphdb.management.JanusGraphManager
graphs: {
  blablabla,
  graph: conf/gremlin-server/socket-jg-hbase_fyk-server-configraph.properties
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;准备上述 &lt;code&gt;socket-gremlin-server.yaml&lt;/code&gt; 中对图表进行设置的 properties 文件，&lt;code&gt;conf/gremlin-server/socket-jg-hbase_fyk-server-configraph.properties&lt;/code&gt; 文件内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gremlin.graph=org.janusgraph.core.JanusGraphFactory
graph.graphname=graph

storage.backend=hbase  # 设置我们本地启动的 hbase 作为底层数据库
storage.hostname=127.0.0.1

index.search.backend=elasticsearch  # 设置 Janus graph 自带的 es 作为我们的检索服务
index.search.hostname=127.0.0.1

cache.db-cache = true
cache.db-cache-clean-wait = 20
cache.db-cache-time = 180000
cache.db-cache-size = 0.5
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;基本用法&#34;&gt;基本用法&lt;/h2&gt;
&lt;p&gt;依次启动 hbase,elasticsearch 以及 gremlin-server，最后进入 gremlin.sh 客户端对图表进行操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;hbase&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@xnode208 ~] start-hbase.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;elasticsearch.(注：Janusgraph 自带的 elastic search 服务启动时为确保安全被禁止使用 root 用户)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[zkr@xnode208 ~] cd /usr/local/janusgraph-0.2.2-hadoop2
[zkr@xnode208 elasticsearch] ./bin/elasticsearch
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gremlin-server(启动成功后，会创建我们在配置文件中设计的图表)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[zkr@xnode208 janusgraph0.2] ./bin/gremlin-server.sh ./conf/gremlin-server/socket-gremlin-server.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gremlin.sh(进入 gremlin 交互式客户端)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@xnode208 janusgraph0.2] ./bin/gremlin.sh
gremlin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;加载诸神图&#34;&gt;加载诸神图&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 连接 gremlin server
gremlin&amp;gt; :remote connect tinkerpop.server conf/remote.yaml session
==&amp;gt;Configured localhost/127.0.0.1:8182-[f6db862e-752c-48db-839b-1b5b16f1786a]
gremlin&amp;gt; :remote console
==&amp;gt;All scripts will now be sent to Gremlin Server - [localhost/127.0.0.1:8182]-[f6db862e-752c-48db-839b-1b5b16f1786a] - type &#39;:remote console&#39; to return to local mode

# 加载诸神图到我们创建的空图表中
gremlin&amp;gt; GraphOfTheGodsFactory.load(graph)
==&amp;gt;null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例数据描述了一部分希腊诸神以及他们居住的诸神殿的相关关系。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2021/06/17/6bKJYdog2eClRBV.png&#34; alt=&#34;graph-of-the-gods&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;粗体键&lt;/td&gt;
&lt;td&gt;带索引的键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;星标粗体键&lt;/td&gt;
&lt;td&gt;具有唯一值的带索引的键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;带下划线的键&lt;/td&gt;
&lt;td&gt;以顶点为核心的带索引的键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;空心箭头边&lt;/td&gt;
&lt;td&gt;不能有多个指向的唯一边&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;尾部划线的边&lt;/td&gt;
&lt;td&gt;单向边&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在 JanusGraph 中，实体以顶点表示，关系以边表示，顶点和边都可以具有属性。&lt;/p&gt;
&lt;h2 id=&#34;一些基本操作&#34;&gt;一些基本操作&lt;/h2&gt;
&lt;h3 id=&#34;增操作&#34;&gt;增操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 添加顶点
v1 = graph.addVertex(label, &#39;student&#39;);  # 创建第一个顶点 v1 并增加标签
v2 = graph.addVertex();  # 创建第二个顶点没有标签

# 为顶点添加属性
v1.property(&#39;id&#39;, &#39;1&#39;);  # 为顶点 v1 添加 id 属性，值为 1
v3 = graph.addVertex(label,&#39;girl&#39;,&#39;name&#39;,&#39;huahua&#39;);  # 创建第三个顶点并且增加标签，属性以及属性值
v4 = graph.addVertex(label,&#39;boy&#39;,&#39;name&#39;,&#39;wuyanzu&#39;,&#39;age&#39;,18)  # 创建第四个顶点添加标签以及多个属性属性值

# 添加边
t1 = v1.addEdge(&#39;friends&#39;, v2);  # 为 v1 添加关系到 v2, 并定义这个关系为 t1
t2 = v1.addEdge(&#39;boyfriend&#39;, v2);  # 两个顶点之间可以增加多种关系

# 为边增加属性
t1.property(&#39;reason&#39;,&#39;cool&#39;);  # 为 t1 增加属性
v3.addEdge(&#39;boyfriend&#39;,v4,&#39;reason&#39;,&#39;because the reason&#39;);  # v3 添加关系到 v4 并且增加关系属性及属性值

# 提交修改
graph.tx().commit();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;删操作&#34;&gt;删操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 清空
g.V().drop();  # 删除所有点 / 图
g.E().drop();  # 删除所有边
graph1.close();
JanusGraphFactory.drop(graph1);  # 清空图中的所有数据

# 删除顶点
pluto = g.V().has(&#39;name&#39;,&#39;pluto&#39;).next();g.V(pluto).drop().iterate();  # 删除 name 属性为 &amp;quot;pluto&amp;quot; 的顶点
g.V().has(&#39;keys&#39;,&#39;ll&#39;).drop().iterate();  # 删除 keys 属性为 &amp;quot;ll&amp;quot; 的顶点
g.V().hasLabel(&#39;student&#39;).has(&#39;name&#39;,&#39;ll&#39;).drop().iterate();  # 删除标签为 student，并且顶点属性 name 的值为 &amp;quot;ll&amp;quot; 的顶点

# 删除边
g.E().has(&#39;uuu&#39;,&#39;because the reason&#39;).drop().iterate();  # 删除边属性 uuu 的属性值为 because the reason 的边
g.E().hasLabel(&#39;boyfriend&#39;).has(&#39;event&#39;,&#39;the reason&#39;).drop().iterate();  # 删除边标签为 boyfriend 并且边属性 event 的值为 the reason 的边

# 删除顶点标签以及顶点属性
g.V().hasLabel(&#39;girl&#39;).drop();  # 删除标签 girl 以及标签为 girl 的所有顶点
g.V().properties(&#39;name&#39;).drop();  # 删除顶点属性 name

# 删除边标签、边属性以及属性值
g.E().hasLabel(&#39;boyfriend&#39;).drop();  # 删除边标签 boyfriend
g.E().properties(&#39;uuu&#39;).drop();  # 删除边属性 uuu
g.E().hasLabel(&amp;quot;friend&amp;quot;).properties().drop();  # 删除边标签为 friend 的所有属性以及属性值
g.E().values(&#39;because the reason&#39;).drop();  # 删除边属性值为 because the reason 以及对应的属性


graph.tx().commit();  # 提交
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;查询&#34;&gt;查询&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 设置 g=graph.traversal(), 方便查询
gremlin&amp;gt; g = graph.traversal()
==&amp;gt;graphtraversalsource[standardjanusgraph[hbase:[127.0.0.1]], standard]

# 顶点标签查询
g.V();  # 查看所有顶点 id
g.V().label();  # 查看所有顶点标签
g.V().hasLabel(&amp;quot;god&amp;quot;);  # 查看所有标签为 god 的顶点 id
g.V().filter(label().is(&#39;god&#39;));  # 用 filter 查看所有标签为 god 的顶点 id
g.V().has(&#39;name&#39;,&#39;hercules&#39;);  # 查看属性为 name, 值为 hercules 的顶点

# 顶点属性及属性值查询
g.V().valueMap();  # 遍历每个顶点的属性及属性值 (若没有展示空集)
g.V().properties();  # 查看所有顶点的属性及属性值 (不展示空)
g.V().hasLabel(&amp;quot;god&amp;quot;).values();  # 查看所有顶点标签为 god 的属性值
g.V().hasLabel(&amp;quot;god&amp;quot;).properties();  # 查看顶点标签为 god 的所有顶点属性以及属性值
g.V().values(&#39;id&#39;);  # 查看顶点属性为 id 的属性值
g.V().properties(&#39;id&#39;)  # 查看顶点属性为 id 的属性及属性值

# 边标签查询
g.E();  # 查看所有顶点之间的边 顶点 id---&amp;gt; 边 ---&amp;gt; 顶点 id
g.E().label();  # 查看所有边的标签 (关系)
g.E().hasLabel(&amp;quot;battled&amp;quot;)  # 查看标签为 battled 的所有边
g.E().filter(label().is(&#39;battled&#39;));  # 用 filter 查看标签为 battled 的所有边
g.E().has(&#39;time&#39;,12);  # 查看属性 time 的值为 12 的所有边

# 边属性及属性值查询
g.E().valueMap();  # 遍历所有边属性及属性值
g.E().properties();  # 查看所有边属性及属性值
g.E().hasLabel(&amp;quot;battled&amp;quot;).values();  # 查看所有标签为 battled 的边属性值
g.E().hasLabel(&amp;quot;battled&amp;quot;).properties();  # 查看所有标签为 battled 的边属性以及属性值
g.E().values(&#39;reason&#39;);  # 查看边属性为 reason 的属性值
g.E().properties(&#39;reason&#39;);  # 查看边属性为 reason 的属性及属性值
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Git三棵树和reset/checkout命令</title>
      <link>https://szthanatos.github.io/post/git/git_trees/</link>
      <pubDate>Sat, 05 Jan 2019 14:13:21 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/git/git_trees/</guid>
      <description>&lt;p&gt;理解Git没有比从三棵树开始更好的了。&lt;/p&gt;
&lt;p&gt;完整的话还是看&lt;a href=&#34;https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;git文档&lt;/a&gt;比较好，说的蛮清楚了。&lt;/p&gt;
&lt;h2 id=&#34;三棵树和正向流程&#34;&gt;三棵树和正向流程&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;树&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;HEAD&lt;/td&gt;
&lt;td&gt;上一次提交的快照，下一次提交的父结点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Index&lt;/td&gt;
&lt;td&gt;预期的下一次提交的快照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Working Directory&lt;/td&gt;
&lt;td&gt;沙盒&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;git的核心工作就是管理这三棵树。&lt;code&gt;git add&lt;/code&gt;就是把你工作目录(Working Directory)的修改提交到暂存区(Index)，&lt;code&gt;git commit&lt;/code&gt;就是把暂存区的内容同步到仓库里作为一个快照，并移动&lt;code&gt;HEAD&lt;/code&gt;指向新快照；















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2021/06/17/TC92Dm8Y4liM7Lc.gif&#34; alt=&#34;git_flow&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;额外说一下这个&lt;code&gt;HEAD指针&lt;/code&gt;，每一次commit都相当于在仓库(Repository)里生成一个快照，
把N个快照想象成一个右进左出的队列(List)，再想象有一个指针，默认指向队首(最新快照)，告诉你当前到底用的是哪一个版本快照。&lt;/p&gt;
&lt;h2 id=&#34;reset&#34;&gt;reset&lt;/h2&gt;
&lt;p&gt;显然，&lt;code&gt;git reset&lt;/code&gt;就是对上述行为的反向操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;reset&lt;/code&gt;的本质其实是移动&lt;code&gt;HEAD&lt;/code&gt;指针指向哪个快照，而通过&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--soft&lt;/code&gt;——只改变指针指向的快照；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--mixed&lt;/code&gt;——移动指针的同时也把快照内容同步到暂存区；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--hard&lt;/code&gt;——三棵树全同步为指针指向的快照；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参数来&lt;strong&gt;递进的&lt;/strong&gt;控制改变是发生在哪几颗树上。















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2021/06/17/SeHiuWg5haKUvI4.gif&#34; alt=&#34;git_reflow&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;再强调一遍，&lt;code&gt;reset&lt;/code&gt;的改变的是&lt;code&gt;HEAD&lt;/code&gt;指针，而不是文件。即使&lt;code&gt;git reset File&lt;/code&gt;的写法是有效的，但它的本质是&lt;code&gt;git reset --mixed HEAD File&lt;/code&gt;的缩写，即将&lt;code&gt;File&lt;/code&gt;从&lt;code&gt;HEAD&lt;/code&gt;指向的快照复制到索引中。&lt;code&gt;HEAD&lt;/code&gt;指针永远只能指向一个快照，但是快照是可以局部修改它里面的文件的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HEAD~&lt;/code&gt;表示前一个快照，&lt;code&gt;HEAD~2&lt;/code&gt;表示前两个，依此类推。&lt;/p&gt;
&lt;h2 id=&#34;checkout&#34;&gt;checkout&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;checkout&lt;/code&gt;的本质就有所不同，它关心的是分支(branch)，它的主要作用是让&lt;code&gt;HEAD&lt;/code&gt;在不同分支间移动(默认三棵树都会更新)。&lt;/p&gt;
&lt;p&gt;还是拿刚才那个队列举例，分支相当于是平行的一条队列，现在把他放在你脑子里之前那个队列的上方，
由于&lt;code&gt;HEAD&lt;/code&gt;指针只能指向一个快照，所以这个时候它可能会在两个队列间“跳动”，&lt;code&gt;checkout&lt;/code&gt;就是控制指针上下移动的命令，而&lt;code&gt;reset&lt;/code&gt;则是控制指针在当前队列左右(前后)移动。















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2021/06/17/HdKsNMhfyAwclr2.gif&#34; alt=&#34;git_chechout&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;同样的，&lt;code&gt;checkout&lt;/code&gt;后面也可以跟一个文件，和&lt;code&gt;git reset --hard [branch] file&lt;/code&gt;可能会产生的效果一样。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>(翻译)Academic 文档 - 内容编写</title>
      <link>https://szthanatos.github.io/post/academic/trans_writing_content/</link>
      <pubDate>Tue, 01 Jan 2019 12:54:29 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/academic/trans_writing_content/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;本文是对 &lt;a href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/&#34;&gt;Academic 文档 - Writing content 章节&lt;/a&gt; 的个人翻译，基于个人理解，不保证绝对准确。&lt;/p&gt;
&lt;p&gt;原文见上方连接。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Academic 支持使用 Markdown、LaTeX 数学公式和 Hugo 代码段编写内容。
此外，可以使用 HTML 以实现高级样式。
本文概述最常见的格式选项。&lt;/p&gt;
&lt;h2 id=&#34;副标题&#34;&gt;副标题&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;## Heading 2
### Heading 3
#### Heading 4
##### Heading 5
###### Heading 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;强调&#34;&gt;强调&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 下划线内为斜体
Italics with _underscores_.

# * 内为粗体
Bold with **asterisks**.

# 粗体和斜体可以组合
Combined emphasis with **asterisks and _underscores_**.

# 双波浪符内为删除线
Strikethrough with ~~two tildes~~.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;有序列表&#34;&gt;有序列表&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;1. First item
2. Another item
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;无序列表&#34;&gt;无序列表&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;我个人更习惯用 -
* First item
* Another item
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;图片&#34;&gt;图片&lt;/h2&gt;
&lt;p&gt;图片可以存放在你的媒体库 &lt;code&gt;static/img&lt;/code&gt; 或你的 &lt;a href=&#34;https://gohugo.io/content-management/page-bundles/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;页面文件夹&lt;/a&gt;。
使用以下任一方式即可引用图片：&lt;/p&gt;
&lt;p&gt;假设图片来自你的 &lt;code&gt;static/img&lt;/code&gt; 媒体库：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; figure library=&amp;quot;1&amp;quot; src=&amp;quot;image.jpg&amp;quot; title=&amp;quot;A caption&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设图片来自你的页面文件夹 (比如 &lt;code&gt;content/post/hello/&lt;/code&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; figure src=&amp;quot;image.jpg&amp;quot; title=&amp;quot;A caption&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;带编号和标题的图片：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; figure src=&amp;quot;image.jpg&amp;quot; title=&amp;quot;A caption&amp;quot; numbered=&amp;quot;true&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般图片：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;![alternative text for search engines](/media/image.jpg)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;图片集&#34;&gt;图片集&lt;/h2&gt;
&lt;p&gt;为页面包增加一个图片集：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 &lt;a href=&#34;https://gohugo.io/content-management/page-bundles/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;页面包&lt;/a&gt;(也就是你的页面文件夹) 内创建图片集文件夹；&lt;/li&gt;
&lt;li&gt;将图片放入图片集文件夹；&lt;/li&gt;
&lt;li&gt;粘贴 &lt;code&gt;{``{&amp;lt; gallery album=&amp;quot;&amp;lt;ALBUM FOLDER&amp;gt;&amp;quot; &amp;gt;}``}&lt;/code&gt; 到文章中你想要它出现的地方，将 album 参数修改为你文件集的名称；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可选的，要为你的图片集添加标题的话，将下面的实例添加到你扉页的尾部:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[[gallery_item]]
album = &amp;quot;&amp;lt;ALBUM FOLDER&amp;gt;&amp;quot;
image = &amp;quot;&amp;lt;IMAGE NAME&amp;gt;.jpg&amp;quot;
caption = &amp;quot;Write your image caption here&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，想要在图片集中使用网络位置 / 媒体库中的图片；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将图片添加到 &lt;code&gt;static/img/&lt;/code&gt; 文件夹；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在文章的扉页尾部声明图片引用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[[gallery_item]]
album = &amp;quot;1&amp;quot;
image = &amp;quot;my_image.jpg&amp;quot;
caption = &amp;quot;Write your image caption here&amp;quot;

[[gallery_item]]
album = &amp;quot;1&amp;quot;
image = &amp;quot;https://raw.githubusercontent.com/gcushen/hugo-academic/master/images/theme-dark.png&amp;quot;
caption = &amp;quot;Dark theme&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在正文要显示的位置使用 &lt;code&gt;{``{&amp;lt; gallery album=&amp;quot;1&amp;quot;&amp;gt;}``}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;视频&#34;&gt;视频&lt;/h2&gt;
&lt;p&gt;页面可以添加以下几种类型的视频。&lt;/p&gt;
&lt;h3 id=&#34;本地视频文件&#34;&gt;本地视频文件&lt;/h3&gt;
&lt;p&gt;要添加视频，将它放在 &lt;code&gt;static/img/&lt;/code&gt; 媒体库或者页面文件夹内，使用以下任一方式即可引用。&lt;/p&gt;
&lt;p&gt;位于 &lt;code&gt;static/img/&lt;/code&gt; 文件夹下的视频：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; video library=&amp;quot;1&amp;quot; src=&amp;quot;my_video.mp4&amp;quot; controls=&amp;quot;yes&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;位于页面文件夹下的视频：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; video src=&amp;quot;my_video.mp4&amp;quot; controls=&amp;quot;yes&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;youtube&#34;&gt;Youtube&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; youtube w7Ft2ymGmfc &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;vimeo&#34;&gt;Vimeo&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; vimeo 146022717 &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;链接&#34;&gt;链接&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;[I&#39;m a link](https://www.google.com)
[A post]({{&amp;lt; ref &amp;quot;post/hi.md&amp;quot; &amp;gt;}})
[A publication]({{&amp;lt; ref &amp;quot;publication/hi.md&amp;quot; &amp;gt;}})
[A project]({{&amp;lt; ref &amp;quot;project/hi.md&amp;quot; &amp;gt;}})
[Another section]({{&amp;lt; relref &amp;quot;hi.md#who&amp;quot; &amp;gt;}})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想要链接到一个文件，比如 PDF，首先将它放到 &lt;code&gt;static/files/&lt;/code&gt; 文件夹下，然后使用下面方式链接：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{% staticref &amp;quot;files/cv.pdf&amp;quot; &amp;quot;newtab&amp;quot; %}}Download my CV{{% /staticref %}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;staticref&lt;/code&gt; 的 &lt;code&gt;&amp;quot;newtab&amp;quot;&lt;/code&gt; 参数将使链接在新页面打开。&lt;/p&gt;
&lt;h3 id=&#34;标签和分类&#34;&gt;标签和分类&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;{``{&amp;lt; list_tags&amp;gt;}``}&lt;/code&gt; 生成标签链接列表，使用 &lt;code&gt;{``{&amp;lt; list_categories &amp;gt;}``}&lt;/code&gt; 生成分类链接列表。&lt;/p&gt;
&lt;h2 id=&#34;emojis&#34;&gt;Emojis&lt;/h2&gt;
&lt;p&gt;可用 Emojis 见 &lt;a href=&#34;http://www.webpagefx.com/tools/emoji-cheat-sheet/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Emoji cheat sheet&lt;/a&gt;。
下面的这个示例在实际使用时需要把: 和表情名之前的空格去掉：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;I : heart : Academic : smile :
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I ❤️ Academic 😄&lt;/p&gt;
&lt;h2 id=&#34;段落引用&#34;&gt;段落引用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; This is a blockquote.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a blockquote.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;高亮引用&#34;&gt;高亮引用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;This is a {{&amp;lt; hl&amp;gt;}}highlighted quote{{&amp;lt; /hl &amp;gt;}}.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a &lt;mark&gt;highlighted quote&lt;/mark&gt;.&lt;/p&gt;
&lt;h2 id=&#34;脚注&#34;&gt;脚注&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;I have more [^1] to say.
[^1]: Footnote example.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;嵌入文档&#34;&gt;嵌入文档&lt;/h2&gt;
&lt;p&gt;下面几种类型的文档可以被嵌入到页面中。&lt;/p&gt;
&lt;p&gt;要插入 &lt;strong&gt;谷歌文档&lt;/strong&gt; (比如幻灯片) 点击 Google Docs 中的 &lt;em&gt;File &amp;gt; Publish to web &amp;gt; Embed&lt;/em&gt; 并复制 &lt;code&gt;src=&amp;quot;...&amp;quot;&lt;/code&gt; 部分中的 URL。
之后粘贴到下面代码中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; gdocs src=&amp;quot;https://docs.google.com/...&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;speaker-deck&#34;&gt;Speaker Deck&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; speakerdeck 4e8126e72d853c0060001f97 &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;代码高亮&#34;&gt;代码高亮&lt;/h2&gt;
&lt;p&gt;将语言的代码，比如 &lt;code&gt;python&lt;/code&gt;，作为参数放在三个反引号之后：(打出来 ``` 就会被解析，只能加空格了)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt; ` ` `python
 # Example of code highlighting
 input_string_var = input(&amp;quot;Enter some data:&amp;quot;)
 print(&amp;quot;You entered: {}&amp;quot;.format(input_string_var))
 ` ` `

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Example of code highlighting
input_string_var = input(&amp;quot;Enter some data:&amp;quot;)
print(&amp;quot;You entered: {}&amp;quot;.format(input_string_var))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;高亮选项&#34;&gt;高亮选项&lt;/h3&gt;
&lt;p&gt;Academic 主题使用 &lt;a href=&#34;https://highlightjs.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;highlight.js&lt;/a&gt; 作为高亮的来源，并且默认为所有页面启用。
并且，有一些更细粒度的选项可以控制 highlight.js 的显示效果。&lt;/p&gt;
&lt;p&gt;下表列出了 highlight.js 支持的一些选项，包含他们的类型和简短描述。
&lt;strong&gt;config.toml&lt;/strong&gt; 列中的 &amp;ldquo;yes&amp;rdquo; 表示允许在 &lt;code&gt;config.toml&lt;/code&gt; 中全局设置，
&lt;strong&gt;preamble&lt;/strong&gt; 列中的 &amp;ldquo;yes&amp;rdquo; 表示可以设定在特定页面中。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;option&lt;/th&gt;
&lt;th&gt;type&lt;/th&gt;
&lt;th&gt;description&lt;/th&gt;
&lt;th&gt;config.toml&lt;/th&gt;
&lt;th&gt;preamble&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;highlight&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;启用 / 禁用高亮&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;highlight_languages&lt;/td&gt;
&lt;td&gt;slice&lt;/td&gt;
&lt;td&gt;选择额外语言&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;highlight_style&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;选择高亮样式&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;highlight-选项&#34;&gt;&lt;code&gt;highlight&lt;/code&gt; 选项&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;highlight&lt;/code&gt; 选项允许在全局或者特定页面启动 / 禁止语法高亮。
如果没有明确指定的话，默认会认为你设置了 &lt;code&gt;highlight = true&lt;/code&gt;。
也就是说，highlight.js 的 javascript/css 文件会出现在每一个页面文件中。
如果你只希望那些真的需要使用的页面才有语法高亮，
你可以在 &lt;code&gt;config.toml&lt;/code&gt; 中设置 &lt;code&gt;highlight = false&lt;/code&gt;，
之后在需要的页面的扉页覆盖为 &lt;code&gt;highlight = true&lt;/code&gt;。
相反，你也可以全局启用语法高亮，在不需要的页面中禁用。
下面给出一张展示不同全局和单独页面设置下，页面是否高亮。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;config.toml&lt;/th&gt;
&lt;th&gt;page preamble&lt;/th&gt;
&lt;th&gt;highlighting enabled for page?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;unset or true&lt;/td&gt;
&lt;td&gt;unset or true&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unset or true&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;unset or false&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;highlight_languages-选项&#34;&gt;&lt;code&gt;highlight_languages&lt;/code&gt; 选项&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;highlight_languages&lt;/code&gt; 选项允许你指定 highlight.js 支持的，但是不是默认支持的常见的语言。
比如，你想在所有页面高亮 Go 和 clojure 语言，那就在 &lt;code&gt;config.toml&lt;/code&gt; 中设置 &lt;code&gt;highlight_languages = [&amp;quot;go&amp;quot;, &amp;quot;clojure&amp;quot;]&lt;/code&gt;。
另外，如果你想为页面只启用特定的语法高亮，那就去页面扉页设置 &lt;code&gt;highlight_languages&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;config.toml&lt;/code&gt; 和扉页设置的 &lt;code&gt;highlight_languages&lt;/code&gt; 是累加的。
也就是说，如果 &lt;code&gt;config.toml&lt;/code&gt; 里设置了 &lt;code&gt;highlight_languages = [&amp;quot;go&amp;quot;]&lt;/code&gt;，而扉页设置了 &lt;code&gt;highlight_languages = [&amp;quot;ocaml&amp;quot;]&lt;/code&gt;，
那么这个页面会包含两者的高亮文件。&lt;/p&gt;
&lt;p&gt;当你设置了 &lt;code&gt;highlight_languages&lt;/code&gt; 之后，相应的高亮脚本会由 &lt;a href=&#34;https://cdnjs.com/libraries/highlight.js/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cdnjs 服务&lt;/a&gt; 提供。
要查看支持的语言，访问 &lt;a href=&#34;https://cdnjs.com/libraries/highlight.js/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cdnjs page&lt;/a&gt; 页面并查找包含 &amp;ldquo;languages&amp;rdquo; 关键字的链接。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;highlight_languages&lt;/code&gt; 选项通过 CDN 提供了一种方便又容易的方式来满足附加语言的高亮需求。
如果 cdnjs 提供的默认的文件不能满足你的需求，你可以通过 &lt;a href=&#34;https://sourcethemes.com/academic/docs/customization/#add-scripts-js&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;个性化指南&lt;/a&gt; 中的方法来使用自己的 javascript 文件。&lt;/p&gt;
&lt;h4 id=&#34;highlight_style-选项&#34;&gt;&lt;code&gt;highlight_style&lt;/code&gt; 选项&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;highlight_style&lt;/code&gt; 选项允许你使用备选的高亮样式。
比如，如果你想使用 solarized-dark 样式，你可以在 &lt;code&gt;config.toml&lt;/code&gt; 中设置 &lt;code&gt;highlight_style = &amp;quot;solarized-dark&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果未设置 &lt;code&gt;highlight_style&lt;/code&gt;，默认会使用 Academic 提供的或者在你的 &lt;code&gt;static&lt;/code&gt; 文件夹下的 &lt;code&gt;/css/highlight.min.css&lt;/code&gt;。
Academic 提供的默认样式和 &lt;code&gt;github&lt;/code&gt; 是一致的。&lt;/p&gt;
&lt;p&gt;如果设置了 &lt;code&gt;highlight_style&lt;/code&gt;，&lt;code&gt;/css/highlight.min.css&lt;/code&gt; 就会被忽略，相应的样式会由 &lt;a href=&#34;https://cdnjs.com/libraries/highlight.js/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cdnjs 服务&lt;/a&gt; 提供。
要查看支持的样式列表，访问 &lt;a href=&#34;https://cdnjs.com/libraries/highlight.js/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cdnjs page&lt;/a&gt; 页面并查找包含 &amp;ldquo;styles&amp;rdquo; 关键字的链接。&lt;/p&gt;
&lt;p&gt;可以在 &lt;a href=&#34;https://highlightjs.org/static/demo/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;highlight.js demo page&lt;/a&gt; 上查看可用样式。&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    不是所有 &lt;a href=&#34;https://highlightjs.org/static/demo/&#34;&gt;highlight.js demo page&lt;/a&gt; 上列出的样式都在 &lt;a href=&#34;https://cdnjs.com/libraries/highlight.js/&#34;&gt;cdnjs 服务&lt;/a&gt; 上可用。
如果你想使用不是由 cdnjs 提供的样式，那么保持 &lt;code&gt;highlight_style&lt;/code&gt; 未设置，然后将相应文件放到 &lt;code&gt;/static/css/highlight.min.css&lt;/code&gt;。
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    如果你不想更换 Academic 附带的样式，但是还是想由 &lt;a href=&#34;https://cdnjs.com/libraries/highlight.js/&#34;&gt;cdnjs&lt;/a&gt; 提供服务，那么在 &lt;code&gt;config.toml&lt;/code&gt; 中设置 &lt;code&gt;highlight_style = &amp;quot;github&amp;quot;&lt;/code&gt;。
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;只有在 &lt;code&gt;config.toml&lt;/code&gt; 中设置的 &lt;code&gt;highlight_style&lt;/code&gt; 才会生效，在扉页设置的 &lt;code&gt;highlight_style&lt;/code&gt; 不会生效。&lt;/p&gt;
&lt;h2 id=&#34;twitter-tweet&#34;&gt;Twitter tweet&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; tweet 666616452582129664 &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;github-gist&#34;&gt;GitHub gist&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; gist USERNAME GIST-ID &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;latex-数学公式&#34;&gt;LATEX 数学公式&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$$\left [– \frac{\hbar^2}{2 m} \frac{\partial^2}{\partial x^2} + V \right ] \Psi = i \hbar \frac{\partial}{\partial t} \Psi$$
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
$$\left [– \frac{\hbar^2}{2 m} \frac{\partial^2}{\partial x^2} + V \right ] \Psi = i \hbar \frac{\partial}{\partial t} \Psi$$
&lt;/div&gt;
&lt;p&gt;另外，单行的数学公式可以只用单个 &lt;code&gt;$&lt;/code&gt; 包裹：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;This is inline: $\mathbf{y} = \mathbf{X}\boldsymbol\beta + \boldsymbol\varepsilon$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is inline: $\mathbf{y} = \mathbf{X}\boldsymbol\beta + \boldsymbol\varepsilon$&lt;/p&gt;
&lt;p&gt;注意 Markdown 的特殊符号需要使用反斜杠转义，才能被识别为数学公式而非 Markdown 关键字。
比如 &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;_&lt;/code&gt; 应该被替换为 &lt;code&gt;\*&lt;/code&gt; 和 &lt;code&gt;\_&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;多行方程式&#34;&gt;多行方程式&lt;/h3&gt;
&lt;p&gt;标准 LaTeX 的双反斜杠换行应该被替换为 6 个反斜杠：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$$f(k;p\_0^\*) = \begin{cases} p\_0^\* &amp;amp; \text{if }k=1, \\\\\\
1-p\_0^\* &amp;amp; \text {if}k=0.\end{cases}$$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$$f(k;p_0^*) = \begin{cases} p_0^* &amp;amp; \text{if }k=1, \\\&lt;br&gt;
1-p_0^* &amp;amp; \text {if}k=0.\end{cases}$$&lt;/p&gt;
&lt;h3 id=&#34;论文摘要&#34;&gt;论文摘要&lt;/h3&gt;
&lt;p&gt;由于 Hugo 和 Academic 会尝试解析摘要中的 TOML, Markdown, 以及 LaTeX 内容，论文的 &lt;code&gt;abstract&lt;/code&gt; 和 &lt;code&gt;abstract_short&lt;/code&gt; 部分应当遵循下面两个方针：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LaTeX 的反斜杠 &lt;code&gt;\&lt;/code&gt; 应该被转义为双反斜杠，也就是 &lt;code&gt;\\&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;LaTeX 的下划线 &lt;code&gt;_&lt;/code&gt; 应该被转义为双反斜杠加下划线，也就是 &lt;code&gt;\\_&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，&lt;code&gt;abstract = &amp;quot;${O(d_{\max})}$&amp;quot;&lt;/code&gt; 就会变成 &lt;code&gt;abstract = &amp;quot;${O(d\\_{\\max})}$&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;表格&#34;&gt;表格&lt;/h2&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;| Command         | Description         |
| --------------- | ------------------- |
| `hugo`          | Build your website. |
| `hugo serve -w` | View your website.  |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hugo&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build your website.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hugo serve -w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;View your website.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;警报&#34;&gt;警报&lt;/h2&gt;
&lt;p&gt;在你为文章添加提示、注意项、警告时，警报是一个非常有用的功能。
尤其是对于教程性质的文章。
使用对应的短代码以在文章中显示警报：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;{{% alert note %}}
Here&#39;s a tip or note...
{{% /alert %}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会显示为如下 &lt;em&gt;注意&lt;/em&gt; 项：&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Here&amp;rsquo;s a tip or note&amp;hellip;
  &lt;/div&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;{{% alert warning %}}
Here&#39;s some important information...
{{% /alert %}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会展示为如下 &lt;em&gt;警告&lt;/em&gt; 项：&lt;/p&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    Here&amp;rsquo;s some important information&amp;hellip;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;
&lt;p&gt;目录对于长文章或者教程 / 文档可能特别有用，在你 Markdown 正文的任何位置使用 &lt;code&gt;{``{% toc %}``}&lt;/code&gt; 短代码自动生成目录。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>(翻译)Academic 文档 - 内容管理</title>
      <link>https://szthanatos.github.io/post/academic/trans_managing_content/</link>
      <pubDate>Tue, 01 Jan 2019 12:54:11 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/academic/trans_managing_content/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;本文是对 &lt;a href=&#34;https://sourcethemes.com/academic/docs/managing-content/&#34;&gt;Academic 文档 - Managing content 章节&lt;/a&gt; 的个人翻译，基于个人理解，不保证绝对准确。&lt;/p&gt;
&lt;p&gt;原文见上方连接。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这是一个使用 Academic 框架管理你的文章的简短指南。
Academic 提供的内容模板包括出版物、项目、宣讲、新闻 / 博客文章、以及小部件页。
之后，你可能同样对 &lt;a href=&#34;https://szthanatos.github.io/post/trans_writing_content.md&#34;&gt;使用 Markdown、LaTeX 数学公式和代码段进行创作&lt;/a&gt; 感兴趣。&lt;/p&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    Hugo V0.49 版本在使用本指南中的 &lt;code&gt;hugo new&lt;/code&gt; 命令时存在一个 bug，请升级到 V0.50 及以上。
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;精选图片&#34;&gt;精选图片&lt;/h2&gt;
&lt;p&gt;要在文章页显示一个精选图片，简单的将名为 &lt;code&gt;featured.*&lt;/code&gt;(e.g. &lt;code&gt;featured.jpg&lt;/code&gt;) 的图片文件拖拽到文章文件夹即可。&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    如果你的页面在它所属的分类文件夹下没有自己的文件夹 (&lt;a href=&#34;https://gohugo.io/content-management/page-bundles/&#34;&gt;页面包&lt;/a&gt;)，
你可以创建一个和你页面 &lt;code&gt;NAME.md&lt;/code&gt; 同名的文件夹 &lt;code&gt;NAME&lt;/code&gt;，并将页面文件放入文件夹中，变为 &lt;code&gt;NAME/index.md&lt;/code&gt;。
这里有一个 &lt;a href=&#34;https://github.com/sourcethemes/academic-scripts&#34;&gt;自动迁移工具&lt;/a&gt;。
使用页面包需要 Academic v3+ 以及 Hugo v0.50 以上。
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;想要为图片添加标题或者设置一个焦点以控制图片的裁剪？
将下方的参数添加到扉页 (也就是 md 文件 &lt;code&gt;+++&lt;/code&gt; 括起来的部分) 的底部以自定义图片的外观。
标题 (caption) 参数支持使用 Markdown 为图片添加标题或描述。
焦点 (focal_point) 参数确保图片自动缩放的时候主要内容始终可见。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Featured image
# To use, add an image named `featured.jpg/png` to your page&#39;s folder.
[image]
  # Caption (optional)
  caption = &amp;quot;Photo by [Academic](https://sourcethemes.com/academic/)&amp;quot;

  # Focal point (optional)
  # Options: Smart, Center, TopLeft, Top, TopRight, Left, Right, BottomLeft, Bottom, BottomRight
  focal_point = &amp;quot;Smart&amp;quot;

  # Show image only in page previews?
  preview_only = false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;标题图片&#34;&gt;标题图片&lt;/h2&gt;
&lt;p&gt;将下面的 header 参数添加到扉页的末尾，以在页面顶部展示一个占据全部宽度的标题图片。
图片文件默认会从静态图片文件库 &lt;code&gt;static/img/&lt;/code&gt; 读取 (所以不必写全)，所以下面例子的图片文件的完整路径是 &lt;code&gt;static/img/header.png&lt;/code&gt;。
标题参数作用和精选图一致。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;[header]
  image = &amp;quot;header.png&amp;quot;
  caption = &amp;quot;Image credit: [**Academic**](https://github.com/gcushen/hugo-academic/)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数学公式和代码&#34;&gt;数学公式和代码&lt;/h2&gt;
&lt;p&gt;要在页面中启用 &lt;strong&gt;LaTeX&lt;/strong&gt; 渲染数学公式，在页面的扉页中应该申明 &lt;code&gt;math = true&lt;/code&gt;，如同示例网站的例子一样。
或者，在 &lt;code&gt;config.toml&lt;/code&gt; 中设置 &lt;code&gt;math = true&lt;/code&gt;，以在全局范围内允许数学公式渲染。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;config.toml&lt;/code&gt; 中设置 &lt;code&gt;highlight = false&lt;/code&gt; 以全局禁用代码高亮。你可以在需要代码高亮的页面的扉页单独设置 &lt;code&gt;highlight = true&lt;/code&gt;。
查看 &lt;a href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/#code-highlighting&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;code-highlighting docs&lt;/a&gt; 以获取更多细节。&lt;/p&gt;
&lt;h2 id=&#34;页面特性&#34;&gt;页面特性&lt;/h2&gt;
&lt;p&gt;将下述参数添加到页面扉页以管理页面特性：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;reading_time = false  # 显示估计阅读时间
share = false  # 显示分享按钮
profile = false  # 显示作者信息
comments = false  # 显示评论区
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;创建一个出版物&#34;&gt;创建一个出版物&lt;/h2&gt;
&lt;h3 id=&#34;自动&#34;&gt;自动&lt;/h3&gt;
&lt;p&gt;先进的文献管理工具可以帮助你将你的出版物转化为开源的 BibTeX 格式。
如果你是新手的话我们推荐你使用流行的开源工具 &lt;a href=&#34;https://www.zotero.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Zotero&lt;/a&gt; 来管理你的文献。&lt;/p&gt;
&lt;p&gt;在你的文献管理工具中创建你自己的出版物列表并导出为 &lt;code&gt;*.bib&lt;/code&gt; 格式的 BibTeX 文件。&lt;/p&gt;
&lt;p&gt;工具需要 Python3 环境，所以请先 &lt;a href=&#34;https://realpython.com/installing-python/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;安装 Python3&lt;/a&gt;。
同样，为了让你有机会检查 Academic 管理工具产生的改变，你需要备份你的站点，或者确保它已经处于 Git 的管理之中。&lt;/p&gt;
&lt;p&gt;打开你的终端或者命令提示符应用，安装 Academic 管理工具：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip3 install -U academic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;cd&lt;/code&gt; 命令进入你的站点目录。&lt;/p&gt;
&lt;p&gt;之后，导入你的出版物：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;academic import --bibtex &amp;lt;path_to_your/publications.bib&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个工具尚处于测试阶段，目的是为了给你提供辅助。
所以在发布你的站点之前你应该检查 &lt;code&gt;publications&lt;/code&gt; 文件夹下产生的内容。
你同样可以看看下一章节 &lt;code&gt;手动&lt;/code&gt; 部分有关扉页参数的细节，以想办法增强展示效果。&lt;/p&gt;
&lt;p&gt;想要支持这个工具或者提供建议 / 反馈，请查看 &lt;a href=&#34;https://github.com/sourcethemes/academic-admin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Academic admin tool 项目主页&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;手动&#34;&gt;手动&lt;/h3&gt;
&lt;p&gt;另一种选择，使用命令手动的创建出版物：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo new --kind publication publication/&amp;lt;my-publication&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;my-publication&amp;gt;&lt;/code&gt; 是你得出版物的名称，使用 &lt;code&gt;-&lt;/code&gt; 代替空格。&lt;/p&gt;
&lt;p&gt;之后，编辑 &lt;code&gt;content/publication/&amp;lt;my-publication&amp;gt;/index.md&lt;/code&gt; 内含有你的出版物信息的参数。主要参数如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;title&lt;/strong&gt;: 标题&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;date&lt;/strong&gt;: 发布日期 (必须使用有效的 TOML 日期格式)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;publication_types&lt;/strong&gt;: 使用图例来说明你出版物的类型, e.g. conference proceedings&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;publication&lt;/strong&gt;: 你的出版物发布在什么地方 - 允许使用 Markdown 以标注斜体或其他.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;abstract&lt;/strong&gt;: 摘要&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 Markdown 格式将你出版物的细节写到文档的正文部分 (在 &lt;code&gt;+++&lt;/code&gt; 部分之后)。
内容会出现在你的出版物页之上。&lt;/p&gt;
&lt;p&gt;要使访客能够阅读到你的作品，将作品的 PDF 链接填入 &lt;code&gt;url_pdf&lt;/code&gt;，或者将作品 PDF 文件放置到出版物目录并统一为相同命名，这样会自动生成 PDF 的链接。
举例，如果你的出版物说明位于 &lt;code&gt;publication/photons/index.md&lt;/code&gt;，将 PDF 文件重命名并放到 &lt;code&gt;publication/photons/photons.pdf&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;关联其它资源&#34;&gt;关联其它资源&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;url_&lt;/code&gt; 链接以指向本地 / 网络内容。
要关联本地内容的话将之复制到出版物文件夹并使用例如 &lt;code&gt;url_code = &amp;quot;code.zip&amp;quot;&lt;/code&gt; 的方式添加引用。&lt;/p&gt;
&lt;p&gt;你也可以将下面的代码块添加到扉页，以使用自定义链接按钮：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;url_custom = [{name = &amp;quot;Custom Link 1&amp;quot;, url = &amp;quot;http://example.org&amp;quot;},
              {name = &amp;quot;Custom Link 2&amp;quot;, url = &amp;quot;http://example.org&amp;quot;}]
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    想要在扉页的参数中使用双引号或者反斜杠需要额外添加一个反斜杠，&lt;em&gt;例子懒得翻&lt;/em&gt;，更多信息请参阅 &lt;a href=&#34;https://github.com/toml-lang/toml#user-content-string&#34;&gt;TOML 文档&lt;/a&gt;。
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;创建博文&#34;&gt;创建博文&lt;/h2&gt;
&lt;p&gt;要创建一篇新文章：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo new  --kind post post/my-article-name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后用你的完整标题和内容填充新生成的 &lt;code&gt;content/post/my-article-name.md&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;Academic 会自动生成内容摘要并显示在主页上。
如果你不满意自动生成的摘要内容，你可以在文章内容中放置 &lt;code&gt;&amp;lt;!``--more--&amp;gt;&lt;/code&gt; 以限定摘要的长度，
或者像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;summary = &amp;quot;Summary of my post.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在扉页内添加 &lt;code&gt;summary&lt;/code&gt; 参数以覆盖自动生成的摘要。&lt;/p&gt;
&lt;p&gt;要为特定的文章禁止评论，在扉页添加 &lt;code&gt;disable_comments = true&lt;/code&gt; 参数。
要全局的禁止评论的话，在 &lt;code&gt;config.toml&lt;/code&gt; 中设置 &lt;code&gt;disqusShortname = &amp;quot;&amp;quot;&lt;/code&gt; 或者 &lt;code&gt;disable_comments = true&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;创建项目&#34;&gt;创建项目&lt;/h2&gt;
&lt;p&gt;要创建一个项目：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo new  --kind project project/my-project-name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后编辑新生成的 &lt;code&gt;content/project/my-project-name.md&lt;/code&gt; 文件。
在扉页将 &lt;code&gt;external_link = &amp;quot;http://external-project.com&amp;quot;&lt;/code&gt; 设置成已经存在的项目网址，
或者也可以手动在正文中介绍项目的情况。&lt;/p&gt;
&lt;h2 id=&#34;创建演讲&#34;&gt;创建演讲&lt;/h2&gt;
&lt;p&gt;要创建一个演讲：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo new  --kind talk talk/my-talk-name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后用你的完整标题和内容填充新生成的 &lt;code&gt;content/talk/my-talk-name.md&lt;/code&gt; 文件。
你会注意到演讲的很多参数和出版物是类似的。&lt;/p&gt;
&lt;h2 id=&#34;创建幻灯片&#34;&gt;创建幻灯片&lt;/h2&gt;
&lt;p&gt;可以使用 Markdown 非常高效的创建幻灯片并通过你的网站分享给观众。
甚至还包括演讲者笔记。&lt;/p&gt;
&lt;p&gt;查看 &lt;a href=&#34;https://themes.gohugo.io//theme/academic/slides/example-slides#/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;slides demo&lt;/a&gt;
——尽管你可以注意到这个幻灯片是由 Hugo 团队制作的，并且他们缩减了一些功能。
运行 &lt;code&gt;themes/academic/exampleSite/&lt;/code&gt; 下的示例站点以查看完整的包含演讲者笔记的示例。&lt;/p&gt;
&lt;p&gt;查看 &lt;code&gt;themes/academic/exampleSite/content/slides/example-slides.md&lt;/code&gt; 内的 &lt;code&gt;example slide deck&lt;/code&gt; 以开始学习。&lt;/p&gt;
&lt;p&gt;在演讲 / 出版物页面使用 &lt;code&gt;url_slides&lt;/code&gt; 参数来关联到幻灯片。
比如，&lt;code&gt;url_slides = &amp;quot;slides/example-slides&amp;quot;&lt;/code&gt; 可以关联到上面的示例站点。
在 &lt;a href=&#34;https://raw.githubusercontent.com/gcushen/hugo-academic/master/exampleSite/content/talk/example/index.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt; 可以看到包含 &lt;code&gt;url_slides&lt;/code&gt; 的完整扉页的示例。&lt;/p&gt;
&lt;h2 id=&#34;创建课程或文档&#34;&gt;创建课程或文档&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;文档&lt;/em&gt; 是用来 &lt;strong&gt;分享知识&lt;/strong&gt; 的。常见例子包括在线课程、教程、软件文档以及知识库。&lt;/p&gt;
&lt;p&gt;你现在阅读的这个页面 (不是我翻译之后的这个) 就是用_文档_的方式来展现 Academic 相关的。
同样，这里也有一个 &lt;a href=&#34;https://themes.gohugo.io//theme/academic/tutorial/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在线课程&lt;/a&gt; 的例子。&lt;/p&gt;
&lt;p&gt;查看 &lt;code&gt;themes/academic/exampleSite/content/tutorial/&lt;/code&gt; 的示例以学习如何开始。&lt;/p&gt;
&lt;p&gt;如果你是一名使用 R 语言的数据分析师 / 数据科学家 (e.g. RStudio and RMarkdown)，我们推荐你阅读 &lt;a href=&#34;https://github.com/sourcethemes/project-kickstart-r&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;R boilerplate project on GitHub&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;创建小部件页面&#34;&gt;创建小部件页面&lt;/h2&gt;
&lt;p&gt;你是否想利用 Academic 的小部件系统，创建一个和 Academic 主页类似的页面？&lt;/p&gt;
&lt;p&gt;在你的 &lt;code&gt;content&lt;/code&gt; 文件夹下创建一个新的，以你的页面命名的文件夹。在这个例子中我们将创建 &lt;code&gt;content/tutorials/&lt;/code&gt; 文件夹以创建我们的 tutorials 页。&lt;/p&gt;
&lt;p&gt;在新建的 &lt;code&gt;content/tutorials/&lt;/code&gt; 文件夹下创建一个名为 &lt;code&gt;_index.md&lt;/code&gt; 的文件，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;+++
title = &amp;quot;Tutorials&amp;quot;  # Add a page title.
date = 2017-01-01T00:00:00  # Add today&#39;s date.
widgets = true  # Page type is a Widget Page.
summary = &amp;quot;&amp;quot;  # Add a page description.
+++
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将你的小部件放入 &lt;code&gt;content/tutorials/&lt;/code&gt; 文件夹，可以通过复制 &lt;code&gt;content/home/&lt;/code&gt; 下的小部件或者从 &lt;a href=&#34;https://github.com/gcushen/hugo-academic/tree/master/exampleSite/content/home&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github&lt;/a&gt; 上下载来实现。&lt;/p&gt;
&lt;h2 id=&#34;创建其他页面-eg-简历&#34;&gt;创建其他页面 (e.g. 简历)&lt;/h2&gt;
&lt;p&gt;其他类型内容的话，可以创建自己的自定义页面。
例如，我们在 &lt;code&gt;content&lt;/code&gt; 文件夹下创建一个 &lt;code&gt;cv.md&lt;/code&gt; 简历页面。复制任意一个文章的扉页，根据需要进行调整，然后在下面编辑 Markdown 内容。
再之后，您可以使用 &lt;code&gt;[My CV]{``{&amp;lt; ref &amp;quot;cv.md&amp;quot; &amp;gt;}}&lt;/code&gt; 代码将简历添加到任何现有页面的内容上。&lt;/p&gt;
&lt;p&gt;或者，在上面的例子中，我们可以使用简历的 PDF 文件。为此，在 &lt;code&gt;static&lt;/code&gt; 文件夹中创建名为 &lt;code&gt;files&lt;/code&gt; 的文件夹，并将名为 &lt;code&gt;cv.pdf&lt;/code&gt; 的 PDF 文件移动到该位置。
然后可以使用以下代码将 PDF 文件链接到你的任意内容中：&lt;code&gt;{``{% staticref &amp;quot;files/cv.pdf&amp;quot; %}}`` 下载我的简历 ``{``{% /staticref %}}&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;管理列表页&#34;&gt;管理列表页&lt;/h2&gt;
&lt;p&gt;档案 (archive，我理解的就是列表) 页或者说节点页，是列出你所有内容的特殊页面。
博客文章、出版物、演讲都会有列表页。
如果存在一个小部件放不下的内容的话，主页上的小部件会自动链接到列表页。
因此，如果你没有足够多的内容的话你可能不会看到自动生成的链接——
不过你也可以在文章中用一般的 Markdown 链接格式，手动的链接他们。&lt;/p&gt;
&lt;p&gt;你可以通过将以下 &lt;code&gt;_index.md&lt;/code&gt; 文件从示例站点复制到你的 &lt;code&gt;content/&lt;/code&gt; 文件夹中的相同位置，来编辑标题并添加自己的内容（比如简介）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/themes/academic/exampleSite/content/post/_index.md
/themes/academic/exampleSite/content/publication/_index.md
/themes/academic/exampleSite/content/talk/_index.md
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后，根据需要编辑每个 &lt;code&gt;_index.md&lt;/code&gt; 中的 &lt;code&gt;title&lt;/code&gt; 参数，并在扉页之后添加任何内容。
你可能注意到 &lt;code&gt;_index.md&lt;/code&gt; 文件略有不同，其中一些具有可用于关联内容类型的特殊选项。
例如，&lt;code&gt;publication/_index.md&lt;/code&gt; 包含用于设置出版物列表页面上显示的列表的引用样式的选项。&lt;/p&gt;
&lt;h2 id=&#34;移除内容&#34;&gt;移除内容&lt;/h2&gt;
&lt;p&gt;通常来说，要移除任意内容，简单的从你的 &lt;code&gt;content/post&lt;/code&gt;、&lt;code&gt;content/publication&lt;/code&gt;、&lt;code&gt;content/project&lt;/code&gt; 或者 &lt;code&gt;content/talk&lt;/code&gt; 文件夹中删除对应页面文件即可。&lt;/p&gt;
&lt;h2 id=&#34;查看站点更新&#34;&gt;查看站点更新&lt;/h2&gt;
&lt;p&gt;在你对站点做出修改之后，你可以通过执行 &lt;code&gt;hugo server&lt;/code&gt; 并在浏览器中打开 &lt;a href=&#34;http://localhost:1313/&#34;&gt;http://localhost:1313/&lt;/a&gt; 来看到效果。&lt;/p&gt;
&lt;h2 id=&#34;部署站点&#34;&gt;部署站点&lt;/h2&gt;
&lt;p&gt;最后，你可以 &lt;a href=&#34;https://sourcethemes.com/academic/docs/deployment/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;部署你的站点&lt;/a&gt; 了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tmux in 10 minutes</title>
      <link>https://szthanatos.github.io/post/tmux/</link>
      <pubDate>Tue, 01 Jan 2019 12:27:05 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/tmux/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Tmux 是一个终端复用软件，默认的 Linux 终端一个会话只能干一件事，有了 tmux 就能在一个窗口同时管理多个前 / 后台程序了。&lt;/p&gt;
&lt;h2 id=&#34;安装-tmux&#34;&gt;安装 tmux&lt;/h2&gt;
&lt;p&gt;基础软件，跳过&lt;/p&gt;
&lt;h2 id=&#34;基础概念&#34;&gt;基础概念&lt;/h2&gt;
&lt;p&gt;见图&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2021/06/17/Yc5AbRow7niOevt.jpg&#34; alt=&#34;Tmux 页面&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Session&lt;/code&gt;：输入 tmux 后就创建了一个会话，一个会话是一组窗体的集合；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Window&lt;/code&gt;：会话中一个可见的窗口；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pane&lt;/code&gt;: 一个窗口可以分成多个窗格；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用 win10 任务视图 (Win+Tab 调出) 的概念来类比，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Pane&lt;/code&gt; 就是一个个应用窗口，在一个桌面上可以同时开多个 (但是不能堆叠，)；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Window&lt;/code&gt; 就是一组组桌面，同一时间你只能看到一个桌面&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Session&lt;/code&gt; 就是一个用户，区别就是 win10 同一个账户只能登陆一次，tmux 里相当于一个用户登陆 N 次。&lt;/p&gt;
&lt;p&gt;为了控制这些元素，tmux 分为三种模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;控制模式&lt;/code&gt;: （按下或者按住前缀 (tmux-prefix)，默认 ctrl+b, 下文用 &lt;code&gt;※ + X&lt;/code&gt; 表示按下前缀之后按 X，&lt;code&gt;※※ + Y&lt;/code&gt; 表示按住前缀的同时按 Y）相当于各种热键；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;命令模式&lt;/code&gt;: （输入 tmux 后接命令，或者在 tmux 内输入 &lt;code&gt;※ + shift + :&lt;/code&gt;）也就是输入命令，但是执行的不是系统命令，而是 tmux 自身的命令；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;一般模式&lt;/code&gt;:  正常打字；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;和 zsh 一样，得先配置才能用的舒坦。下面是我个人用的配置文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ctrl+b&lt;/code&gt; 被我替换为 &lt;code&gt;Ctrl+x&lt;/code&gt;，横竖分割窗格我分别设置为 &lt;code&gt;-&lt;/code&gt; 和 &lt;code&gt;\&lt;/code&gt;，刚好一横一竖嘛，并且启用了 tpm 管理 tmux 插件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;#-- base --#
# (可选) 设置 zsh 为默认 shell
set -g default-shell /bin/zsh

#-- settings --#
set -g mouse on # 开启鼠标切换窗格，按住 shift 复制粘贴
set -g base-index 1 # 窗口编号从 1 开始计数
set -g renumber-windows on # 关掉某个窗口后，编号重排
set -g pane-base-index 1 # 窗格编号从 1 开始计数
set -g display-panes-time 5000 # PREFIX-Q 显示编号的驻留时长，单位 ms
setw -g mode-keys vi # 进入复制模式的时候使用 vi 键位（默认是 EMACS）
setw -g allow-rename off # 禁止活动进程修改窗口名
setw -g automatic-rename off # 禁止自动命名新窗口
set -g default-terminal &amp;quot;tmux-256color&amp;quot; # 开启 256 colors 支持

#-- bindkeys --#
# 以下 3 行设置 ctrl+x 代替 ctrl+b 的快捷键
set -g prefix C-x
unbind C-b
bind C-x send-prefix

# 设置 tmux-prefix + \ 垂直分割窗格
unbind %
bind \ split-window -h
# 设置 tmux-prefix + - 水平分割窗格
unbind &#39;&amp;quot;&#39;
bind - split-window -v

# 设置 ctrl+vim 方式切换窗格
bind -n C-h select-pane -L
bind -n C-j select-pane -D
bind -n C-k select-pane -U
bind -n C-l select-pane -R

# plugins
# tmux plugin manager 插件管理
set -g @plugin &#39;tmux-plugins/tpm&#39;
set -g @plugin &#39;tmux-plugins/tmux-sensible&#39;
# 保存布局插件，tmux-prefix + ctrl+s/tmux-prefix + ctrl+r 保存 / 恢复
set -g @plugin &#39;tmux-plugins/tmux-resurrect&#39;
# 自动保存插件
set -g @plugin &#39;tmux-plugins/tmux-continuum&#39;

# tmux-resurrect 配置
# 恢复 shell 的历史记录, 只有无前台任务运行的窗格 才能被保存
set -g @resurrect-save-bash-history &#39;on&#39;
# 恢复窗格内容, 目前使用该功能时，请确保 tmux 的 default-command 没有包含 &amp;amp;&amp;amp; 或者 || 操作符，
# 否则将导致 bug。（查看 default-command 的值，请使用命令 tmux show -g default-command。）
set -g @resurrect-capture-pane-contents &#39;on&#39;
# 恢复 vim 会话
set -g @resurrect-strategy-vim &#39;session&#39;

# set -g @resurrect-save &#39;S&#39;
# set -g @resurrect-restore &#39;R&#39;

# tmux-continuum 配置
# 开启自动恢复
set -g @continuum-restore &#39;on&#39;
# 设置备份间隔（分钟，0 为不自动备份）
set -g @continuum-save-interval &#39;240&#39;
# 状态栏查看备份状态
# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)
set -g status-right &#39;Continuum status: #{continuum_status}&#39;

run &#39;/etc/.tmux/plugins/tpm/tpm&#39;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体配置步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编辑 &lt;code&gt;.tmux.conf&lt;/code&gt; 文件放到你的根目录下；&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;git clone https://github.com/tmux-plugins/tpm /etc/.tmux/plugins/tpm&lt;/code&gt; 将 tpm 安装到 &lt;code&gt;etc&lt;/code&gt; 目录下
(或者随你喜欢，我是个人和 root 共用一套配置，所以放个公共的地)；&lt;/li&gt;
&lt;li&gt;输入 &lt;code&gt;tmux source-file ~/.tmux.conf&lt;/code&gt; 载入配置；&lt;/li&gt;
&lt;li&gt;进入 tmux，输入 &lt;code&gt;※ + U&lt;/code&gt; 查看 tpm 插件更新，弹出页面默认打开命令模式，直接输入 &lt;code&gt;all&lt;/code&gt; 完成更新；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;常用控制&#34;&gt;常用控制&lt;/h2&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    注意，下列所有快捷键区分大小写。
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;会话&#34;&gt;会话&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;※ + d&lt;/td&gt;
&lt;td&gt;休眠&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + s&lt;/td&gt;
&lt;td&gt;以菜单方式显示和选择会话&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + L&lt;/td&gt;
&lt;td&gt;切换回上一次的会话&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;窗口&#34;&gt;窗口&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;※ + c&lt;/td&gt;
&lt;td&gt;创建新窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + n&lt;/td&gt;
&lt;td&gt;选择下一个窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + p&lt;/td&gt;
&lt;td&gt;选择前一个窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + l&lt;/td&gt;
&lt;td&gt;最近一次活跃窗口之间进行切换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + 0~9&lt;/td&gt;
&lt;td&gt;选择几号窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + ,&lt;/td&gt;
&lt;td&gt;重命名窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + .&lt;/td&gt;
&lt;td&gt;更改窗口的编号，但只能更改成未使用的编号，所以要交换窗口的话，得多次更改进行交换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + &amp;amp;&lt;/td&gt;
&lt;td&gt;关闭窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + w&lt;/td&gt;
&lt;td&gt;以菜单方式显示及选择窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + f&lt;/td&gt;
&lt;td&gt;在所有窗口中查找内容&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;窗格&#34;&gt;窗格&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;※ + z&lt;/td&gt;
&lt;td&gt;最大化 / 还原当前窗格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + &amp;quot;&lt;/td&gt;
&lt;td&gt;模向分隔窗格，&lt;strong&gt;替换为了 &lt;code&gt;-&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + %&lt;/td&gt;
&lt;td&gt;纵向分隔窗格，&lt;strong&gt;替换为了 &lt;code&gt;\&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + o&lt;/td&gt;
&lt;td&gt;跳到下一个分隔窗格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + x&lt;/td&gt;
&lt;td&gt;关闭窗格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + ;&lt;/td&gt;
&lt;td&gt;切换到最后一个使用的窗格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + ↑/↓/←/→&lt;/td&gt;
&lt;td&gt;切换到上 / 下 / 左 / 右的窗格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※※ + h/j/k/l&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;自定义配置，vim 方式切换窗格&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + q&lt;/td&gt;
&lt;td&gt;显示窗格编号，并在右上角显示窗格的长宽&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + 空格键&lt;/td&gt;
&lt;td&gt;自动排布窗格，可多次执行尝试多种布局&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;tpm-插件&#34;&gt;tpm 插件&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;※ + S&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;自定义配置，保存当前布局&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;※ + R&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;自定义配置，还原保存的布局&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;鼠标操作&#34;&gt;鼠标操作&lt;/h2&gt;
&lt;p&gt;鼠标按住窗格的分割线可以修改窗格大小；&lt;/p&gt;
&lt;p&gt;如果你用 &lt;code&gt;wsltty&lt;/code&gt; 或者其他软件，发现右键 / 中键失效，记得按住修饰键 (比如 &lt;code&gt;Shift&lt;/code&gt;) 再试。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Git Tips</title>
      <link>https://szthanatos.github.io/post/git/git_tips/</link>
      <pubDate>Fri, 14 Dec 2018 09:35:32 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/git/git_tips/</guid>
      <description>&lt;h2 id=&#34;deploy-keyssh-keygithub&#34;&gt;Deploy key/SSH key(github)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Deploy key&lt;/code&gt; 是在 &lt;code&gt;项目主页&lt;/code&gt;-&lt;code&gt;setting&lt;/code&gt;-&lt;code&gt;Delpoy keys&lt;/code&gt; 下进行添加，如果勾选 &lt;code&gt;Allow write access&lt;/code&gt;，则相当于具有对这个项目的读写权限 (否则只能 &lt;code&gt;clone&lt;/code&gt; 不能 &lt;code&gt;push&lt;/code&gt;)。&lt;strong&gt;作用范围是这个项目。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SSH key&lt;/code&gt; 是在你 &lt;code&gt;个人主页&lt;/code&gt;-&lt;code&gt;Settings&lt;/code&gt;-&lt;code&gt;SSH and GPG keys&lt;/code&gt; 下进行添加。&lt;strong&gt;作用范围是你的账户下的所有项目。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同一个 &lt;code&gt;公钥&lt;/code&gt;，只能作为整个账户的 &lt;code&gt;SSH key&lt;/code&gt;，或者 &lt;strong&gt;一个项目&lt;/strong&gt; 的 &lt;code&gt;Deploy key&lt;/code&gt;。想为一台机器授予多个项目的读写权限的话，需要通过 &lt;code&gt;ssh-keygen&lt;/code&gt; 生成多个密钥，分别作为不同项目的 &lt;code&gt;Deploy key&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;更换-git-协议&#34;&gt;更换 git 协议&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;http&lt;/code&gt;/&lt;code&gt;https&lt;/code&gt; 协议连接仓库相比 &lt;code&gt;ssh&lt;/code&gt; 即不够安全，也会存在 &lt;code&gt;push&lt;/code&gt; 的时候必须输入用户名密码的问题。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;git remote -v&lt;/code&gt; 可以查看项目使用的协议。&lt;/p&gt;
&lt;p&gt;如果是新建的项目，推荐在一开始就使用 &lt;code&gt;git@github.com:{USER}/{PROJECT}.git&lt;/code&gt; 进行 &lt;code&gt;clone&lt;/code&gt;。这样默认都是用 &lt;code&gt;ssh&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;如果是已有项目，使用 &lt;code&gt;git remote set-url {repository} {url}&lt;/code&gt; 更改。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git remote -v
origin  https://github.com/abc/bcd.git (fetch)
origin  https://github.com/abc/bcd.git (push)

$ git remote set-url origin git@github.com:abc/bcd.git

$ git remote -v
origin  git@github.com:abc/bcd.git (fetch)
origin  git@github.com:abc/bcd.git (push)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;强制覆盖本地文件&#34;&gt;强制覆盖本地文件&lt;/h2&gt;
&lt;p&gt;啥都别说了，直接重来吧：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git fetch --all
git reset --hard origin/master
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;撤销修改&#34;&gt;撤销修改&lt;/h2&gt;
&lt;h3 id=&#34;add-之前撤销&#34;&gt;add 之前撤销&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 单个文件
git checkout FileName

# 所有文件
git checkout .
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;commit-之前撤销&#34;&gt;commit 之前撤销&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 取消暂存
git reset HEAD FileName

# 撤销修改
git checkout FileName
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;push-之前撤销&#34;&gt;push 之前撤销&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git reset [--hard|soft|mixed] [commit|HEAD]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;删除历史提交记录&#34;&gt;删除历史提交记录&lt;/h2&gt;
&lt;p&gt;commit 多了项目也会膨胀&amp;hellip; 清了一干二净。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 用 orphan 参数创建全新的分支
git checkout --orphan {new_branch}

# 添加所有文件
git add -A

# 提交
git commit -am &amp;quot;commit message&amp;quot;

# 删除原始分支
git branch -D {old_branch}

# 交换分支
git branch -m {old_branch}

# 强制提交变更
git push -f origin {old_branch}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;忽略文件权限&#34;&gt;忽略文件权限&lt;/h2&gt;
&lt;p&gt;文件在系统间转移的时候可能由于权限改变而使文件全都处于 &amp;ldquo;modified&amp;rdquo; 状态。（比如从 linux 到 Windows，权限会从 644 变成 755）可以以项目为单位设置忽略文件权限：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git config core.filemode false
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Academic 实现 Github Page 个人博客</title>
      <link>https://szthanatos.github.io/post/academic/academic_in_practice/</link>
      <pubDate>Sun, 09 Dec 2018 16:34:42 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/academic/academic_in_practice/</guid>
      <description>&lt;h2 id=&#34;hugo-安装--更新&#34;&gt;Hugo 安装 / 更新&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://gohugo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hugo&lt;/a&gt; 是使用 &lt;code&gt;Go&lt;/code&gt; 语言开发的静态站点生成器。不过无需准备 &lt;code&gt;Go&lt;/code&gt; 语言环境，可以直接通过二进制编译包进行跨平台部署。&lt;/p&gt;
&lt;p&gt;以下均以 Ubuntu18.0 为例。&lt;/p&gt;
&lt;h3 id=&#34;安装--更新&#34;&gt;安装 / 更新&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;前往 &lt;a href=&#34;https://github.com/gohugoio/hugo/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github 页面&lt;/a&gt; 下载最新版本，这里我们下载 &lt;code&gt;hugo_0.52_Linux-64bit.deb&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;使用命令 &lt;code&gt;dpkg -i hugo_0.52_Linux-64bit.deb&lt;/code&gt; 安装 hugo;&lt;/li&gt;
&lt;li&gt;更新即重复上面两步，覆盖安装即可;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;常用命令&#34;&gt;常用命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;hugo&lt;/code&gt;&lt;/strong&gt;： 编译项目生成静态网站，默认位置在项目的 &lt;code&gt;public&lt;/code&gt; 目录下&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;hugo server&lt;/code&gt;&lt;/strong&gt;： 启动你的网站服务，可以通过浏览器访问 &lt;code&gt;http://127.0.0.1:1313/&lt;/code&gt; 访问站点;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;hugo new {folder}/{name}.md&lt;/code&gt;&lt;/strong&gt;: 创建新文章，使用 &lt;code&gt;markdown&lt;/code&gt; 进行排版，一般默认放在 &lt;code&gt;post&lt;/code&gt; 文件夹下；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本没了，一般情况下用这三个命令就够了。&lt;/p&gt;
&lt;h2 id=&#34;academic-安装--更新&#34;&gt;Academic 安装 / 更新&lt;/h2&gt;
&lt;p&gt;Academic 是一个 Hugo 主题，从名字就可以知道这个主题比较学院派，适合科研 / 学术人员发布个人信息 / 介绍科研项目，当然，拿来做个人博客也是没问题的。&lt;/p&gt;
&lt;h3 id=&#34;通过-netlify&#34;&gt;通过 Netlify&lt;/h3&gt;
&lt;p&gt;Academic 推荐使用第三方博客管理平台 &lt;a href=&#34;https://app.netlify.com/start/deploy?repository=https://github.com/sourcethemes/academic-kickstart&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netlify&lt;/a&gt; 安装，如果你没有域名或者没想建站，只是想自己使用，那我建议不使用它的服务——请直接跳到下一部分，否则跟随网站引导完成安装;&lt;/p&gt;
&lt;h3 id=&#34;通过-git&#34;&gt;通过 Git&lt;/h3&gt;
&lt;h4 id=&#34;安装&#34;&gt;安装&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;通过 git 安装的话，首先建议你在 GitHub 上 fork 成你自己的项目，默认的话，通过 &lt;code&gt;git clone https://github.com/sourcethemes/academic-kickstart.git My_Website&lt;/code&gt; 将代码克隆到本地文件夹 &lt;code&gt;My_Website&lt;/code&gt; &lt;em&gt;(当然，更推荐使用 ssh 协议，更安全，也免于 push 时输入密码，这里暂时按官方的来)&lt;/em&gt; ;&lt;/li&gt;
&lt;li&gt;进入文件夹，初始化项目：&lt;code&gt;git submodule update --init --recursive&lt;/code&gt;，完成安装;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;自动更新&#34;&gt;自动更新&lt;/h4&gt;
&lt;p&gt;说是自动，还是需要手动执行一条命令：&lt;code&gt;git submodule update --remote --merge&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;这么做的前提条件是你是 &lt;code&gt;install&lt;/code&gt; 的，也就是 &lt;code&gt;git submodule update --init --recursive&lt;/code&gt; 过的，而不是直接把 &lt;code&gt;academic&lt;/code&gt; 给 clone 到 themes 文件夹。&lt;/p&gt;
&lt;h4 id=&#34;手动更新&#34;&gt;手动更新&lt;/h4&gt;
&lt;p&gt;如果是 clone 到 themes 文件夹的话要这么更新：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;cd themes/academic&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;origin&lt;/code&gt; 仓库重命名为 &lt;code&gt;upstream&lt;/code&gt;：&lt;code&gt;git remote rename origin upstream&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;将更新下载到本地：&lt;code&gt;git fetch upstream&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;列出可用更新：&lt;code&gt;git log --pretty=oneline --abbrev-commit --decorate HEAD..upstream/master&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;更新：&lt;code&gt;git pull upstream&lt;/code&gt;;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;部署到-github-pages&#34;&gt;部署到 Github Pages&lt;/h2&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;网上介绍的办法很多，但核心其实就一句：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将 &lt;code&gt;hugo&lt;/code&gt; 命令生成的 &lt;code&gt;public&lt;/code&gt; 文件夹上传到 GitHub pages 项目下&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; 文件夹相当于编译完成的静态网站，你在本地打开其实就能看。换句话说，你每次手动将这个目录下的内容上传到你的 GitHub page 项目也是可以的。&lt;/p&gt;
&lt;p&gt;然后为了达到这个目的，Academic 给出的做法是利用 &lt;code&gt;git submodule&lt;/code&gt; 将你的 &lt;code&gt;GitHub page&lt;/code&gt; 项目作为 &lt;code&gt;My_Website&lt;/code&gt; 项目的子模块存放到 &lt;code&gt;public&lt;/code&gt; 目录。那么当你更新你的文章之后，只提交 &lt;code&gt;public&lt;/code&gt; 文件夹内的变更到 &lt;code&gt;GitHub page&lt;/code&gt; 项目即可。&lt;/p&gt;
&lt;h3 id=&#34;官方教程-缩减版&#34;&gt;官方教程 (缩减版)&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&#34;https://sourcethemes.com/academic/docs/deployment/#github-pages&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;原教程&lt;/a&gt; 看这里；&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 GitHub 上创建两个项目，一个是 fork 的 &lt;a href=&#34;https://github.com/sourcethemes/academic-kickstart.git&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;academic-kickstart&lt;/a&gt;，也就是你前面 clone 到本地的 &lt;code&gt;My_Website&lt;/code&gt;，另一个即是以你用户名 / 组织名开头、以 &lt;code&gt;.github.io&lt;/code&gt; 结尾的 GitHub page 项目。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;My_Website&lt;/code&gt; 目录下执行 &lt;code&gt;git submodule update --init --recursive&lt;/code&gt; 将子模块更新到最新状态；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 &lt;code&gt;config.toml&lt;/code&gt; 中的 &lt;code&gt;baseurl&lt;/code&gt; 设置为你的 GitHub page 地址；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;(实质)&lt;/strong&gt; 删除 &lt;code&gt;public&lt;/code&gt; 文件夹 (如果有的话)，将 GitHub page 项目添加为子模块：&lt;code&gt;git submodule add -f -b master https://github.com/&amp;lt;USERNAME&amp;gt;/&amp;lt;USERNAME&amp;gt;.github.io.git public&lt;/code&gt;;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;这时候你的 &lt;code&gt;My_Website&lt;/code&gt; 项目实际上有两个子模块：作为主题依赖的 &lt;code&gt;themes/academic&lt;/code&gt; 和作为网站的 &lt;code&gt;&amp;lt;USERNAME&amp;gt;.github.io&lt;/code&gt;；&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;有意思的是一般是子模块 &lt;code&gt;themes/academic&lt;/code&gt; 更新了之后，你更新主项目 &lt;code&gt;My_Website&lt;/code&gt; 的依赖；&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;而你更新主项目 &lt;code&gt;My_Website&lt;/code&gt; 的文章之后，再会手动的更新子模块 &lt;code&gt;&amp;lt;USERNAME&amp;gt;.github.io&lt;/code&gt;，刚好反过来。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新增 / 编辑文章后，更新 &lt;code&gt;academic-kickstart&lt;/code&gt; 项目：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;Initial commit&amp;quot;
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新 GitHub page 项目：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo
cd public
git add .
git commit -m &amp;quot;Build website&amp;quot;
git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实际上只有第六步是更新 GitHub page，每次重复执行这一部分就行 (如果你不把文章保存到 &lt;code&gt;academic-kickstart&lt;/code&gt; 的话)。&lt;/p&gt;
&lt;h3 id=&#34;脚本&#34;&gt;脚本&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Hugo&lt;/code&gt; 官方把上面步骤打包到了一个脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

echo -e &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m&amp;quot;

# Build the project.
hugo # if using a theme, replace with `hugo -t &amp;lt;YOURTHEME&amp;gt;`

# Go To Public folder
cd public
# Add changes to git.
git add .

# Commit changes.
msg=&amp;quot;rebuilding site `date`&amp;quot;
if [$# -eq 1]
  then msg=&amp;quot;$1&amp;quot;
fi
git commit -m &amp;quot;$msg&amp;quot;

# Push source and build repos.
git push origin master

# Come Back up to the Project Root
cd ..
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际上我们干脆连第五步也放进去呗：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
# Receive args.
if [$1 = &amp;quot;push&amp;quot;]; then
    if [$# -eq 1]; then
        TIME_NOW=$(date +%T\ %F)
        MSG=&amp;quot;Change something nobody knows at ${TIME_NOW}...&amp;quot;
        EDITED_FILE=&amp;quot;.&amp;quot;

    elif [$# -eq 2]; then
        MSG=&amp;quot;$2&amp;quot;
        EDITED_FILE=&amp;quot;.&amp;quot;

    elif [$# -gt 2]; then
        MSG=&amp;quot;$2&amp;quot;
        shift 2
        EDITED_FILE=&amp;quot;$*&amp;quot;

    else
        echo &amp;quot;WTF?&amp;quot;

    fi

    echo &amp;quot;\033[0;32m
    ---------------------------
    Deploying to GitHub Page...
    ---------------------------
    \033[0m&amp;quot;

    # Build the project.
    hugo # if using a theme, replace with `hugo -t &amp;lt;YOURTHEME&amp;gt;`

    # Go To Public folder
    cd public

    # Add changes to git.
    git add .

    # Commit changes.
    git commit -m &amp;quot;$MSG&amp;quot;

    # Push source and build repos.
    git push origin master

    # Come Back up to the Project Root
    cd ..

    echo &amp;quot;\033[0;32m
    -----------------------------
    Updating content to GitHub...
    -----------------------------
    \033[0m&amp;quot;

    # Add changes to git.
    git add $EDITED_FILE

    # Commit changes.
    git commit -m &amp;quot;$MSG&amp;quot;

    # Push source and build repos.
    git push origin master

elif [$1 = &amp;quot;pull&amp;quot;]; then

    # Update main repo.
    git pull

    # Update submodule.
    git submodule update

    echo &amp;quot;Synchronize finish.&amp;quot;

else
    echo &amp;quot;Determine What you wanna do.&amp;quot;

fi

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将脚本保存为 &lt;code&gt;deploy.sh&lt;/code&gt;，放到项目根目录下，完成修改后执行 &lt;code&gt;./deploy.sh&lt;/code&gt; + &lt;code&gt;pull&lt;/code&gt;/&lt;code&gt;push&lt;/code&gt; 一键从服务器同步 / 提交 + 部署。&lt;/p&gt;
&lt;p&gt;参数的第一个是你要执行的动作，从远程服务器 down 到本地的话就是 &lt;code&gt;./deploy.sh pull&lt;/code&gt;，不用接别的。&lt;/p&gt;
&lt;p&gt;如果是要将更新上传到服务器并部署，那就执行 &lt;code&gt;./deploy.sh push&lt;/code&gt; + commit message，提交消息可以不写 (但最好还是写一下)：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./deploy.sh push &amp;quot;{Your optional commit message}&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果修改了多个文件，只想提交其中的一部分文件以保持 commit 的纯净，那就在 mesaage 后面附加你要提交的文件路径 (不超过 10 个&amp;hellip;)：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./deploy.sh push &amp;quot;{Your optional commit message}&amp;quot; path1 path2...&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;个性化配置&#34;&gt;个性化配置&lt;/h2&gt;
&lt;p&gt;项目目录结构大体如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;content 目录&lt;/code&gt;： 网站内容，&lt;code&gt;home&lt;/code&gt; 是你的主页的小控件，&lt;code&gt;post&lt;/code&gt; 是默认文章存放位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public 目录&lt;/code&gt;： 生成的静态页面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resouces 目录&lt;/code&gt;： JS 资源存放位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static 目录&lt;/code&gt;： 静态资源存放位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;themes 目录&lt;/code&gt;： 主题文件所在目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;config.toml&lt;/code&gt;: 全局配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;configtoml-主要配置项解释&#34;&gt;config.toml 主要配置项解释&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;配置项&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;baseurl&lt;/td&gt;
&lt;td&gt;你的站点的 url，不设置这个你的文章 / 资源可能相互引用不到&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;title&lt;/td&gt;
&lt;td&gt;网站标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;defaultContentLanguage&lt;/td&gt;
&lt;td&gt;默认语言，中文的话填 &lt;code&gt;zh&lt;/code&gt;，在文件末尾还有一处配置要同时修改才行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hasCJKLanguage&lt;/td&gt;
&lt;td&gt;是否有中 / 日 / 韩语&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;defaultContentLanguageInSubdir&lt;/td&gt;
&lt;td&gt;目录是否允许用默认语言，&lt;code&gt;true&lt;/code&gt; 就对了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;highlight_languages&lt;/td&gt;
&lt;td&gt;语法高亮，支持的语言可以去 &lt;a href=&#34;https://cdnjs.com/libraries/highlight.js/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;highlight.js&lt;/a&gt; 查到&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[[menu.main]]&lt;/td&gt;
&lt;td&gt;这部分是你主页上标题栏显示的内容，&lt;code&gt;url&lt;/code&gt; 默认和你 &lt;code&gt;content/home&lt;/code&gt; 下的文件名对应&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Languages&lt;/td&gt;
&lt;td&gt;添加中文支持的话，把 &lt;code&gt;[languages.zh]&lt;/code&gt; 部分解除注释，&lt;code&gt;languageCode&lt;/code&gt; 写 &lt;code&gt;&amp;quot;zh-cn&amp;quot;&lt;/code&gt;，添加其他语种的话，相同格式再写一组 &lt;code&gt;[languages.XX]&lt;/code&gt; 即可，支持的语言代码可以在 &lt;code&gt;themes\academic\i18n&lt;/code&gt; 查看&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;修改网站-logo&#34;&gt;修改网站 logo&lt;/h3&gt;
&lt;p&gt;默认的 logo 是 Academic 的蓝色学位帽，想替换的话将你想用的 logo 保存为
&lt;code&gt;icon.png&lt;/code&gt;(默认 32&lt;em&gt;32 像素，大了也没关系)
和 &lt;code&gt;icon-192.png&lt;/code&gt;(192&lt;/em&gt;192 像素)，并放到项目的 &lt;code&gt;static/img&lt;/code&gt; 目录下&lt;/p&gt;
&lt;h3 id=&#34;给文章添加精选图&#34;&gt;给文章添加精选图&lt;/h3&gt;
&lt;p&gt;这个图片只能添加一个，名字必须是 &lt;code&gt;featured.*&lt;/code&gt;(后缀 jpg/png 都行)，而且必须和文章放在同一个文件夹下。&lt;/p&gt;
&lt;p&gt;所以一般做法是把文章 &lt;code&gt;aaa.md&lt;/code&gt; 改名为 &lt;code&gt;index.md&lt;/code&gt; 并新建一个 &lt;code&gt;aaa&lt;/code&gt; 目录，再和 &lt;code&gt;featured.png&lt;/code&gt; 图片一起扔进去。&lt;/p&gt;
&lt;p&gt;显示的效果是在文章列表页，文章右侧有一个缩略图；打开文章，标题默认会居左，右边是精选图：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2021/06/17/w9J1YNL7zDE26od.png&#34; alt=&#34;example&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;给文章添加头部背景&#34;&gt;给文章添加头部背景&lt;/h3&gt;
&lt;p&gt;这个是文章头部的横跨整个页面的大图，也就是文章头部这个黑底白字的大图。&lt;/p&gt;
&lt;p&gt;这个的图片可以放到 &lt;code&gt;static/img&lt;/code&gt; 目录下，不过需要在你文件的 &lt;code&gt;+++&lt;/code&gt; 的部分添加如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;[header]
  image = &amp;quot;img 名称&amp;quot;
  caption = &amp;quot;标题说明&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;顺便一提，文章内引用 &lt;code&gt;static/img&lt;/code&gt; 下存储的图像的话，路径大致如此 &lt;code&gt;![example](/media/image_abc.png)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;目录&#34;&gt;目录&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;{``{% toc %}}&lt;/code&gt; 加在文章的任何你想要的地方以自动生成目录&lt;/p&gt;
&lt;h3 id=&#34;注意--警告标识&#34;&gt;注意 / 警告标识&lt;/h3&gt;
&lt;p&gt;被 &lt;code&gt;{``{% alert note %}}&lt;/code&gt; 和 &lt;code&gt;{``{% /alert %}}&lt;/code&gt; 包裹起来的内容即为注意项：&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    注意内容 blabla
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;被 &lt;code&gt;{``{% alert warning %}}&lt;/code&gt; 和 &lt;code&gt;{``{% /alert %}}&lt;/code&gt; 包裹起来的内容即为警告项：&lt;/p&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    警告内容 blabla
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;消除短代码效果&#34;&gt;消除短代码效果&lt;/h3&gt;
&lt;p&gt;Hugo 是基于 Go 的 Template，所以所有以 &lt;code&gt;{``{% %}}&lt;/code&gt; 或者 &lt;code&gt;{``{&amp;lt; &amp;gt;}}&lt;/code&gt; 包裹的内容都会被解析为短代码块，而无法直接显示其代码。
那么我是怎么解决的呢，分情况：&lt;/p&gt;
&lt;h4 id=&#34;单行代码&#34;&gt;单行代码&lt;/h4&gt;
&lt;p&gt;你看到的 &lt;code&gt;{``{% toc %}}&lt;/code&gt; 实际是由 &lt;code&gt;`{`&lt;/code&gt; 和 &lt;code&gt;`{% toc %}}`&lt;/code&gt; 组成的。&lt;/p&gt;
&lt;p&gt;而上面打出的 &lt;code&gt;`&lt;/code&gt; 其实是 &lt;code&gt;双反引号 空格 反引号 空格 双反引号&lt;/code&gt;，就不再嵌套了。。。&lt;/p&gt;
&lt;h4 id=&#34;代码块&#34;&gt;代码块&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{{&amp;lt; figure library=&amp;quot;1&amp;quot; src=&amp;quot;image.jpg&amp;quot; title=&amp;quot;A caption&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;的本质是将 &amp;lt;&amp;gt; 或者 %% 内的内容用 /**/ 注释掉：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{``{&amp;lt;/* figure library=&amp;quot;1&amp;quot; src=&amp;quot;image.jpg&amp;quot; title=&amp;quot;A caption&amp;quot; */&amp;gt;}}&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    谁知道 Markdown 的代码块怎么嵌套&amp;hellip;
比如外层一个 markdown 的代码块，
里面要显示包含反引号格式的 python 代码块&amp;hellip;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;修改模板&#34;&gt;修改模板&lt;/h3&gt;
&lt;p&gt;比如你看到我每个文章结尾都有一个 &lt;a href=&#34;http://creativecommons.org/licenses/by-sa/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;CC4.0 协议&lt;/code&gt;&lt;/a&gt; 的标志，这个肯定不是一篇篇手动添加的，实际上我是自己写了一个 License 的 Widget，插入到文章的模板里面实现的。&lt;/p&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    不要直接修改 &lt;code&gt;theme&lt;/code&gt; 里面的内容，否则更新主题的时候会非常尴尬。
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;正确的做法是在项目根目录建立 &lt;code&gt;layouts&lt;/code&gt; 文件夹，将你想修改的模板从 &lt;code&gt;themes/academic/layouts&lt;/code&gt; 拷贝过来再修改。&lt;/p&gt;
&lt;p&gt;现在 Academic 主题的 layouts 大概是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_default&lt;/code&gt;: 默认文章相关模板；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docs&lt;/code&gt;: 文档相关模板;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;home&lt;/code&gt;: 主页相关模板;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;partials&lt;/code&gt;: 小部件相关模板，页面头部 / 脚注 / 摘要等等的都在这;
&lt;ul&gt;
&lt;li&gt;额外的有一个 &lt;code&gt;widgets&lt;/code&gt; 文件夹，里面是主页的 widget 的模板；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;project&lt;/code&gt;: 项目相关模板;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;publication&lt;/code&gt;: 出版物相关模板;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;section&lt;/code&gt;: 摘要相关模板;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shortcodes&lt;/code&gt;: Academic 提供的额外效果模板，你写的所有 &lt;code&gt;{``{%%}}&lt;/code&gt; 的内容效果都出自这里;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slides&lt;/code&gt;: 幻灯片相关模板;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;talk&lt;/code&gt;: 宣讲相关模板;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;继续用我自己做例子，我新建了 &lt;code&gt;layouts/partials/license.html&lt;/code&gt;，把 CC 协议相关内容存了进去，
接着，复制主题目录下的 &lt;code&gt;layouts/_default/single.html&lt;/code&gt; 到对应位置，在合适地方插入一句 &lt;code&gt;{{partial &amp;quot;license.html&amp;quot; .}}&lt;/code&gt;，表明我要在这里使用名为 &lt;code&gt;license.html&lt;/code&gt; 的 &lt;code&gt;partial&lt;/code&gt;。
再之后就是你们看到的效果了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>hbase 表设计风格指南</title>
      <link>https://szthanatos.github.io/post/hbase_design/</link>
      <pubDate>Sun, 09 Dec 2018 16:19:27 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/hbase_design/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;本指南是对在 HBase 进行字段设计而提供的指导性准则和建议。总体标准、设计方式参照 &lt;a href=&#34;https://github.com/google/styleguide&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google 开源项目风格指南&lt;/a&gt; 以及现有项目经验。所有条目均为个人总结，&lt;strong&gt;并不是一份官方标准性质的指南&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;HBase 是建立在 Hadoop 文件系统（HDFS）之上的分布式、面向列的数据库。&lt;/p&gt;
&lt;h2 id=&#34;一般原则&#34;&gt;一般原则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;无论是表或者是列或者其他，都应该使用名词或者动宾短语以代表一类对象;&lt;/li&gt;
&lt;li&gt;尽量避免使用 (尤其是单独使用) 例如 &lt;code&gt;int&lt;/code&gt;、&lt;code&gt;join&lt;/code&gt;、&lt;code&gt;select&lt;/code&gt; 等常见保留词;&lt;/li&gt;
&lt;li&gt;HBase 在性能和效率上更擅长处理 “高而瘦” 的表，而非 “矮而胖” 的表——以 Excel 类比，HBase 应该尽可能设计成只有很少的列 (瘦) 而有非常多行 (高) 的模式;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;命名空间-namespace&#34;&gt;命名空间 (NameSpace)&lt;/h2&gt;
&lt;h3 id=&#34;命名规范&#34;&gt;命名规范&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;采用英文单词、阿拉伯数字的组合形式，其中，单词必须大写，并且首字符必须为英文字符，不能是数字;&lt;/li&gt;
&lt;li&gt;不建议用连接符（下划线）拼接多个单词，简单语义的可采用单个单词，复杂语义的可采用多个单词的首字母拼接;&lt;/li&gt;
&lt;li&gt;长度尽量限制在 4~8 字符之间;&lt;/li&gt;
&lt;li&gt;命名空间一般可与项目名称、组织机构名称等保持一致;&lt;/li&gt;
&lt;li&gt;一般情况下如果不指定命名空间，表会被放在默认 (default) 命名空间下;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ZKR
XJ917
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;表-table&#34;&gt;表 (Table)&lt;/h2&gt;
&lt;h3 id=&#34;命名规范-1&#34;&gt;命名规范&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;采用英文单词、阿拉伯数字、连接符（_）的组合形式，其中，单词必须大写，并且首字符必须为英文字符，可用连接符拼接多个单词;&lt;/li&gt;
&lt;li&gt;长度尽量限制在 8~16 字符之间;&lt;/li&gt;
&lt;li&gt;尽量采用具有明确意义的英文单词，而不建议采用汉字的拼音字母或者拼音首字母组合;&lt;/li&gt;
&lt;li&gt;无需以 &lt;code&gt;TABLE&lt;/code&gt; 结尾;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示例-1&#34;&gt;示例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;USER_INFO
WEIBO_USER_FANS
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;行键-rowkey&#34;&gt;行键 (Rowkey)&lt;/h2&gt;
&lt;h3 id=&#34;命名规范-2&#34;&gt;命名规范&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;采用英文单词、阿拉伯数字、非转义字符组合形式，不要求大小写，但首字符必须是英文字符或数字;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示例-2&#34;&gt;示例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;123456-654321
dftf3a3l3rv3qr
s.taobo.com/faefavc
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注意&#34;&gt;注意&lt;/h3&gt;
&lt;h4 id=&#34;慎重将时间戳直接放入行键中&#34;&gt;慎重将时间戳直接放入行键中&lt;/h4&gt;
&lt;p&gt;对于同一条数据，HBase 本身提供时间戳 (TimeStamp) 以在同一个 RowKey 下保存不同版本数据;
对于整体，存放旧数据的区域随着时间戳增大可能不再写入，而存放新数据的区域始终保持高负荷，这样降低了 HBase 整体的读写能力。&lt;/p&gt;
&lt;p&gt;一个推荐的方式是使用反向时间戳。&lt;/p&gt;
&lt;h4 id=&#34;权衡-hash-和-string-的效果&#34;&gt;权衡 hash 和 string 的效果&lt;/h4&gt;
&lt;p&gt;哈希化 (一般特指单项哈希) 的 Rowkey 能很好的避免热点问题，但是也会同时丢失直接使用 String 的 RowKey 的天然聚类和排序的能力。&lt;/p&gt;
&lt;h2 id=&#34;列族-columnfamily&#34;&gt;列族 (ColumnFamily)&lt;/h2&gt;
&lt;h3 id=&#34;命名规范-3&#34;&gt;命名规范&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;采用英文单词、阿拉伯数字的组合形式，其中，单词必须大写，并且首字符必须为英文字符，不能是数字;&lt;/li&gt;
&lt;li&gt;长度尽量限制在 1~6 字符之间，过长的列族名称将占用更多的存储空间, 它们不应该像在典型的 RDBMS 中一样具有自我记录和描述性;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示例-3&#34;&gt;示例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;DATA
D1 # data1
WA # web args
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注意-1&#34;&gt;注意&lt;/h3&gt;
&lt;h4 id=&#34;列族的数量应控制在-1-3-个&#34;&gt;列族的数量应控制在 1-3 个&lt;/h4&gt;
&lt;p&gt;HBase 表不应该被设计成模拟 RDBMS 表，列族的数量在满足需求的情况下应该尽可能少。在存储时，一个列族会存储成一个 StoreFile，多个列族对应的多个文件在分裂时会对服务器造成更大的压力。&lt;/p&gt;
&lt;h2 id=&#34;列-qualifier&#34;&gt;列 (Qualifier)&lt;/h2&gt;
&lt;h3 id=&#34;命名规范-4&#34;&gt;命名规范&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;采用英文单词、阿拉伯数字、连接符（_）的组合形式，其中，单词必须 ** 小写 **，并且首字符必须为英文字符，不能是数字，可用连接符拼接多个单词;&lt;/li&gt;
&lt;li&gt;所有列名都应该是名词或者以 &lt;code&gt;is&lt;/code&gt; 开头的动宾短语 (表示判断)，不应该使用其他词性单词;&lt;/li&gt;
&lt;li&gt;允许使用前缀，不允许使用后缀;&lt;/li&gt;
&lt;li&gt;长度尽量限制在 1~16 字符之间;&lt;/li&gt;
&lt;li&gt;尽量采用具有明确意义的英文单词，而不建议采用汉字的拼音字母或者拼音首字母组合;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示例-4&#34;&gt;示例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;user_name
is_str
sound_type
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Palantir 一分钟印象</title>
      <link>https://szthanatos.github.io/post/palantir_intro/</link>
      <pubDate>Wed, 05 Dec 2018 17:09:21 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/palantir_intro/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Palantir 是全球第一大 &lt;code&gt;大数据公司&lt;/code&gt;。曾经的全球四大独角兽之一（其它三家是 Uber，Airbnb 和小米）。中文名帕兰提尔，源于《指环王》中邪恶巫师萨鲁曼使用的可穿越时空、洞悉世间一切的水晶球 (Palantiri)。主要客户为政府机构和金融机构。&lt;/p&gt;
&lt;p&gt;最出名的案例是以大数据技术帮助美国军方成功定位和击毙基地组织首脑本 · 拉登，以及协助多家银行追回了纳斯达克前主席麦道夫 Bernie Madoff 的庞氏骗局中所隐藏起来的数十亿美元巨款。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;最新情况&#34;&gt;最新情况&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2018 年 10 月 29 日&lt;/strong&gt;，Palantir 正在建立 ICE 的案例管理软件 —— &lt;a href=&#34;http://aldianews.com/articles/politics/immigration/technology-companies-are-ices-dark-allies/54287&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AL DIA News&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2018 年 10 月 23 日&lt;/strong&gt;，亚马逊、微软、Palantir 等科技公司在特朗普的移民法案中起到重要作用 —— &lt;a href=&#34;https://www.commondreams.org/news/2018/10/23/amazon-microsoft-and-palantir-among-tech-giants-making-huge-profits-trumps&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Common Dreams&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2018 年 10 月 19 日&lt;/strong&gt;，Palantir 或明年上市，估值达 410 亿美元 —— &lt;a href=&#34;https://www.vanityfair.com/news/2018/10/palantir-peter-thiels-all-seeing-eye-looks-to-a-41-billion-dollar-ipo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MAYA KOSOFF&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2018 年 09 月 14 日&lt;/strong&gt;，美国陆军决议中止对 Palantir2.06 亿美元的采购合同 —— &lt;a href=&#34;https://www.law360.com/articles/1082813/army-wrongly-ignored-palantir-in-206m-deal-fed-circ-says&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LAW 360&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2018 年 03 月 14 日&lt;/strong&gt;，雷神、Palantir 拿下美国陆军 8.76 亿美元合同 —— &lt;a href=&#34;https://www.reuters.com/article/us-raytheon-pentagon/raytheon-palantir-win-876-million-u-s-defense-contract-pentagon-idUSKCN1GL2HR&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;reuters&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2018 年 03 月 02 日&lt;/strong&gt;，传 Palantir 在新奥尔良秘密测试犯罪预测技术，最神秘的独角兽再陷隐私风波 —— &lt;a href=&#34;https://www.lieyunwang.com/archives/416481&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;猎云网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Palantir 发布 &lt;a href=&#34;https://www.palantir.com/philanthropy-engineering/annual-report/2017/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2017 年度报告&lt;/a&gt; 重点提到在哈维飓风的救援以及灾后重建工作，以及帮助世界粮食计划署运输食品以对抗饥饿的工作中所起到的作用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;创始人&#34;&gt;创始人&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Peter Thiel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;斯坦福本科及法学院 JD 的高材生，《从 0 到 1》的作者。创立了 Clarium Capital、Founders Fund、Valar Ventures、、Mithril Capital Management 等多支基金。Paypal 创始人之一并出任 CEO。2002 年 paypal 被收购之后，以投资人身份投资包括 Facebook、Asana、Quora、LinkedIn、Yelp、Yammer 在内的诸多当今一线公司。号称硅谷创投教父。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Alex Karp&lt;/strong&gt; (CEO)&lt;/p&gt;
&lt;p&gt;哈佛本科毕业，斯坦福法学 JD 学位，德国法兰克福大学新古典社会理论方向博士学位，师从本世纪最伟大的哲学家之一哈贝马斯。早年继承家产后成为硅谷著名投资人，并在伦敦创立 Caedmon Group 基金管理投资。目前坚持保持单身，热爱气功、游泳以及与员工讲马克思还有带领员工在硅谷打太极。Peter Thiel 在斯坦福的室友。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Joe Lonsdale&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;斯坦福计算机系毕业。除 Palantir 外，还曾创办另外两家高科技公司，和硅谷最大的面向亚洲的风投基金 Formation8、 8vc。管理着 5000 亿美元财富。此外，还是《福布斯》评选出的 12 位行业未来之星之一，还被美国媒体评为硅谷排名第二的天使投资人。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Stephen Cohen&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;毕业于斯坦福计算机系的高级工程师。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Nathan Gettings&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来自于 PayPal 的的高级工程师。在 PayPal 负责风险和研发的总监，曾以开发了反欺诈的系统而闻名于世。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;发展历程&#34;&gt;发展历程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2004 年 Palantir 公司创立于加利福尼亚州帕洛阿尔托。创业初期 Palantir 并不被人看好，融资过程也是屡屡受阻，包括红杉资本，凯鹏华盈两大 VC 基金都不看好 Palantir 的发展。经过多次奔走博弈，最终，Palantir 赢得了 CIA 的创投基金的 2 轮投资，从而走上了发展的正轨。&lt;/li&gt;
&lt;li&gt;2004 到 2009 年，Palantir 主要业务还是服务于美国政府部门，提供情报分析，防欺诈、反恐等服务。&lt;/li&gt;
&lt;li&gt;2010 年，Palantir 开始提供企业服务，实现业务多元化。&lt;/li&gt;
&lt;li&gt;2010 年 7 月，当时已经拥有 250 位工程师的 Palantir 完成 9000 万美元的 D 轮融资，估值达到 7.35 亿美元。&lt;/li&gt;
&lt;li&gt;2011 年 5 月 6 日，融资 5000 万美元，累计融资额达到了 1.75 亿美元。&lt;/li&gt;
&lt;li&gt;2011 年 10 月 7 日，融资 7000 万美元，估值 25 亿美元。&lt;/li&gt;
&lt;li&gt;2013 年 9 月 29 日，融资 1.96 亿美元，估值 60 亿美元。&lt;/li&gt;
&lt;li&gt;2013 年 12 月，Palantir 新一轮融资 1.075 亿美元，同时估值达到 90 亿美元。此时 Palantir 的年收入已经超过 4.5 亿美元。&lt;/li&gt;
&lt;li&gt;2014 年 11 月，Palantir 再拿到 5 亿美元投资，企业用户突破 14000 家，估值达到了 150 亿美元。&lt;/li&gt;
&lt;li&gt;2015 年年底，Palantir 获得 8.8 亿美元的融资，市值达到 200 亿美元。成为继 Uber、小米、Airbnb 之后，全球估值第四高的创业公司。（截至 2018 年 11 月最后一笔融资）&lt;/li&gt;
&lt;li&gt;2016 年 2 月，收购 Kimono Labs&lt;/li&gt;
&lt;li&gt;2016 年 5 月，Buzzfeed 爆料, 数司百名员工离职，多个重要客户不再续约。&lt;/li&gt;
&lt;li&gt;2016 年 8 月，Palantir 收购数据可视化公司 Silk。&lt;/li&gt;
&lt;li&gt;2018 年 10 月，Palantir 预备明年下半年上市，公司估值或将达 410 亿美元&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;产品内容&#34;&gt;产品内容&lt;/h2&gt;
&lt;h3 id=&#34;官方主页-home--palantirhttpswwwpalantircom&#34;&gt;官方主页： &lt;a href=&#34;https://www.palantir.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Home | Palantir&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;产品线&#34;&gt;产品线&lt;/h3&gt;
&lt;p&gt;目前 Palantir 仅保留两条产品线：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/palantir-gotham/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Palantir Gotham&lt;/a&gt;&lt;/strong&gt; 一个集成，管理，保护和分析多来源的企业数据的复合平台。命名来源于蝙蝠侠所在的哥谭市。作为后端，Gotham 平台可用于集成许多不同的数据源，以进行安全的协作分析；也可以存储企业的各类建模分析数据，充当企业知识库。而在前端, Gotham 平台提供了一套针对语义，时间，地理空间和全文分析的分析工具集合。为 Gotham 提供支撑的子产品包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PHOENIX&lt;/strong&gt; 支持 PB 级的数万亿条记录进行亚秒级查询的集群数据库；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RAPTOR&lt;/strong&gt; 提供对外部数据源进行联合查询, 并实时加入数据库的检索工具；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SEARCH&lt;/strong&gt; 提供对系统中结构化和非结构化数据的全文检索的搜索引擎；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HORIZON&lt;/strong&gt; 允许用户在数十亿个对象中查询并在约 10 秒内收到结果的, 类 Spark 设计的内存数据库；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DYNAMIC ONTOLOGY&lt;/strong&gt; 高度灵活和动态的数据建模工具；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;REVISIONING DATABASE&lt;/strong&gt; RevDB 是 Gotham 平台的持久化数据管理工具，类似 Zookeeper 之于 Hadoop；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ATLASDB&lt;/strong&gt; 作为 RevDB 的具体数据存储单元，结合了 NoSQL 数据存储的简单性和可扩展性与传统 SQL 数据库的事务安全性和一致性；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NEXUS PEERING&lt;/strong&gt; 分布式系统平台，上面的各个组件都建立在这个平台之上；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/palantir-foundry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Palantir Foundry&lt;/a&gt;&lt;/strong&gt; ：数据集成 / 分析平台，将后端的数据存储和前端的数据分析打通，让任何人都能连接到不同数据源轻松进行建模分析。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解决方案&#34;&gt;解决方案&lt;/h3&gt;
&lt;p&gt;Palantir 面向以下领域直接提供解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/automotive&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;汽车制造业&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/cyber/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;网络安全&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/financial-compliance/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;金融合规&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/insider-threat/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;企业内部信息安全&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/intelligence/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;商业情报分析&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/legal-intelligence/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;法律诉讼&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/mergers-and-acquisitions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;并购支持&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/revenue-maximization/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;收入最大化&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/case-management/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数据组织&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/defense/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;国土防卫&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/gdpr/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;欧盟通用数据保护监管&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/insurance-analytics&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;保险分析&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/law-enforcement/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公共执法&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/manufacturing/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;制造业&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/pharma/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;医药研发&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.palantir.com/solutions/skywise&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;航空业&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 安装最新版本 Python</title>
      <link>https://szthanatos.github.io/post/python/python_install_on_ubuntu/</link>
      <pubDate>Sat, 01 Dec 2018 15:59:04 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/python/python_install_on_ubuntu/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;添加 ppa 源：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 死蛇的源
sudo add-apt-repository ppa:deadsnakes/ppa
# 或者，jonathonf 的源
sudo add-apt-repository ppa:jonathonf/python-3.x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果提示没有 add-apt-repository 的话执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt install software-properties-common
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新源并安装 python3.x，&lt;code&gt;3.x&lt;/code&gt; 以你要安装的版本号为准：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt update
sudo apt install python3.x
# 可选
sudo apt install python3.x-dev
sudo apt install python3.x-venv
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装 pip:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://bootstrap.pypa.io/get-pip.py
sudo python3.x get-pip.py
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 python 和 pip 版本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 也可以用 - V
python --version
python3 --version
pip --version
pip3 --version
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果关联版本不正确，备份 usr/bin 的软链接，重建软链接：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 设置默认 python3 对应 python 版本
sudo ln -s /usr/bin/python3.x /usr/bin/python3
# 设置默认 pip3 使用 pip 版本
sudo ln -s /usr/local/bin/pip3.x /usr/bin/pip3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意 python 默认安装位置在 &lt;code&gt;/usr/bin&lt;/code&gt; 下，pip 默认安装位置在 &lt;code&gt;/usr/local/bin&lt;/code&gt; 下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pip 初始化设置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir ~/.pip
touch ~/.pip/pip.conf
# python3.6/pip18 之后无需配置这个
echo [list]&amp;gt;&amp;gt;~/.pip/pip.conf
echo format=columns&amp;gt;&amp;gt;~/.pip/pip.conf
# 设置默认 pip 源为清华大学开源镜像
echo [global]&amp;gt;&amp;gt;~/.pip/pip.conf
echo index-url = https://pypi.tuna.tsinghua.edu.cn/simple&amp;gt;&amp;gt;~/.pip/pip.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(可选) 一键升级所有过期的包：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo pip freeze --local | grep -v &#39;^\-e&#39; | cut -d = -f 1  | xargs pip install -U
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>欢迎来到氪石实验室</title>
      <link>https://szthanatos.github.io/post/0x00/</link>
      <pubDate>Sat, 01 Dec 2018 12:00:24 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/0x00/</guid>
      <description>&lt;p&gt;这是我第四次，也可能是我最后一次博客迁移 (flag 已立←_←)。&lt;/p&gt;
&lt;p&gt;从大学时代开始，找个地方写点什么的蠢动心思就没消停过，但是也都消磨在了无关文字的地方。有一个 Geek 圈子的说法，&lt;code&gt;yak-shaving&lt;/code&gt;，剪牦牛毛，放我身上非常合适——本来只是想写点什么，却发现不知道写哪好，就开始研究市面上的博客服务，又发现都不太好用不如自己搭，又开始研究自建网站，自建网站的过程中又发现自己需要一个服务器，又开始折腾主机&amp;hellip; 折腾个人域名&amp;hellip; 折腾 Linux&amp;hellip; 折腾 LAMP 环境&amp;hellip;——总之折腾到最后，走马观花的东西很多，写出来的东西寥寥无几。&lt;/p&gt;
&lt;p&gt;yak-shaving 的得失不提，到了现在的这个阶段，折腾的心思已经熄了很多，但是已经写出来的东西零零散散还是会难以忍受。也有一部分内容已经过时，或者回头再看理解已经完全不同&amp;hellip; 总而言之，借此机会，旧的内容安置妥当，咱们就此别过。未来的文章，短时间内也无虞搬迁之苦，踏踏实实的呆在实验室档案柜吧。&lt;/p&gt;
&lt;p&gt;以后笔记只分两部分存储：未经整理的内容继续保存在 OneNote 里，相对完整的东西再放到这里来。&lt;/p&gt;
&lt;p&gt;旧的博客文章大概 200 篇不到，但是想到要挨个过一遍还得翻新到 Hugo 的模板&amp;hellip;.. 就感觉&amp;hellip;&amp;hellip; 啊，还是鸽了吧&amp;hellip;&amp;hellip;（不过自己立的 flag 哭着也要做完的）&lt;/p&gt;
&lt;p&gt;说回个人博客。&lt;/p&gt;
&lt;p&gt;上一个博客的灵感是万智牌 &lt;font color=#F8F8FF&gt;（和长者）&lt;/font&gt;，为自己设定的身份是掌握了东方神秘膜法的旅法师&amp;hellip; 所以取名叫做 &amp;ldquo;黑膜法师营地&amp;rdquo;，不过旅法师对决之后也已经好久没玩了。&lt;/p&gt;
&lt;p&gt;至于现在博客的设定，起源于最近重温 &lt;a href=&#34;https://www.bilibili.com/bangumi/play/ep257474/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;守望者&lt;/a&gt;。看到罗夏(罗夏帅爆!) 就想到老爷，看到笑匠就想到小丑(罗夏：致命玩笑←_←)，看到法老王&amp;hellip; 唔&amp;hellip; 蝙蝠侠对抗的智商爆表而且 ** 精神正常 ** 的反派&amp;hellip; 阿卡姆疯人院:&amp;ldquo;外面的都是神经病啊，不要放进来！&amp;quot;。&lt;/p&gt;
&lt;p&gt;脑洞扩展到 DCEU，嗯，超人，嗯，卢瑟，嗯，巴别塔&amp;hellip; 老爷不会只靠定情小氪石的，一定有后备方案，嗯，Lex Wayne，就这么定了。&lt;/p&gt;
&lt;p&gt;顺理成章，细节设定就是严肃的考 (wan) 证(geng)啦。&lt;/p&gt;
&lt;h2 id=&#34;kryptonite-lab&#34;&gt;Kryptonite Lab&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2021/06/17/TDOlof7tyQxKbp1.jpg&#34; alt=&#34;kryptonite&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;氪石实验室，没什么好说的，名字都是 Lex Wayne 了肯定患有氪石狂热啦 (雾！)，什么住在全是氪石的实验室啦，爱嚼氪石口香糖啦，肯定都是基本设定啦 (大雾！)。&lt;/p&gt;
&lt;p&gt;42 这个倒和 DCEU 没关——《银河系漫游指南》里宇宙的终极答案啊！十六进制的 ASCII 码 &lt;code&gt;*&lt;/code&gt;，&lt;code&gt;&#39;the&lt;/code&gt;&lt;strong&gt;&lt;code&gt;Answer&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;to&lt;/code&gt;&lt;strong&gt;&lt;code&gt;Life&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;the&lt;/code&gt;&lt;strong&gt;&lt;code&gt;Universe&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;and&lt;/code&gt;&lt;strong&gt;&lt;code&gt;Everything&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;is&#39;&lt;/code&gt; 问题本身的长度，感觉没有更赞的了 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。已经想好了，如果以后完善 Lab 的设定，里面的超算肯定叫深思 (Deep Thought)。&lt;/p&gt;
&lt;h2 id=&#34;wayne-manor-b3-1007-mountain-drive-gotham-nj-12345-usa&#34;&gt;Wayne Manor B3, 1007 Mountain Drive, Gotham, NJ 12345, USA&lt;/h2&gt;
&lt;p&gt;一段一段说，&lt;/p&gt;
&lt;h3 id=&#34;wayne-manor-b3&#34;&gt;Wayne Manor B3&lt;/h3&gt;
&lt;p&gt;地下三层取自这个蝙蝠洞的设计图：















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2021/06/17/3i6fd9STZNXqAhu.jpg&#34; alt=&#34;蝙蝠洞设计图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;放大可以看到地下从上往下数分别是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-1 &lt;code&gt;Main Level&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;-2 &lt;code&gt;Additional Hangar Aeras&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;-3 &lt;code&gt;Sub Level 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Sub Level 1&lt;/code&gt; 放的就是 &lt;code&gt;Labs/Workshops/Library&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1007-mountain-drive-gotham&#34;&gt;1007 Mountain Drive, Gotham&lt;/h3&gt;
&lt;p&gt;韦恩庄园所在的 &lt;code&gt;1007 Mountain Drive&lt;/code&gt; 这个地址来源于 92-95 年的蝙蝠侠动画 &lt;code&gt;Batman: The Animated Series&lt;/code&gt; 第一季中的 &lt;code&gt;The Demon&#39;s Quest&lt;/code&gt; 故事，应该也是目前蝙蝠侠相关作品中唯一正面出现的庄园地址。&lt;/p&gt;
&lt;p&gt;具体坐落在哥谭的什么位置可以参考 1999 年 Eliot R. Brown 制作的地图：















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2021/06/17/qjvyNKJxVUimHLM.jpg&#34; alt=&#34;Eliot R. Brown 版本&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;而更新一点的设定可以参考诺兰的黑暗骑士的周边 &lt;a href=&#34;https://www.amazon.com/The-Dark-Knight-Manual-Documents/dp/1608871045?tag=thehuffingtop-20&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《黑暗骑士手册》&lt;/a&gt;：















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2021/06/17/rhy2FbWPexic7Cu.jpg&#34; alt=&#34;Nolan 版本&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;总之，都在右上角啦←_←。&lt;/p&gt;
&lt;h3 id=&#34;nj-12345-usa&#34;&gt;NJ 12345, USA&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;NJ&lt;/code&gt; 是新泽西的缩写，虽然哥谭给人的印象就是纽约（早于黑暗骑士的电影给人的感觉可能更像芝加哥），但新泽西的设定可以追溯到 1974 年的 DC 漫画惊奇世界 (详见维基)，















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2021/06/17/Q5Lcuzx4iKaXs3y.jpg&#34; alt=&#34;哥谭位置&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

&lt;code&gt;NJ 12345&lt;/code&gt; 也是出自 93 年的 &lt;code&gt;Batman: Shadow of the Bat&lt;/code&gt; 里的那个驾驶证：&lt;code&gt;72 Faxcol Dr Gotham City, NJ 12345&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;其他彩蛋&#34;&gt;其他彩蛋&lt;/h3&gt;
&lt;p&gt;其他的设定零零碎碎的，以后也会往里面填充更多内容啦。&lt;/p&gt;
&lt;h4 id=&#34;star-war&#34;&gt;Star War&lt;/h4&gt;
&lt;p&gt;比如我个人介绍的 &lt;code&gt;Python Knight &amp;amp; Go Padawan&lt;/code&gt;，这里的 &lt;code&gt;Knight&lt;/code&gt; 显然和黑暗骑士什么的无关——Jedi！星战好像已经是老年人爱好了&amp;hellip; 但当年真的迷过一段时间，桌面都是拿星战的设定集原画做的&amp;hellip;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2021/06/17/eOlKCZAjxnLm16b.jpg&#34; alt=&#34;wheel bike&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;另一方面是一时想不到 DCEU 里面和等级相关的设定了&amp;hellip; 星战就很明确啊，
&lt;code&gt;youngling&lt;/code&gt; 是幼徒，&lt;code&gt;Padawan&lt;/code&gt; 是学徒，&lt;code&gt;Knight&lt;/code&gt; 是武士，&lt;code&gt;Master&lt;/code&gt; 是大师，简单明了~&lt;/p&gt;
&lt;p&gt;再有就是，&lt;code&gt;Kryptonitesaber&lt;/code&gt; 什么的想想就很带感啊&amp;hellip; 以后绝对要补充这方面设定的！&lt;/p&gt;
&lt;p&gt;嗯&amp;hellip; 上面都是写给自己看的，&lt;/p&gt;
&lt;h1 id=&#34;陌生人p-欢迎翻阅氪石实验室-42-号档案柜&#34;&gt;陌生人，&lt;p&gt; 欢迎翻阅氪石实验室 42 号档案柜。&lt;/h1&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;《蜘蛛侠: 平行宇宙》也是 42 的梗，大家真的是很爱 42 啊&amp;hellip;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>python 单元测试标准及实现</title>
      <link>https://szthanatos.github.io/post/python/unit_testing/</link>
      <pubDate>Mon, 20 Aug 2018 10:49:50 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/python/unit_testing/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    这是写给我组里的人看的，顺手粘过来
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;什么是单元测试&#34;&gt;什么是单元测试&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;单元测试 (Unit Testing) 又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一句话概括，单元测试也就是校验代码中具体的类 (甚至函数) 的输出值是否符合预期。&lt;/p&gt;
&lt;h2 id=&#34;为什么要写单元测试&#34;&gt;为什么要写单元测试&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;“可能出错的事情最终一定会出错”&lt;/p&gt;
&lt;p&gt;——墨菲定律&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码随着时间的累计而增长，出现意想不到的问题的可能性也在指数级上升。代码的正确与否不应该靠人来保证，因为人是会犯错并且一定犯错的。如果每次新功能上线时不能回答 “所有功能都测试过了么” 的问题，那么最终整个项目的可靠性都将被摧毁。单元测试的意义就在于让你能够回答这个问题，并且，回答的更自动化。&lt;/p&gt;
&lt;h2 id=&#34;怎么写单元测试&#34;&gt;怎么写单元测试&lt;/h2&gt;
&lt;h3 id=&#34;原生测试框架-unittestunittest2&#34;&gt;原生测试框架 unittest/unittest2&lt;/h3&gt;
&lt;p&gt;在 python 语境中，官方提供 unittest 标准库完成单元测试。&lt;/p&gt;
&lt;h4 id=&#34;基础&#34;&gt;基础&lt;/h4&gt;
&lt;p&gt;需要理解的概念有如下四个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;test fixture&lt;/code&gt;：单元测试所需上下文环境，比如临时数据库 / 网络连接等；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test case&lt;/code&gt;：一个独立的单元测试最小单位；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test suite&lt;/code&gt;：test case 的集合；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test runner&lt;/code&gt;：执行并输出单元测试的程序；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细定义请自行查阅 &lt;a href=&#34;https://docs.python.org/3/library/unittest.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官网文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;官方单元测试用例如下，我们对 upper(将 string 转换为大写)、isupper(判断 string 是否全部为大写)、split(对 string 按空格切分为 list) 函数的功能进行校验&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import unittest

class TestStringMethods(unittest.TestCase):

    def test_upper(self):
        self.assertEqual(&#39;foo&#39;.upper(), &#39;FOO&#39;)

    def test_isupper(self):
        self.assertTrue(&#39;FOO&#39;.isupper())
        self.assertFalse(&#39;Foo&#39;.isupper())

    def test_split(self):
        s = &#39;hello world&#39;
        self.assertEqual(s.split(), [&#39;hello&#39;, &#39;world&#39;])
        # check that s.split fails when the separator is not a string
        with self.assertRaises(TypeError):
            s.split(2)

if __name__ == &#39;__main__&#39;:
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;断言&#34;&gt;断言&lt;/h4&gt;
&lt;p&gt;可以从上面的例子看出，单元测试判断结果是否符合预期的主要方式是通过断言 (assert)  实现。
以下是常见断言：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Checks that&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;assertEqual(a, b)&lt;/td&gt;
&lt;td&gt;a == b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertNotEqual(a, b)&lt;/td&gt;
&lt;td&gt;a != b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertGreater(a, b)&lt;/td&gt;
&lt;td&gt;a &amp;gt; b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertGreaterEqual(a, b)&lt;/td&gt;
&lt;td&gt;a &amp;gt;= b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertLess(a, b)&lt;/td&gt;
&lt;td&gt;a &amp;lt; b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertLessEqual(a, b)&lt;/td&gt;
&lt;td&gt;a &amp;lt;= b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertAlmostEqual(a, b)&lt;/td&gt;
&lt;td&gt;round(a-b, 7) == 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertNotAlmostEqual(a, b)&lt;/td&gt;
&lt;td&gt;round(a-b, 7) != 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertRegex(s, r)&lt;/td&gt;
&lt;td&gt;r.search(s)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertNotRegex(s, r)&lt;/td&gt;
&lt;td&gt;not r.search(s)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertTrue(x)&lt;/td&gt;
&lt;td&gt;bool(x) is True&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertFalse(x)&lt;/td&gt;
&lt;td&gt;bool(x) is False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertIs(a, b)&lt;/td&gt;
&lt;td&gt;a is b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertIsNot(a, b)&lt;/td&gt;
&lt;td&gt;a is not b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertIsNone(x)&lt;/td&gt;
&lt;td&gt;x is None&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertIsNotNone(x)&lt;/td&gt;
&lt;td&gt;x is not None&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertIn(a, b)&lt;/td&gt;
&lt;td&gt;a in b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertNotIn(a, b)&lt;/td&gt;
&lt;td&gt;a not in b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertIsInstance(a, b)&lt;/td&gt;
&lt;td&gt;isinstance(a, b)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assertNotIsInstance(a, b)&lt;/td&gt;
&lt;td&gt;not isinstance(a, b)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;setup-和-teardown&#34;&gt;setUp 和 tearDown&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;test fixture&lt;/code&gt; 是通过 &lt;code&gt;setUp&lt;/code&gt; 和 &lt;code&gt;tearDown&lt;/code&gt; 来具体实现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;setUp() 方法&lt;/strong&gt;：
在执行每个测试用例 (test case) 之前被执行，除了 unittest.SkipTest 和 AssertionError 以外的任何异常都会当做是 error 并终止当前测试用例；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tearDown() 方法&lt;/strong&gt;：
执行了 setUp()方法后，执行 tearDown()方法 (进行清理)。对异常的处理和 setUp() 类似；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;setUpClass(cls) 与 tearDownClass(cls) 类&lt;/strong&gt;：
可以将 setUp 和 tearDown 定义在基类中避免重复定义，定义 setUpClass(cls) 与 tearDownClass(cls) 类时必须加上 classmethod 装饰符；&lt;/p&gt;
&lt;p&gt;对上面的例子进行简单的改造以演示 setUp 和 tearDown 的效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import unittest

class TestStringMethods(unittest.TestCase):

    def setUp(self):
        print &#39;1. setUp here&#39;

    def tearDown(self):
        print &#39;2. tearDown here&#39;

    def test_upper(self):
        self.assertEqual(&#39;foo&#39;.upper(), &#39;FOO&#39;)

    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行后效果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;test_isupper (mytest.TestStringMethods) ... 1. setUp here
1. tearDown here
ok
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;缺点&#34;&gt;缺点&lt;/h4&gt;
&lt;p&gt;基本的一个单元测试可以用这四步概括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新建单元测试脚本&lt;/li&gt;
&lt;li&gt;导入单元测试依赖&lt;/li&gt;
&lt;li&gt;继承单元测试类&lt;/li&gt;
&lt;li&gt;实现单元测试方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而这个过程非常不 pythonic：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须新建单独的测试文件&lt;/li&gt;
&lt;li&gt;测试必须继承自 unittest 类，即使再简单的测试&lt;/li&gt;
&lt;li&gt;断言只能使用 unittest 的 Assertion&lt;/li&gt;
&lt;li&gt;最最关键和难以忍受的：unitunit 内的命名规则和 pep 8 相悖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;造成这些问题的原因一言以蔽之：python 的测试框架是完全仿照 Java 实现的。&lt;/p&gt;
&lt;h3 id=&#34;第三方测试框架-pytest&#34;&gt;第三方测试框架 py.test&lt;/h3&gt;
&lt;p&gt;实际上，通过使用 py.test，我们可以非常 pythonic 的实现单元测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# content of test_sample.py
def inc(x):
    return x + 1


def test_answer():
    assert inc(3) == 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接在测试文件所在目录执行 py.test 得到如下结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-3.x.y, py-1.x.y, pluggy-0.x.y
rootdir: $REGENDOC_TMPDIR, inifile:
collected 1 item

test_sample.py F                                                     [100%]

================================= FAILURES =================================
_______________________________ test_answer ________________________________

    def test_answer():
&amp;gt;       assert inc(3) == 5
E       assert 4 == 5
E        +  where 4 = inc(3)

test_sample.py:6: AssertionError
========================= 1 failed in 0.12 seconds =========================
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就是这么简单，更进一步的，py.test 支持自动生成对指定目录下所有测试文件的统一测试脚本，更具体的用法参见 &lt;a href=&#34;https://docs.pytest.org/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pytest 文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总的来说，py.test 具有如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非常容易上手，入门简单，文档丰富，文档中有很多实例可以参考&lt;/li&gt;
&lt;li&gt;能够支持简单的单元测试和复杂的功能测试&lt;/li&gt;
&lt;li&gt;支持参数化&lt;/li&gt;
&lt;li&gt;执行测试过程中可以将某些测试跳过，或者对某些预期失败的 case 标记成失败&lt;/li&gt;
&lt;li&gt;支持重复执行失败的 case&lt;/li&gt;
&lt;li&gt;支持运行由 nose , unittest 编写的测试 case&lt;/li&gt;
&lt;li&gt;具有很多第三方插件，并且可以自定义扩展&lt;/li&gt;
&lt;li&gt;方便的和持续集成工具集成&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;单元测试标准&#34;&gt;单元测试标准&lt;/h2&gt;
&lt;p&gt;业界通常使用代码覆盖 (率) 来评判测试的好坏。&lt;/p&gt;
&lt;h3 id=&#34;代码覆盖指标&#34;&gt;代码覆盖指标&lt;/h3&gt;
&lt;p&gt;单独的一两个测试完全无法体现测试的优势。而对所有可能的情况编写单元测试既不现实也无必要。所以明确测试覆盖哪些指标非常重要。&lt;strong&gt;我们在此指定以下四个指标必须被覆盖：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数覆盖（Function Coverage）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每一个函数都必须被测试；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;语句覆盖（Statement Coverage）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;被测代码中每个可执行语句都应该被执行测试。例如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def foo(x:int, y:int):
    z = 0
    if x&amp;gt;0 and y &amp;gt;0:
        z = x
    return z
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;中，如果测试为 assertEqualst(0, foo(2,-1))，则 if 内的代码就没有被覆盖到；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;决策覆盖（Decision Coverage）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指每一个逻辑分支都应该被测试覆盖。类似上面的例子，如果想要达到决策覆盖，我们起码应该执行两次测试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;assertEquals(2, foo(2, 2))  # 决策 1&lt;/li&gt;
&lt;li&gt;assertEqualst(0, foo(2,-1))  # 决策 2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;条件覆盖（Condition Coverage）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每一个逻辑分支的每一个条件都应该被覆盖。条件覆盖不需要满足条件表达式所有的排列组合，而只需将每个条件表达式的结果为 true/false 的情况进行测试就可以了。依旧使用上面的例子，如果想要达到条件覆盖，我们应该执行至少三次测试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;assertEquals(2, foo(2, 2))  # 决策 1 条件 true&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;assertEqualst(0, foo(2,-1))  # 决策 2(没有条件)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;assertEquals(0, foo(-1, -1))  # 决策 1 条件 false&lt;/p&gt;
&lt;p&gt;如果没有第三个测试，那么只能达到决策覆盖，不能达到条件覆盖。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;代码覆盖率&#34;&gt;代码覆盖率&lt;/h3&gt;
&lt;p&gt;在满足代码覆盖指标的基础上，只有保证一定的代码覆盖率才能保证测试的完整。满足代码覆盖指标相当于是 “质”，而代码覆盖率则是保证 “量”。&lt;strong&gt;目前要求代码覆盖率不应该低于 75%&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们选定 &lt;a href=&#34;https://pypi.org/project/coverage/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;coverage.py&lt;/a&gt; 来统计代码覆盖率。由于主要使用 py.test，需要额外安装 &lt;a href=&#34;https://github.com/pytest-dev/pytest-cov&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pytest-cov&lt;/a&gt; 插件。安装过程非常简单，对照文档直接 pip 安装即可，不多介绍。&lt;/p&gt;
&lt;p&gt;完成安装后，使用 py.test 的时候增加 &amp;ndash;cov=myproj 参数即可。
效果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;-------------------- coverage: ... ---------------------
Name                 Stmts   Miss  Cover
----------------------------------------
myproj/__init__          2      0   100%
myproj/myproj          257     13    94%
myproj/feature4286      94      7    92%
----------------------------------------
TOTAL                  353     20    94%
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;详细用法可参照 &lt;a href=&#34;http://pytest-cov.readthedocs.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;总结一下，通过对单元测试的必要性、编写方法、评判标准等一系列的介绍，确立了以下三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 py.test+unittest 编写单元测试，使用 coverage 统计、分析单元测试编写情况；&lt;/li&gt;
&lt;li&gt;单元测试应覆盖最基本的四项指标 (函数覆盖、语句覆盖、分支覆盖、条件覆盖)；&lt;/li&gt;
&lt;li&gt;在覆盖基本指标的基础上，需要达到 75% 的代码覆盖率；&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>可序列化类型和多进程 PicklingError</title>
      <link>https://szthanatos.github.io/post/python/pickled/</link>
      <pubDate>Tue, 20 Mar 2018 16:16:15 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/python/pickled/</guid>
      <description>&lt;p&gt;遇到一个报错：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;PicklingError: Can&#39;t pickle &amp;lt;type&#39;instancemethod&#39;&amp;gt;: attribute lookup __builtin__.instancemethod failed&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当时的情况是想写一个多进程的解析代码，爬虫爬到的内容给扔过来就不管了，差不多这个意思：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# !/usr/bin/env python
# -*- coding: utf-8 -*-

from concurrent.futures import ProcessPoolExecutor


class PageProcess(object):
    def __init__(self, worker):
        self.max_worker = worker

    def single_process(self, page):
        pass

    def multi_process(self, page_list):
        with ProcessPoolExecutor(max_workers=self.max_worker) as pp:
            result = pp.map(self.single_process, page_list)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个错误是这么造成的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在类中使用进程池；&lt;/li&gt;
&lt;li&gt;进程池使用 &lt;code&gt;Queue&lt;/code&gt; 管理任务队列；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Queue&lt;/code&gt; 要求传递的内容必须都是可以被序列化的；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么问题来了，哪些类型是可以被序列化的呢？&lt;/p&gt;
&lt;p&gt;根据 &lt;a href=&#34;https://docs.python.org/3/library/pickle.html#pickle-picklable&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;，可序列化的类型包括：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;原文&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;布尔型和空值&lt;/td&gt;
&lt;td&gt;&lt;code&gt;None&lt;/code&gt;, &lt;code&gt;True&lt;/code&gt;, and &lt;code&gt;False&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数字类型中的整数，浮点数和复数&lt;/td&gt;
&lt;td&gt;integers, floating point numbers, complex numbers&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串类型和二进制类型 (字节流，字节数组)&lt;/td&gt;
&lt;td&gt;strings, bytes, bytearrays&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;只包含可序列化对象的元组、集合、列表、字典&lt;/td&gt;
&lt;td&gt;tuples, lists, sets, and dictionaries containing only picklable objects&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;模块中最顶层声明的非匿名函数&lt;/td&gt;
&lt;td&gt;functions defined at the top level of a module (using def, not lambda)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;模块中最顶层声明的内置函数&lt;/td&gt;
&lt;td&gt;built-in functions defined at the top level of a module&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;模块中最顶层声明的类&lt;/td&gt;
&lt;td&gt;classes that are defined at the top level of a module&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__getstate__&lt;/code&gt; 的结果或 &lt;code&gt;__dict__&lt;/code&gt; 是可序列化的这样的类的实例&lt;/td&gt;
&lt;td&gt;instances of such classes whose &lt;code&gt;__dict__&lt;/code&gt; or the result of calling &lt;code&gt;__getstate__()&lt;/code&gt; is picklable&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;破案了，上面代码中，我们的进程池要序列化的是类中的函数，就不符合最顶层定义的函数的要求。&lt;/p&gt;
&lt;p&gt;所以最直接的解决办法也很简单，把要并行的函数抽外面去就行了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# !/usr/bin/env python
# -*- coding: utf-8 -*-

from concurrent.futures import ProcessPoolExecutor


def single_process(page):
    pass


class PageProcess(object):
    def __init__(self, worker):
        self.max_worker = worker

    def multi_process(self, page_list):
        with ProcessPoolExecutor(max_workers=self.max_worker) as pp:
            result = pp.map(single_process, page_list)

&lt;/code&gt;&lt;/pre&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;英文这种语序 / 标点我老是搞不懂，这个 &lt;code&gt;containing only picklable objects&lt;/code&gt; 到底是指 dictionaries 还是前面全部，就当是全部吧&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>列表原序去重性能测试</title>
      <link>https://szthanatos.github.io/post/python/unique_list_ordered/</link>
      <pubDate>Fri, 01 Sep 2017 18:08:57 +0800</pubDate>
      <guid>https://szthanatos.github.io/post/python/unique_list_ordered/</guid>
      <description>&lt;p&gt;对列表的去重很简单，&lt;code&gt;set()&lt;/code&gt; 一下再 &lt;code&gt;list()&lt;/code&gt; 回来就可以了，但是如果要保留原始列表的顺序呢？&lt;/p&gt;
&lt;p&gt;举例，对 &lt;code&gt;[&amp;quot;b&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;]&lt;/code&gt; 这个列表进行原序去重，得到结果应该是 &lt;code&gt;[&#39;b&#39;, &#39;c&#39;, &#39;a&#39;]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;有下面这几种写法：&lt;/p&gt;
&lt;h4 id=&#34;二次排序&#34;&gt;二次排序&lt;/h4&gt;
&lt;p&gt;也就是对去重结果再按原列表 sort 一次：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sort_1(list_in):
    return sorted(list(set(list_in)), key=list_in.index)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;匿名函数&#34;&gt;匿名函数&lt;/h4&gt;
&lt;p&gt;使用匿名函数将列表里不重复的元素累加到一个新列表中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sort_2(list_in):
    return reduce(lambda x, y: x if y in x else x + [y], [[], ] + list_in)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;借用字典&#34;&gt;借用字典&lt;/h4&gt;
&lt;h5 id=&#34;有序字典&#34;&gt;有序字典&lt;/h5&gt;
&lt;p&gt;使用 &lt;code&gt;OrderedDict&lt;/code&gt; 排序：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sort_3(list_in):
    return list(collections.OrderedDict.fromkeys(list_in).keys())
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;defaultdict&#34;&gt;defaultdict&lt;/h4&gt;
&lt;p&gt;类似的, 我们使用 &lt;code&gt;defaultdict&lt;/code&gt; 进行排序：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sort_4(list_in):
    return list(collections.defaultdict.fromkeys(list_in).keys())
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;直接使用-dict&#34;&gt;直接使用 dict&lt;/h4&gt;
&lt;p&gt;在 python3.6 之前， &lt;code&gt;dict&lt;/code&gt; 的 &lt;code&gt;key&lt;/code&gt; 的顺序并不保证一定是插入顺序，所以只有在 python3.6 之后才可以直接用 &lt;code&gt;dict&lt;/code&gt; 实现这个操作；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sort_5(list_in):
    return list(dict.fromkeys(list_in).keys())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完整性能测试代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# !/usr/bin/env python
# encoding: utf-8

from timeit import repeat
from functools import reduce
from collections import defaultdict, OrderedDict

example = [&amp;quot;b&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;]


def sort_1(list_in):
    return sorted(list(set(list_in)), key=list_in.index)


def sort_2(list_in):
    return reduce(lambda x, y: x if y in x else x + [y], [[], ] + list_in)


def sort_3(list_in):
    return list(OrderedDict.fromkeys(list_in).keys())


def sort_4(list_in):
    return list(defaultdict.fromkeys(list_in).keys())


def sort_5(list_in):
    return list(dict.fromkeys(list_in).keys())


if __name__ == &#39;__main__&#39;:
    # time usage: t5&amp;lt; t4 &amp;lt; t3 &amp;lt; t2 &amp;lt; t1
    result = {}
    for i in range(1, 6):
        result[&#39;sort_{}&#39;.format(i)] = repeat(&#39;sort_{}(example)&#39;.format(i),
                                             &#39;from __main__ import sort_{}, example&#39;.format(i),
                                             number=1000000,
                                             repeat=5)
    for k, v in result.items():
        avg_v = round(sum(v) / len(v), 3)
        print(k, avg_v)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在我的苏菲婆上的结果仅供参考：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;排序&lt;/th&gt;
&lt;th&gt;平均时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;sort_1&lt;/td&gt;
&lt;td&gt;1.477&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sort_2&lt;/td&gt;
&lt;td&gt;1.305&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sort_3&lt;/td&gt;
&lt;td&gt;0.957&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sort_4&lt;/td&gt;
&lt;td&gt;0.734&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sort_5&lt;/td&gt;
&lt;td&gt;0.698&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可见，python3.6 之后 dict 是最好的原序去重办法，3.6 之前用 defaultdict 吧。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
