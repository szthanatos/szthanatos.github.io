<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>优化指南 | Kryptonite Lab</title>
    <link>https://szthanatos.github.io/topic/redis/04-advanced/</link>
      <atom:link href="https://szthanatos.github.io/topic/redis/04-advanced/index.xml" rel="self" type="application/rss+xml" />
    <description>优化指南</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh-Hans</language><copyright>© 2021 szthanatos</copyright><lastBuildDate>Mon, 18 Mar 2019 15:04:35 +0800</lastBuildDate>
    <image>
      <url>https://szthanatos.github.io/media/icon_hu638af3a55c65206eddec4e3c4c13a753_187410_512x512_fill_lanczos_center_2.png</url>
      <title>优化指南</title>
      <link>https://szthanatos.github.io/topic/redis/04-advanced/</link>
    </image>
    
    <item>
      <title>优化指南 - 设计</title>
      <link>https://szthanatos.github.io/topic/redis/04-advanced/improve-01/</link>
      <pubDate>Mon, 18 Mar 2019 15:04:35 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/redis/04-advanced/improve-01/</guid>
      <description>&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;
&lt;p&gt;不同数据类型对应的操作的时间复杂度也不一样，选择合适的数据类型可以降低很多时间成本：&lt;/p&gt;
&lt;h3 id=&#34;string&#34;&gt;String&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SET&lt;/code&gt; key value [EX seconds] [PX milliseconds] [NX|XX]&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SETNX&lt;/code&gt; key value&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SETEX&lt;/code&gt; key seconds value&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;PSETEX&lt;/code&gt; key milliseconds value&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GET&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GETSET&lt;/code&gt; key value&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;STRLEN&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;APPEND&lt;/code&gt; key value&lt;/td&gt;
&lt;td&gt;平均 O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SETRANGE&lt;/code&gt; key offset value&lt;/td&gt;
&lt;td&gt;短字符串平均 O(1)/ 长字符串 O(N)，N 为 &lt;code&gt;value&lt;/code&gt; 长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GETRANGE&lt;/code&gt; key start end&lt;/td&gt;
&lt;td&gt;O(N)，N 为返回值长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;INCR&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;INCRBY&lt;/code&gt; key increment&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;INCRBYFLOAT&lt;/code&gt; key increment&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DECR&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DECRBY&lt;/code&gt; key decrement&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MSET&lt;/code&gt; key value [key value …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MSETNX&lt;/code&gt; key value [key value …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MGET&lt;/code&gt; key [key …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;list&#34;&gt;List&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LPUSH&lt;/code&gt; key value [value …]&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LPUSHX&lt;/code&gt; key value&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RPUSH&lt;/code&gt; key value [value …]&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RPUSHX&lt;/code&gt; key value&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LPOP&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RPOP&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RPOPLPUSH&lt;/code&gt; source destination&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LREM&lt;/code&gt; key count value&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LLEN&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LINDEX&lt;/code&gt; key index&lt;/td&gt;
&lt;td&gt;O(N)，N 为到达下标 &lt;code&gt;index&lt;/code&gt; 过程中经过的元素数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LINSERT&lt;/code&gt; key BEFORE|AFTER pivot value&lt;/td&gt;
&lt;td&gt;O(N)，N 为寻找 &lt;code&gt;pivot&lt;/code&gt; 过程中经过的元素数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LSET&lt;/code&gt; key index value&lt;/td&gt;
&lt;td&gt;头尾元素 O(1)，其他 O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LRANGE&lt;/code&gt; key start stop&lt;/td&gt;
&lt;td&gt;O(S+N)，S 为偏移量 start ， N 为指定区间内元素的数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LTRIM&lt;/code&gt; key start stop&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BLPOP&lt;/code&gt; key [key …] timeout&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BRPOP&lt;/code&gt; key [key …] timeout&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BRPOPLPUSH&lt;/code&gt; source destination timeout&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;hash&#34;&gt;Hash&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HSET&lt;/code&gt; hash field value&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HSETNX&lt;/code&gt; hash field value&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HGET&lt;/code&gt; hash field&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HEXISTS&lt;/code&gt; hash field&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HDEL&lt;/code&gt; key field [field …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HLEN&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HSTRLEN&lt;/code&gt; key field&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HINCRBY&lt;/code&gt; key field increment&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HINCRBYFLOAT&lt;/code&gt; key field increment&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HMSET&lt;/code&gt; key field value [field value …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HMGET&lt;/code&gt; key field [field …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HKEYS&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HVALS&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HGETALL&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HSCAN&lt;/code&gt; key cursor [MATCH pattern] [COUNT count]&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;set&#34;&gt;Set&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SADD&lt;/code&gt; key member [member …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SISMEMBER&lt;/code&gt; key member&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SPOP&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SRANDMEMBER&lt;/code&gt; key [count]&lt;/td&gt;
&lt;td&gt;无 conut 时 O(1)，有 conut 时 O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SREM&lt;/code&gt; key member [member …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SMOVE&lt;/code&gt; source destination member&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SCARD&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SMEMBERS&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SSCAN&lt;/code&gt; key cursor [MATCH pattern] [COUNT count]&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SINTER&lt;/code&gt; key [key …]&lt;/td&gt;
&lt;td&gt;O(N*M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SINTERSTORE&lt;/code&gt; destination key [key …]&lt;/td&gt;
&lt;td&gt;O(N*M)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SUNION&lt;/code&gt; key [key …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SUNIONSTORE&lt;/code&gt; destination key [key …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SDIFF&lt;/code&gt; key [key …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SDIFFSTORE&lt;/code&gt; destination key [key …]&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;zset&#34;&gt;ZSet&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZADD&lt;/code&gt; key score member [[score member] [score member] …]&lt;/td&gt;
&lt;td&gt;O(M*log(N))，N 是有序集的基数， M 为成功添加的新成员的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZSCORE&lt;/code&gt; key member&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZINCRBY&lt;/code&gt; key increment member&lt;/td&gt;
&lt;td&gt;O(log(N))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZCARD&lt;/code&gt; key&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZCOUNT&lt;/code&gt; key min max&lt;/td&gt;
&lt;td&gt;O(log(N))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZRANGE&lt;/code&gt; key start stop [WITHSCORES]&lt;/td&gt;
&lt;td&gt;O(log(N)+M)，N 为有序集的基数，而 M 为结果集的基数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZREVRANGE&lt;/code&gt; key start stop [WITHSCORES]&lt;/td&gt;
&lt;td&gt;O(log(N)+M)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZRANGEBYSCORE&lt;/code&gt; key min max [WITHSCORES] [LIMIT offset count]&lt;/td&gt;
&lt;td&gt;O(log(N)+M)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZREVRANGEBYSCORE&lt;/code&gt; key max min [WITHSCORES] [LIMIT offset count]&lt;/td&gt;
&lt;td&gt;O(log(N)+M)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZRANK&lt;/code&gt; key member&lt;/td&gt;
&lt;td&gt;O(log(N))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZREVRANK&lt;/code&gt; key member&lt;/td&gt;
&lt;td&gt;O(log(N))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZREM&lt;/code&gt; key member [member …]&lt;/td&gt;
&lt;td&gt;O(M*log(N))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZREMRANGEBYRANK&lt;/code&gt; key start stop&lt;/td&gt;
&lt;td&gt;O(log(N)+M)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZREMRANGEBYSCORE&lt;/code&gt; key min max&lt;/td&gt;
&lt;td&gt;O(log(N)+M)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZRANGEBYLEX&lt;/code&gt; key min max [LIMIT offset count]&lt;/td&gt;
&lt;td&gt;O(log(N)+M)，N 为有序集合的元素数量， 而 M 则是命令返回的元素数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZLEXCOUNT&lt;/code&gt; key min max&lt;/td&gt;
&lt;td&gt;O(log(N))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZREMRANGEBYLEX&lt;/code&gt; key min max&lt;/td&gt;
&lt;td&gt;O(log(N)+M)，N 为有序集合的元素数量， 而 M 则为被移除的元素数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZSCAN&lt;/code&gt; key cursor [MATCH pattern] [COUNT count]&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZUNIONSTORE&lt;/code&gt; destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]&lt;/td&gt;
&lt;td&gt;O(N)+O(M log(M))，N 为给定有序集基数的总和， M 为结果集的基数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZINTERSTORE&lt;/code&gt; destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]&lt;/td&gt;
&lt;td&gt;O(N&lt;em&gt;K)+O(M&lt;/em&gt;log(M))， N 为给定 key 中基数最小的有序集， K 为给定有序集的数量， M 为结果集的基数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;模拟类型&#34;&gt;模拟类型&lt;/h3&gt;
&lt;p&gt;除了直接使用 redis 数据类型，其他的一些常见数据结构也可以用固定操作模拟出来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;堆栈&lt;/strong&gt;：lpush + lpop = Stack&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;队列&lt;/strong&gt;：lpush + rpop = Queue&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有限集合&lt;/strong&gt;：lpush + ltrim = Capped Collection&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;：lpush + brpop = Message Queue&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;负载&#34;&gt;负载&lt;/h2&gt;
&lt;p&gt;redis 基本的逻辑存储单位是键 (Key) 对象，键底层的编码方式会随着键的类型 / 大小而改变：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;编码方式 (C 语言实现)&lt;/th&gt;
&lt;th&gt;情况&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;String&lt;/code&gt; 类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int(long 类型整数)&lt;/td&gt;
&lt;td&gt;long 能存下的整数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;embstr(embstr 类型的简单动态字符串 SDS)&lt;/td&gt;
&lt;td&gt;&amp;lt;=32 字节的字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;raw(简单动态字符串 SDS)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;List&lt;/code&gt; 类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ziplist(压缩列表)&lt;/td&gt;
&lt;td&gt;列表内元素不超过 512 个并且所有元素长度都小于 64 字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;linkedlist(双端链表)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;Hash&lt;/code&gt; 类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ziplist&lt;/td&gt;
&lt;td&gt;哈希内不超过 512 个键值对并且所有键值对的键和值的长度都小于 64 字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hashtable(字典)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;Set&lt;/code&gt; 类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;intset(整数集合)&lt;/td&gt;
&lt;td&gt;集合内元素不超过 512 个并且所有元素都是整数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hashtable&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;ZSet&lt;/code&gt; 类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ziplist&lt;/td&gt;
&lt;td&gt;有序集合内元素不超过 128 个并且所有元素的长度都小于 64 字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;skiplist(跳跃表和字典)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;所以简单的来说，String 长度小于 32 字节，其他复合类型元素个数不超过 512 个 (ZSet 不超过 128 个) 并且元素小于 64 字节或者是整数 (Set) 的时候，是 redis 认为的一个 key 的合理值，超过这个范围 redis 也是允许的，但是关注点就放在存储而不是性能上了。&lt;/p&gt;
&lt;p&gt;大键会拖累存储性能。尤其是在时间复杂度不是 O(1)的操作上，性能损失是线性 (eg: &lt;code&gt;LREM&lt;/code&gt;) 甚至指数 (eg: &lt;code&gt;ZINTERSTORE&lt;/code&gt;) 上升的。&lt;/p&gt;
&lt;p&gt;过小 (零碎) 的键也不合适，它是对性能的一种浪费，比如要存放 &lt;code&gt;用户: 用户信息&lt;/code&gt;，直接将每个用户存为一个 &lt;code&gt;String&lt;/code&gt;，相比用 &lt;code&gt;Hash&lt;/code&gt; 把所有用户存储在一个键上，想要实现 &lt;code&gt;hgetall&lt;/code&gt; 这样的操作既复杂，效率也更低。&lt;/p&gt;
&lt;h3 id=&#34;集群倾斜--热点问题&#34;&gt;集群倾斜 &amp;amp; 热点问题&lt;/h3&gt;
&lt;p&gt;在集群中，redis 是划分出 16384 个哈希槽，然后将哈希槽平均 (也可以手动指定) 分配到集群节点上。键会通过 &lt;code&gt;crc16&lt;/code&gt; 算法计算并将结果对 16384 取余，由此将键映射到编号为 0~16383 的哈希槽中。&lt;/p&gt;
&lt;p&gt;大键会造成集群倾斜，也就是大键所在节点的内存可能被占满了，而其他节点还空着。极端情况下如果一个键所占空间超过了节点分配的内存，那这个集群可能会永远 &lt;code&gt;fail&lt;/code&gt; 下去——虽然有大量内存空着，但是没有一个节点能放下这个键了。&lt;/p&gt;
&lt;p&gt;大键越多，分布越不均匀，在集群中就越容易出现热点问题 (另一种角度的倾斜)，简单来说，就是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于数据都集中在一个键&lt;/li&gt;
&lt;li&gt;→ 对数据的操作都集中在一个键&lt;/li&gt;
&lt;li&gt;→ 键位于某个哈希槽&lt;/li&gt;
&lt;li&gt;→ 哈希槽所在的节点读写压力非常大&lt;/li&gt;
&lt;li&gt;→ 集群其他节点都在划水&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设是 3 个 master 的集群，本来的处理能力可能是 100000 q/s * 3，这样的情况下实际发挥出来的就只有 100000 q/s 了。&lt;/p&gt;
&lt;p&gt;针对大键 &amp;amp; 倾斜问题可以有以下措施：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将可能的大键进行拆分，比如将一个大 List 拆成 List0~List9；&lt;/li&gt;
&lt;li&gt;在集群配置中开启 &lt;code&gt;readonly&lt;/code&gt; 以降低主节点读压力 (详见 &lt;a href=&#34;cluster_command.md&#34;&gt;《Redis 集群相关命令》&lt;/a&gt;)；&lt;/li&gt;
&lt;li&gt;根据实际情况，修改 redis 变更编码类型的阈值，比如设定 &lt;code&gt;list-max-ziplist-entries=1024&lt;/code&gt; 让元素在 1024 以内的列表都用 ziplist 编码；&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;redis5 中提供新的数据结构 &lt;code&gt;Stream&lt;/code&gt;，直接实现了 Kafka 那种支持多播的消息队列&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>优化指南 - 使用</title>
      <link>https://szthanatos.github.io/topic/redis/04-advanced/improve-02/</link>
      <pubDate>Mon, 18 Mar 2019 15:04:35 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/redis/04-advanced/improve-02/</guid>
      <description>&lt;h2 id=&#34;操作&#34;&gt;操作&lt;/h2&gt;
&lt;h3 id=&#34;批量操作&#34;&gt;批量操作&lt;/h3&gt;
&lt;p&gt;传统数据库也存在批量操作效率高于单次操作的情况，但是 redis 由于执行效率更高，批量操作带来的提升也更夸张。举个不是很恰当的例子，还是按 redis 每秒能处理 10k 请求来算——&lt;/p&gt;
&lt;p&gt;假设客户端和服务端不在同一机器，网络通信存在额外 1ms 延时：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1000 次 get&lt;/td&gt;
&lt;td&gt;1000 &lt;em&gt;1 + 1000&lt;/em&gt; 0.01 = 1010  (ms)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10 次 100 个键值对的 mget&lt;/td&gt;
&lt;td&gt;10 &lt;em&gt;(1&lt;/em&gt; 1 + 100 * 0.01) = 20 (ms)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1 次 1000 个键值对的 mget&lt;/td&gt;
&lt;td&gt;1 &lt;em&gt;1 + 1000&lt;/em&gt; 0.01 = 11 (ms)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果一条条去执行，这时 redis 每秒只能处理 1000 / 1.01 ≈ 990 次请求，只发挥了实际计算力的 0.99%。&lt;/p&gt;
&lt;h4 id=&#34;multi-action-vs-pipeline-vs-transaction&#34;&gt;Multi-action vs Pipeline vs Transaction&lt;/h4&gt;
&lt;p&gt;批量操作有 3 种实现方式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Multi-action&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是 m 开头的命令，比如 &lt;code&gt;mget&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;效率是最高的，因为它只需要解析一条命令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只能做一件事&lt;/li&gt;
&lt;li&gt;一次操作的 key 太多的话会导致 redis 实例的响应能力等比下降&lt;/li&gt;
&lt;li&gt;不具有原子性，存在部分成功部分失败的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Pipeline&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;管道式的操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以处理多类数据&lt;/li&gt;
&lt;li&gt;可以将大量命令分解为多个包依次发送执行&lt;/li&gt;
&lt;li&gt;使用灵活&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不保证事务，其他客户端发送的命令可能在 pipeline 执行期间被执行&lt;/li&gt;
&lt;li&gt;不具有原子性，存在部分成功部分失败的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Transaction&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性，要么全执行要么不执行&lt;/li&gt;
&lt;li&gt;乐观锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令会被分批发送给服务端，最后统一执行，性能是最低的 (但还是远高于执行 n 次命令)&lt;/li&gt;
&lt;li&gt;随着竞争激烈程度的上升，乐观锁会导致性能相应下降&lt;/li&gt;
&lt;li&gt;在集群中，只有同属于一个哈希槽的键才能使用事务，多数客户端支持的不好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，因为 Pipeline 是基于 redis 自定义的 RESP 协议实现的，而 Transaction 是命令实现，所以给了我们组合使用的机会。相比直接使用事务会快上一点点，没有太大区别。&lt;/p&gt;
&lt;p&gt;总的来说，实现批量执行的核心肯定是 Pipeline，请尽可能的使用。&lt;/p&gt;
&lt;p&gt;放上一组官方测试结果以供参考：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Intel(R) Xeon(R) CPU E5520 @ 2.27GHz (with pipelining)
$ ./redis-benchmark -r 1000000 -n 2000000 -t get,set,lpush,lpop -P 16 -q
&amp;gt; SET: 552028.75 requests per second
&amp;gt; GET: 707463.75 requests per second
&amp;gt; LPUSH: 767459.75 requests per second
&amp;gt; LPOP: 770119.38 requests per second

# Intel(R) Xeon(R) CPU E5520 @ 2.27GHz (without pipelining)
$ ./redis-benchmark -r 1000000 -n 2000000 -t get,set,lpush,lpop -q
&amp;gt; SET: 122556.53 requests per second
&amp;gt; GET: 123601.76 requests per second
&amp;gt; LPUSH: 136752.14 requests per second
&amp;gt; LPOP: 132424.03 requests per second
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;减少阻塞&#34;&gt;减少阻塞&lt;/h3&gt;
&lt;p&gt;另一方面，针对每条命令，由于 redis 是单进程单线程的模式，命令是依次执行的，想象一下星巴克排队，只要有一个客人堵在那，后面的不管买多买少都只能排着&amp;hellip;&lt;/p&gt;
&lt;p&gt;可能造成阻塞的命令包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;del&lt;/code&gt;，这个删除是在前台阻塞式的删除，在 redis4.0 以后应该使用 &lt;code&gt;unlink&lt;/code&gt; 后台非阻塞的标记删除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keys&lt;/code&gt;、&lt;code&gt;hgetall&lt;/code&gt;、&lt;code&gt;smembers&lt;/code&gt;，这类返回所有结果的命令都会占用大量资源，都应该用 &lt;code&gt;scan&lt;/code&gt;、&lt;code&gt;hscan&lt;/code&gt;、&lt;code&gt;sscan&lt;/code&gt; 等命令替换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sinter&lt;/code&gt;/&lt;code&gt;sunion&lt;/code&gt;/&lt;code&gt;sdiff&lt;/code&gt; 的结果如果会重复使用的话，用 &lt;code&gt;sinterstore&lt;/code&gt;/&lt;code&gt;sunionstore&lt;/code&gt;/&lt;code&gt;sdiffstore&lt;/code&gt; 将结果保存起来&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sort&lt;/code&gt;，可以先取到本地再排序&lt;/li&gt;
&lt;li&gt;能用 &lt;code&gt;mget&lt;/code&gt;/&lt;code&gt;mhset&lt;/code&gt; 的情况下就不要用 &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;总之，所有时间复杂度大于 O(log n) 的操作都应该考虑有没有更低占用的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了命令本身，造成阻塞的原因还有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 饱和：cpu 占用率 100% 了&lt;/li&gt;
&lt;li&gt;CPU 竞争：和其他服务竞争资源&lt;/li&gt;
&lt;li&gt;持久化带来的 IO 阻塞
&lt;ul&gt;
&lt;li&gt;fork 阻塞：rdb/aof 文件重写的时候 fork 出的子进程长时间不能完成，导致的主进程阻塞&lt;/li&gt;
&lt;li&gt;AOF 阻塞：数据变动剧烈的时候 fsync 持续写硬盘导致的&lt;/li&gt;
&lt;li&gt;HugePage 阻塞：如果 linux 内核里启用了 &lt;code&gt;transparent_hugepage&lt;/code&gt;，会对内存和延迟带来很大影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存交换：物理内存不够用了，部分数据被写到 Linux 的虚拟内存，也就是 swap，但是内存和磁盘的读写速度起码差了 5 个量级&lt;/li&gt;
&lt;li&gt;网络问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些就需要在使用过程中不断监测和发现了。&lt;/p&gt;
&lt;h2 id=&#34;策略&#34;&gt;策略&lt;/h2&gt;
&lt;h3 id=&#34;过期回收&#34;&gt;过期回收&lt;/h3&gt;
&lt;p&gt;随着时间增长，碎片化的无用 key 的数量也会持续上升，直到最终你的内存被垃圾 Key 占满。
所以一个好习惯是给不需要持久存储 (redis 本身就不是用来持久化的) 的 Key 都加上过期时间。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;注释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EXPIRE &amp;lt;KEY&amp;gt; &amp;lt;TTL&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将键的生存时间设为 ttl 秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;PEXPIRE &amp;lt;KEY&amp;gt; &amp;lt;TTL&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将键的生存时间设为 ttl 毫秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EXPIREAT &amp;lt;KEY&amp;gt; &amp;lt;timestamp&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将键的过期时间设为 timestamp 所指定的秒数时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;PEXPIREAT &amp;lt;KEY&amp;gt; &amp;lt;timestamp&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将键的过期时间设为 timestamp 所指定的毫秒数时间戳.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;但是需要注意，过期键的内存空间默认并不会被立即回收。redis 的内存回收策略主要是这两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;被动删除&lt;/strong&gt;，读 / 写过期键时触发删除；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主动删除&lt;/strong&gt;，每隔 100ms 检查 20 个带过期时间的键，如果有超过四分之一的键过期，则重复上面步骤；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，设置 &lt;code&gt;maxmemory&lt;/code&gt; 最大内存，可以在达到内存阈值的时候触发强制删除机制 (配置项 &lt;code&gt;maxmemory-policy&lt;/code&gt;)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;noeviction&lt;/strong&gt;，禁止强制删除，&lt;strong&gt;默认策略&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;volatile-ttl&lt;/strong&gt;，从带过期时间的键中删除最接近过期的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;volatile-lru&lt;/strong&gt;，从带过期时间的键中删除最近最久未使用的 (&lt;code&gt;Least Recently Used&lt;/code&gt;)；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;volatile-lfu&lt;/strong&gt;，从带过期时间的键中删除最近最少使用的 (&lt;code&gt;Least Frequently Used&lt;/code&gt;)；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;volatile-random&lt;/strong&gt;，从带过期时间的键中随机删除；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;allkeys-lru&lt;/strong&gt;，从所有键中删除最近最久未使用的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;allkeys-lfu&lt;/strong&gt;，从所有键中删除最近最少使用的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;allkeys-random&lt;/strong&gt;，从带过期时间的键中随机删除；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;持久化&#34;&gt;持久化&lt;/h3&gt;
&lt;p&gt;redis 数据落到硬盘依赖两种持久化机制：RDB 和 AOF。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;RDB&lt;/th&gt;
&lt;th&gt;AOF&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;存储内容&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;数据&lt;/td&gt;
&lt;td&gt;写操作日志&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;性能影响&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;小&lt;/td&gt;
&lt;td&gt;大&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;恢复速度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;存储空间&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;小&lt;/td&gt;
&lt;td&gt;大&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;可读性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;安全程度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;较低，保存频率低&lt;/td&gt;
&lt;td&gt;较高，保存频率高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;默认开启&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;存储策略&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;save 900 1&lt;/code&gt;：九百秒内一次修改即保存 &lt;br&gt;&lt;code&gt;save 300 10&lt;/code&gt;：三百秒内十次修改即保存 &amp;lt; br&amp;gt;&lt;code&gt;save 60 10000&lt;/code&gt;：六十秒内一万次修改即保存 &amp;lt; br &amp;gt; 允许自定义&lt;/td&gt;
&lt;td&gt;&lt;code&gt;always&lt;/code&gt;：逐条保存 &amp;lt; br&amp;gt;or&lt;br&gt;&lt;code&gt;everysec&lt;/code&gt;：每秒保存 &amp;lt; br&amp;gt;or&lt;br&gt;&lt;code&gt;no&lt;/code&gt;：系统自己决定什么时候保存&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;RDB 的 save 策略配合大键有时候简直性能地狱。必要时请重写触发机制。&lt;/p&gt;
&lt;p&gt;AOF 的日志文件会膨胀的非常厉害，所以会定期重写。如果文件变动过于剧烈，你会发现 swap 比内存更先被吃干净。&lt;/p&gt;
&lt;p&gt;redis4.0 以后支持一个叫 &lt;code&gt;aof-use-rdb-preamble&lt;/code&gt; 的参数，意思就是在重写 AOF 文件的时候，会把早期日志写成 RDB 格式，新增加的继续使用 AOF。这样一来可以替高重写和恢复的速度。某种意义上有了这个就不必单独开启 RDB 持久化了。&lt;/p&gt;
&lt;h3 id=&#34;内存清理&#34;&gt;内存清理&lt;/h3&gt;
&lt;p&gt;在 redis4.0 之后，可以通过将配置里的 &lt;code&gt;activedefrag&lt;/code&gt; 设置为 &lt;code&gt;yes&lt;/code&gt; 开启自动清理，或者通过 &lt;code&gt;memory purge&lt;/code&gt; 命令手动清理。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>优化指南 - 运维</title>
      <link>https://szthanatos.github.io/topic/redis/04-advanced/improve-03/</link>
      <pubDate>Mon, 18 Mar 2019 15:04:35 +0800</pubDate>
      <guid>https://szthanatos.github.io/topic/redis/04-advanced/improve-03/</guid>
      <description>&lt;h2 id=&#34;监控&#34;&gt;监控&lt;/h2&gt;
&lt;p&gt;为了发现前面所说的问题，需要开发 / 运维人员不断的监控 redis 运行情况。&lt;/p&gt;
&lt;h3 id=&#34;redis-cli-查询&#34;&gt;redis-cli 查询&lt;/h3&gt;
&lt;p&gt;部分信息无法通过 redis 命令直接获取，但是可以通过 &lt;code&gt;redis-cli [参数]&lt;/code&gt; 获取：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;–-bigkeys&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;后台 scan 出每种数据类型中较大的 key&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--latency&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;服务端响应延时&lt;/p&gt;
&lt;h3 id=&#34;slowlog-命令&#34;&gt;slowlog 命令&lt;/h3&gt;
&lt;p&gt;在客户端执行 &lt;code&gt;slowlog get [n]&lt;/code&gt; 可以获取最慢的 n 条执行命令的记录&lt;/p&gt;
&lt;h3 id=&#34;info-命令&#34;&gt;info 命令&lt;/h3&gt;
&lt;p&gt;返回服务器信息，性能监测的时候注意其中的几个部分：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;memory&lt;/strong&gt;：&lt;code&gt;mem_fragmentation_ratio&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;内存碎片率，&lt;code&gt;used_memory_rss&lt;/code&gt;(系统分配内存总量) 和 &lt;code&gt;used_memory&lt;/code&gt;(Redis 分配器分配的内存总量) 的比值。&lt;/p&gt;
&lt;p&gt;在 1-1.5 之间都是合理值，&amp;lt;1 则说明内存已经占满，正在和硬盘进行内存交换，性能下降严重，&amp;gt;1.5 则说明碎片过多需要清理了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stats&lt;/strong&gt;：&lt;code&gt;latest_fork_usec&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最近一次 fork 操作耗时&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;persistence&lt;/strong&gt;：&lt;code&gt;aof_delayed_fsync&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;被延迟的 fsync 调用数量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;clients&lt;/strong&gt;：&lt;code&gt;connected_clients&lt;/code&gt;，&lt;code&gt;blocked_clients&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;已连接客户端的数量和正在等待阻塞命令的客户端的数量&lt;/p&gt;
&lt;h3 id=&#34;monitor-命令&#34;&gt;monitor 命令&lt;/h3&gt;
&lt;p&gt;可以用来监测一个节点一段时间内执行的命令，从而统计出热点 key。但是 monitor 自己也是有内存占用的，所以不能频繁、持续的使用。&lt;/p&gt;
&lt;h2 id=&#34;部署&#34;&gt;部署&lt;/h2&gt;
&lt;h3 id=&#34;网络&#34;&gt;网络&lt;/h3&gt;
&lt;p&gt;影响 redis 性能的最主要因素是网络。&lt;/p&gt;
&lt;p&gt;按官方基准测试来说，对于 10kb 以内的数据，redis 的处理能力在 100000q/s 以上。&lt;/p&gt;
&lt;p&gt;那么假设每次 set/get 的 4kb 大小的字符串，这时占用的带宽就有 3.2 Gbit/s ，千兆网卡 (1 Gbit/s) 就不够用了，得换万兆网卡 (10 Gbit/s) 才能满足需求，可见想跑满 redis 的 CPU 计算力对网络的要求是很夸张的。&lt;/p&gt;
&lt;p&gt;当然，这个例子比较极端，redis 官方推荐的网络环境下每次传输的包最好不超过一个 &lt;code&gt;MTU&lt;/code&gt;(大约 1500 bytes)。&lt;/p&gt;
&lt;p&gt;如果完全抛开网络因素，客户端服务端都在单机上时，使用 Unix 域套接字 (&lt;code&gt;Unix domain sockets&lt;/code&gt;，也叫 &lt;code&gt;IPC(inter-precess communication) socket&lt;/code&gt; 进程间通信套接字) 替换默认的 TCP/IP 连接方式，能额外再有 50% 的吞吐量提升(不过在大量使用 pipeline 的情况下就没差这么多了)。&lt;/p&gt;
&lt;p&gt;启用 Unix 域套接字需要在配置文件中取消注释：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# unixsocket 路径
unixsocket /tmp/redis.sock

# unixsocket 权限
unixsocketperm 700
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后就可以在客户端使用指定方式连接了，以 python 客户端为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import redis

redis_connect = redis.Redis(unix_socket_path=&#39;/tmp/redis.sock&#39;)
pass
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;cpu&#34;&gt;CPU&lt;/h3&gt;
&lt;p&gt;redis 更倾向于具有更大缓存而不是更多核的 CPU，在多核的情况下，redis 性能会受 NUMA 配置和进程所处位置的影响，指定客户端和服务器使用同一 CPU 的两个不同核心可以使从 L3 缓存获得的收益最大化。&lt;/p&gt;
&lt;p&gt;另外，redis 在 Inter 和 AMD 的 CPU 上的表现也有差别，在某些情况下在 AMD 的 CPU 上性能可能只有 Inter 的一半。&lt;/p&gt;
&lt;h3 id=&#34;内存&#34;&gt;内存&lt;/h3&gt;
&lt;p&gt;只有在面对大于 10KB 的数据的时候，内存频率 / 带宽才会影响 redis 性能，所以一般不用去考虑。内存大小只会影响能存放的数据量。&lt;/p&gt;
&lt;h3 id=&#34;连接数&#34;&gt;连接数&lt;/h3&gt;
&lt;p&gt;redis 可以在 60000 多个连接时维持 50000 q/s 的性能，但是根据官方测试，具有 30000 个连接的 redis 实例只能处理 100 个连接实例可实现的吞吐量的一半。&lt;/p&gt;
&lt;h3 id=&#34;虚拟化&#34;&gt;虚拟化&lt;/h3&gt;
&lt;p&gt;虚拟机中的 redis 性能肯定是低于实机上的，系统调用和中断上面浪费的太多。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
