<!DOCTYPE html><html lang="zh-Hans" >

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Wowchemy 5.2.0 for Hugo" />
  

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Lex Wayne" />

  
  
  
    
  
  <meta name="description" content="Docker 简介 什么是 Docker Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公" />

  
  <link rel="alternate" hreflang="zh-Hans" href="https://szthanatos.github.io/topic/docker/basis/" />

  







  




  
  
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    <meta name="theme-color" content="#4169E1" />
  

  
  

  
  
  
  
    
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha256-FMvZuGapsJLjouA6k7Eo2lusoAX9i0ShlWFG6qt7SLc=" crossorigin="anonymous">

    
    
    
    
      
      
    
    
    

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/github.min.css" crossorigin="anonymous" title="hl-light" media="print" onload="this.media='all'">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" media="print" onload="this.media='all'" disabled>
        
      
    

    
    
    

    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      
        
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC&family=JetBrains+Mono&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC&family=JetBrains+Mono&display=swap" media="print" onload="this.media='all'">
    
  

  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.4dc2920ef083a6510eeb71915c8cadbc.css" />

  



  

  

  




  
  
  

  

  
    <link rel="manifest" href="/index.webmanifest" />
  

  <link rel="icon" type="image/png" href="/media/icon_hu638af3a55c65206eddec4e3c4c13a753_187410_32x32_fill_lanczos_center_2.png" />
  <link rel="apple-touch-icon" type="image/png" href="/media/icon_hu638af3a55c65206eddec4e3c4c13a753_187410_180x180_fill_lanczos_center_2.png" />

  <link rel="canonical" href="https://szthanatos.github.io/topic/docker/basis/" />

  
  
  
  
  
  
  
  
    
    
  
  
  <meta property="twitter:card" content="summary" />
  
  <meta property="og:site_name" content="Kryptonite Lab" />
  <meta property="og:url" content="https://szthanatos.github.io/topic/docker/basis/" />
  <meta property="og:title" content="Docker -01- 基本概念 | Kryptonite Lab" />
  <meta property="og:description" content="Docker 简介 什么是 Docker Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公" /><meta property="og:image" content="https://szthanatos.github.io/media/icon_hu638af3a55c65206eddec4e3c4c13a753_187410_512x512_fill_lanczos_center_2.png" />
    <meta property="twitter:image" content="https://szthanatos.github.io/media/icon_hu638af3a55c65206eddec4e3c4c13a753_187410_512x512_fill_lanczos_center_2.png" /><meta property="og:locale" content="zh-Hans" />
  
    
      <meta
        property="article:published_time"
        content="2018-12-05T22:17:22&#43;08:00"
      />
    
    <meta property="article:modified_time" content="2018-12-05T22:17:22&#43;08:00">
  

  



  

  

  





  <title>Docker -01- 基本概念 | Kryptonite Lab</title>
</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper   " data-wc-page-id="2a21c6713191c46e684013e469dfa8c0" >

  
  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.b8153d4570dcbb34350a2a846dba8c03.js"></script>

  


<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>搜索</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="Close"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="搜索..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="搜索...">
        
      </div>

      
      

      

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    












<nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
  <div class="container-xl">

    
    <div class="d-none d-lg-inline-flex">
      <a class="navbar-brand" href="/">Kryptonite Lab</a>
    </div>
    

    
    <button type="button" class="navbar-toggler" data-toggle="collapse"
            data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="切换导航">
    <span><i class="fas fa-bars"></i></span>
    </button>
    

    
    <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
      <a class="navbar-brand" href="/">Kryptonite Lab</a>
    </div>
    

    
    
    <div class="navbar-collapse main-menu-item collapse justify-content-end" id="navbar-content">

      
      <ul class="navbar-nav d-md-inline-flex">
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#hero"><span>主页</span></a>
        </li>

        
        

        

        
        
        

        

        
        
        
        

        
          
            
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/post"><span>笔记</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
        

        <li class="nav-item">
          <a class="nav-link  active" href="/topic"><span>专栏</span></a>
        </li>

        
        

      

        
      </ul>
    </div>

    <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

      
      

      
      
      <li class="nav-item">
        <a class="nav-link js-search" href="#" aria-label="搜索"><i class="fas fa-search" aria-hidden="true"></i></a>
      </li>
      

      
      
      <li class="nav-item dropdown theme-dropdown">
        <a href="#" class="nav-link" data-toggle="dropdown" aria-haspopup="true" aria-label="Display preferences">
          <i class="fas fa-moon" aria-hidden="true"></i>
        </a>
        <div class="dropdown-menu">
          <a href="#" class="dropdown-item js-set-theme-light">
            <span>浅色</span>
          </a>
          <a href="#" class="dropdown-item js-set-theme-dark">
            <span>深色</span>
          </a>
          <a href="#" class="dropdown-item js-set-theme-auto">
            <span>自动</span>
          </a>
        </div>
      </li>
      

      
      

    </ul>

  </div>
</nav>


  </div>

  <div class="page-body">
    





<div class="container-fluid docs">
  <div class="row flex-xl-nowrap">
    <div class="col-12 col-md-3 col-xl-2 docs-sidebar">
      <form class="docs-search d-flex align-items-center">
  <button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type="button" data-toggle="collapse" data-target="#docs-nav" aria-controls="docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    <div class="d-flex">
      <span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">
        
          Overview
        
      </span>
      <span><i class="fas fa-chevron-down"></i></span>
    </div>
  </button>

  
  <button class="form-control sidebar-search js-search d-none d-md-flex">
    <i class="fas fa-search pr-2"></i>
    <span class="sidebar-search-text">搜索...</span>
    <span class="sidebar-search-shortcut">/</span>
  </button>
  
</form>

<nav class="collapse docs-links" id="docs-nav">
  
  
  
  
  
  

  
  
    

    
      

      <ul class="nav docs-sidenav">
        <li><a href="/topic/"><i class="fas fa-arrow-left pr-1"></i>Series</a></li>
      </ul>

      
      
        
          
        
      


  
    
    
    
    
      
    
    

    
      <div class="docs-toc-item">
        <a class="docs-toc-link " href="/topic/docker/">Overview</a>
    
      
        <ul class="nav docs-sidenav">
      


  <li class="active"><a href="/topic/docker/basis/">基本概念</a></li>



  <li class=""><a href="/topic/docker/ecology/">进阶生态</a></li>

      
        </ul>
      
    

    
      </div>
    

    
  
</nav>

    </div>

    
    
    <div class="d-none d-xl-block col-xl-2 docs-toc">
      

      <ul class="nav toc-top">
        <li><a href="#" id="back_to_top" class="docs-toc-title">在本页</a></li>
      </ul>

      <nav id="TableOfContents">
  <ul>
    <li><a href="#docker-简介">Docker 简介</a>
      <ul>
        <li><a href="#什么是-docker">什么是 Docker</a></li>
        <li><a href="#docker-特点">Docker 特点</a></li>
        <li><a href="#为什么要使用-docker">为什么要使用 Docker</a></li>
      </ul>
    </li>
    <li><a href="#基本概念">基本概念</a>
      <ul>
        <li><a href="#镜像">镜像</a></li>
        <li><a href="#容器">容器</a></li>
        <li><a href="#仓库">仓库</a></li>
        <li><a href="#生命周期">生命周期</a></li>
      </ul>
    </li>
    <li><a href="#安装配置">安装配置</a>
      <ul>
        <li><a href="#准备工作">准备工作</a></li>
        <li><a href="#使用脚本安装非生产环境">使用脚本安装（非生产环境）</a></li>
        <li><a href="#使用-yum-安装">使用 yum 安装</a></li>
        <li><a href="#离线安装">离线安装</a></li>
        <li><a href="#启动-docker-ce">启动 Docker CE</a></li>
        <li><a href="#建立-docker-用户组">建立 Docker 用户组</a></li>
        <li><a href="#测试-docker-是否安装正确">测试 Docker 是否安装正确</a></li>
        <li><a href="#镜像加速">镜像加速</a></li>
        <li><a href="#常用-docker-操作">常用 Docker 操作</a></li>
      </ul>
    </li>
    <li><a href="#使用镜像">使用镜像</a>
      <ul>
        <li><a href="#基本操作">基本操作</a></li>
        <li><a href="#dockerfile">Dockerfile</a></li>
      </ul>
    </li>
    <li><a href="#容器操作">容器操作</a>
      <ul>
        <li><a href="#容器启停">容器启停</a></li>
        <li><a href="#数据管理">数据管理</a></li>
        <li><a href="#使用网络">使用网络</a></li>
      </ul>
    </li>
    <li><a href="#延申">延申</a>
      <ul>
        <li><a href="#容器编排">容器编排</a></li>
        <li><a href="#nvidia-docker">Nvidia Docker</a></li>
      </ul>
    </li>
  </ul>
</nav>

      
    </div>
    

    <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 docs-content" role="main">

      <article class="article">

        <div class="docs-article-container">
          
            
  <nav class="d-none d-md-flex" aria-label="breadcrumb">
    <ol class="breadcrumb">
      
  
  
  

  <li class="breadcrumb-item">
    <a href="/">
      
        Home
      
    </a>
  </li>


  <li class="breadcrumb-item">
    <a href="/topic/">
      
        Series
      
    </a>
  </li>


  <li class="breadcrumb-item">
    <a href="/topic/docker/">
      
        Overview
      
    </a>
  </li>


      <li class="breadcrumb-item active" aria-current="page">
        基本概念
      </li>
    </ol>
  </nav>


          

          <h1>Docker -01- 基本概念</h1>

          <div class="article-style">
            <h2 id="docker-简介">Docker 简介</h2>
<h3 id="什么是-docker">什么是 Docker</h3>
<p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 <a href="https://github.com/moby/moby" target="_blank" rel="noopener">GitHub</a> 上进行维护，后来还加入了 Linux 基金会，并成立推动 <a href="https://www.opencontainers.org/" target="_blank" rel="noopener">开放容器联盟（OCI）</a>。</p>
<p>Docker 最初是在 Ubuntu 12.04 上以 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a> 进行开发实现的, Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持 (换句话说不支持 CentOS6.5 以下)。</p>
<p>Docker 是一种 <strong>容器化技术</strong> ，类似虚拟机的概念，但不同的是传统虚拟机是在虚拟硬件的基础上，完整模拟一整个操作系统，而 Docker 是以单个应用（容器）为单位进行虚拟。</p>
<p><img src="/media/virtualization.png" alt="传统虚拟化"></p>
<p><img src="/media/docker.png" alt="Docker"></p>
<h3 id="docker-特点">Docker 特点</h3>
<p>Docker 具有以下特点：</p>
<ul>
<li><strong>文件系统隔离</strong> ：每个进程容器运行在完全独立的根文件系统里。</li>
<li><strong>资源隔离</strong> ：可以使用 cgroup 为每个进程容器分配不同的系统资源，例如 CPU 和内存。</li>
<li><strong>网络隔离</strong> ：每个进程容器运行在自己的网络命名空间里，拥有自己的虚拟接口和 IP 地址。</li>
<li><strong>写时复制</strong> ：采用写时复制方式创建根文件系统，这让部署变得极其快捷，并且节省内存和硬盘空间。</li>
<li><strong>日志记录</strong> ：Docker 将会收集和记录每个进程容器的标准流（stdout/stderr/stdin），用于实时检索或批量检索。</li>
<li><strong>变更管理</strong> ：容器文件系统的变更可以提交到新的映像中，并可重复使用以创建更多的容器。无需使用模板或手动配置。</li>
<li><strong>交互式 Shell</strong> ：Docker 可以分配一个虚拟终端并关联到任何容器的标准输入上，例如运行一个一次性交互 shell。</li>
</ul>
<h3 id="为什么要使用-docker">为什么要使用 Docker</h3>
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left">容器</th>
<th style="text-align:left">虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">启动</td>
<td style="text-align:left">秒级</td>
<td style="text-align:left">分钟级</td>
</tr>
<tr>
<td style="text-align:left">硬盘使用</td>
<td style="text-align:left">一般为 <code>MB</code></td>
<td style="text-align:left">一般为 <code>GB</code></td>
</tr>
<tr>
<td style="text-align:left">性能</td>
<td style="text-align:left">接近原生</td>
<td style="text-align:left">弱于原生</td>
</tr>
<tr>
<td style="text-align:left">系统支持量</td>
<td style="text-align:left">单机支持上千个容器</td>
<td style="text-align:left">一般几十个</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>更高效的利用系统资源</strong> ：由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</li>
<li><strong>更快速的启动时间</strong> ：Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。</li>
<li><strong>一致的运行环境</strong> ： Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</li>
<li><strong>持续交付和部署</strong> ：对 <code>DevOps</code> 人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <a href="###Dockerfile">Dockerfile</a> 来进行镜像构建，并结合 <code>持续集成 (Continuous Integration)</code> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <code>持续部署 (Continuous Delivery/Deployment)</code> 系统进行自动部署。</li>
<li><strong>更轻松的迁移</strong> ：由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</li>
</ul>
<h2 id="基本概念">基本概念</h2>
<p>Docker 包括三个基本概念</p>
<ul>
<li>镜像（<code>Image</code>）</li>
<li>容器（<code>Container</code>）</li>
<li>仓库（<code>Repository</code>）</li>
</ul>
<p>理解了这三个概念，就理解了 Docker 的整个生命周期。</p>
<h3 id="镜像">镜像</h3>
<p>操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:16.04</code> 就包含了完整的一套 Ubuntu 16.04 最小系统的 <code>root</code> 文件系统。</p>
<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 <strong>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</strong></p>
<p>严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p><strong>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</strong> 比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h3 id="容器">容器</h3>
<p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p><strong>容器的实质是进程</strong> ，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <code>命名空间</code>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p>
<p>前面讲过镜像使用的是分层存储，容器也是如此。 <strong>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，</strong> 我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong> 。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此， <strong>任何保存于容器存储层的信息都会随容器删除而丢失</strong> 。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。 <strong>所有的文件写入操作，都应该使用 [数据卷（Volume）](#### 方式 1：数据卷（推荐）)、或者 [绑定宿主目录](#### 方式 2：挂载主机目录)</strong> ，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h3 id="仓库">仓库</h3>
<p>如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker 提供注册服务器 (<code>Docker Registry</code>) 来实现这样的服务。</p>
<p>一个 <code>Docker Registry</code> 中可以包含多个 <strong>仓库</strong> （<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong> （<code>Tag</code>）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt; 标签 &gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p>
<p>以 <a href="https://store.docker.com/images/ubuntu" target="_blank" rel="noopener">Ubuntu 镜像</a> 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>14.04</code>, <code>16.04</code>。我们可以通过 <code>ubuntu:14.04</code>，或者 <code>ubuntu:16.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p>
<p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<p>类似 git 和 GitHub，官方提供 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，作为默认的 Registry。用户也可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://store.docker.com/images/registry/" target="_blank" rel="noopener">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。</p>
<h3 id="生命周期">生命周期</h3>
<p>结合上面的概念，这里有一张图比较好的概括了整个 Docker 工作的生命周期（以及主要命令）。
<img src="/media/period.png" alt="生命周期"></p>
<h2 id="安装配置">安装配置</h2>
<p>这里仅以 CentOS 安装 Docker CE 举例说明。详见 <a href="https://docs.docker.com/engine/installation/linux/docker-ce/centos/" target="_blank" rel="noopener">Docker 官方 CentOS 安装文档</a></p>
<h3 id="准备工作">准备工作</h3>
<h4 id="系统要求">系统要求</h4>
<p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。</p>
<blockquote>
<p>警告：切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker.</p>
</blockquote>
<h4 id="卸载旧版本">卸载旧版本</h4>
<p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p>
<pre><code class="language-bash">sudo yum remove docker \
                docker-client \
                docker-client-latest \
                docker-common \
                docker-latest \
                docker-latest-logrotate \
                docker-logrotate \
                docker-selinux \
                docker-engine-selinux \
                docker-engine
</code></pre>
<h3 id="使用脚本安装非生产环境">使用脚本安装（非生产环境）</h3>
<p>对于个人测试，可以使用这个脚本自动化安装 Docker：</p>
<pre><code class="language-bash">curl -fsSL get.docker.com -o get-docker.sh
sh get-docker.sh
</code></pre>
<p>但是，需要注意， <strong>这个脚本可能扰乱你的系统配置、安装及大量的（你可能用不到的）依赖，并且只能安装最新（可能未经充分测试的）版本的 Docker</strong> ， 所以不推荐在生产环境中使用。</p>
<h3 id="使用-yum-安装">使用 yum 安装</h3>
<p>安装依赖包：</p>
<pre><code class="language-bash">sudo yum install -y yum-utils \
                    device-mapper-persistent-data \
                    lvm2
</code></pre>
<p>添加 <code>yum</code> 软件源：</p>
<pre><code class="language-bash"># 中国科学技术大学开源软件镜像源
sudo yum-config-manager \
    --add-repo \
    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo


# 官方源
# sudo yum-config-manager \
#     --add-repo \
#     https://download.docker.com/linux/centos/docker-ce.repo
</code></pre>
<p>更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code>。</p>
<pre><code class="language-bash">sudo yum makecache fast
sudo yum install docker-ce
</code></pre>
<h3 id="离线安装">离线安装</h3>
<p>以 docker-ce-18.03.1 为例：</p>
<ol>
<li>在 <code>https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</code> 这里找到对应 rpm 包</li>
<li>执行安装命令：<code>rpm -ivh docker-ce-18.03.1.ce-1.el7.centos.x86_64.rpm</code></li>
<li>由于安装环境不同，可能会发现缺少一些相关依赖包（eg: libcgroup、libtool-ltdl、container-selinux）前往 <code>https://pkgs.org/</code> 或 <code>https://buildlogs.centos.org/</code> 下载对应依赖包，依次安装即可</li>
</ol>
<h3 id="启动-docker-ce">启动 Docker CE</h3>
<pre><code class="language-bash">sudo systemctl enable docker
sudo systemctl start docker
</code></pre>
<h3 id="建立-docker-用户组">建立 Docker 用户组</h3>
<p>默认情况下，docker 命令需要 <code>root</code> 权限，为了避免每次输入命令都要加 <code>sudo</code>，可以将用户加入 <code>docker</code> 用户组：</p>
<pre><code class="language-bash">sudo groupadd docker
sudo usermod -aG docker $USER
</code></pre>
<p>退出当前终端并重新登录，进行如下测试。</p>
<h3 id="测试-docker-是否安装正确">测试 Docker 是否安装正确</h3>
<p>执行</p>
<pre><code class="language-bash">docker run hello-world
</code></pre>
<p>Docker 会从官方仓库下载 hello-world 镜像并启动，如果一切正常的话会看到类似如下提示：</p>
<pre><code class="language-bash">Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
ca4f61b1923c: Pull complete
Digest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905c
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://cloud.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/engine/userguide/
</code></pre>
<h3 id="镜像加速">镜像加速</h3>
<p>鉴于国内网络问题，建议使用 Docker 中国或者其他国内镜像源。</p>
<p>修改（或新增）<code>/etc/docker/daemon.json</code> 文件，添加:</p>
<pre><code class="language-bash">{
  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]
}
</code></pre>
<p>之后重启 Docker 使配置生效。</p>
<h3 id="常用-docker-操作">常用 Docker 操作</h3>
<pre><code class="language-bash"># 查看 docker 版本
docker version
# 显示 docker 系统的信息
docker info
# 日志信息
docker logs
# 故障检查
service docker status
# 启动关闭 docker
sudo service docker start|stop
</code></pre>
<h2 id="使用镜像">使用镜像</h2>
<h3 id="基本操作">基本操作</h3>
<p>以 redis 为例，我们从 <a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">Docker Hub</a> 上获取官方镜像到本地：</p>
<p><img src="/media/hub-redis.jpg" alt="Docker hub redis"></p>
<pre><code class="language-bash">docker pull redis
</code></pre>
<p><em>ps1：</em> 由于 redis 是官方源（Official），否则应该写完整的两段式仓库名 <code>&lt;用户名&gt;/&lt; 软件名 &gt;</code>，例如 bitnami/redis。</p>
<p><em>ps2：</em> 此处没有指定镜像版本，默认会拉取 redis:lastest 镜像，指定版本应该写成例如：redis:5.0-rc5</p>
<p>查看已经下载的镜像：</p>
<pre><code class="language-bash">docker image ls

# 会有类似如下显示
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
redis                latest              5f515359c7f8        5 days ago          183 MB
......
</code></pre>
<p>更细节的显示可以使用 <code>docker image ls --format &quot;{{.ID}}: {{.Repository}}&quot;</code> 直接列出镜像 ID 和仓库名,</p>
<p>或者使用 <code>docker image ls --format &quot;table {{.ID}}\t{{.Repository}}\t{{.Tag}}&quot;</code>
以表格等距显示.</p>
<p>如果要删除某个镜像的话，可以使用 <code>docker image rm {IMAGE ID}|{REPOSITORY}</code> 命令，不要过先确保没有容器在使用这个镜像。</p>
<h3 id="dockerfile">Dockerfile</h3>
<p>除了引用制作好的镜像，我们也可以基于现有镜像定制新的镜像。定制所用的脚本文件就是 Dockerfile。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令 (Instruction)</strong> ，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>我们新建一个空白文件，命名为 <code>dockerfile</code>，再文件中写入如下内容：</p>
<pre><code class="language-dockerfile">FROM redis
RUN mkdir redis
WORKDIR redis
COPY ./redis.conf /etc/
CMD [&quot;redis-server&quot;, &quot;/etc/redis.conf&quot;]
</code></pre>
<p>我们依次解释上面每一行：</p>
<ul>
<li><strong>FROM</strong> 就是指定 <strong>基础镜像</strong> , 一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。如果不以任何镜像为基础，那应该用 <code>FROM scratch</code> 作为起始指令。</li>
<li><strong>RUN</strong> 是 Dockerfile 的核心指令，用于执行一条命令，由于 Dockerfile 每一条指令都会新建一层，所以应该尽量将执行的内容写在一行（多行内容可以通过在末尾加 <code>\</code> 以表示未结束），它有两种写法：
<ul>
<li><strong>shell</strong> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。</li>
<li><strong>exec</strong> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数 1&quot;, &quot;参数 2&quot;]</code>，这更像是函数调用中的格式。</li>
</ul>
</li>
<li><strong>WORKDIR</strong> 表示指定当前工作目录，相当于 <code>cd</code> 命令。</li>
<li><strong>COPY</strong> 即复制文件到容器中，在这里是把 redis.conf 文件复制到容器的 <code>/etc</code> 目录下。</li>
<li><strong>CMD</strong> 是启动程序的命令，写法和 <code>RUN</code> 相同，一般推荐使用 <code>exec</code> 格式。</li>
</ul>
<p>常用 Docker 指令列表如下：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>FROM</td>
<td>指定基础镜像</td>
<td><code>FROM &lt;基础镜像&gt;</code></td>
</tr>
<tr>
<td>RUN</td>
<td>执行指令</td>
<td><code>RUN [&quot;可执行文件&quot;, &quot;参数 1&quot;, &quot;参数 2&quot;]</code></td>
</tr>
<tr>
<td>COPY</td>
<td>复制文件</td>
<td><code>COPY [&quot;&lt; 源路径 1&gt;&quot;,... &quot;&lt; 目标路径 &gt;&quot;]</code></td>
</tr>
<tr>
<td>ADD</td>
<td>更高级的复制文件</td>
<td><code>ADD &quot;&lt;压缩文件&gt;&quot;</code></td>
</tr>
<tr>
<td>CMD</td>
<td>容器启动命令</td>
<td><code>CMD [&quot;可执行文件&quot;, &quot;参数 1&quot;, &quot;参数 2&quot;...]</code></td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>入口点</td>
<td><code>ENTRYPOINT [&quot;可执行文件&quot;, &quot;参数 1&quot;, &quot;参数 2&quot;]</code></td>
</tr>
<tr>
<td>ENV</td>
<td>设置环境变量</td>
<td><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></td>
</tr>
<tr>
<td>ARG</td>
<td>构建参数</td>
<td><code>ARG &lt;参数名&gt;[=&lt; 默认值 &gt;]</code></td>
</tr>
<tr>
<td>VOLUME</td>
<td>定义匿名卷</td>
<td><code>VOLUME [&quot;&lt; 路径 1&gt;&quot;, &quot;&lt; 路径 2&gt;&quot;...]</code></td>
</tr>
<tr>
<td>EXPOSE</td>
<td>暴露端口</td>
<td><code>EXPOSE &lt;端口 1&gt; [&lt; 端口 2&gt;...]</code></td>
</tr>
<tr>
<td>WORKDIR</td>
<td>指定工作目录</td>
<td><code>WORKDIR &lt;工作目录路径&gt;</code></td>
</tr>
<tr>
<td>USER</td>
<td>指定当前用户</td>
<td><code>USER &lt;用户名&gt;</code></td>
</tr>
<tr>
<td>HEALTHCHECK</td>
<td>健康检查</td>
<td>`HEALTHCHECK NONE</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>构建下级镜像</td>
<td><code>ONBUILD &lt;其它指令&gt;</code></td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>指定作者</td>
<td><code>ONBUILD &lt;作者&gt;</code></td>
</tr>
</tbody>
</table>
<p>更多指令及用法请参照 <a href="https://docs.docker.com/engine/reference/builder" target="_blank" rel="noopener">官方文档</a></p>
<p>如上，我们完成了一个使用自己配置文件的 redis 镜像的准备工作，之后依据这个 Dockerfile 进行构建：</p>
<pre><code class="language-bash">docker build -t redis_test:v0.1 .

# 会有类似如下输出：
Sending build context to Docker daemon 2.048 kB
Step 1 : FROM redis
...
...
Removing intermediate container 9cdc27646c7b
Successfully built 44aa4490ce2c
</code></pre>
<p><code>docker build</code> 的用法为：</p>
<pre><code class="language-bash">docker build [选项] &lt; 上下文路径 / URL/-&gt;
</code></pre>
<p>最后，可以使用 <code>docker push</code> 将你自己构建的镜像上传到仓库中，详细用法见 <a href="https://docs.docker.com/engine/reference/commandline/push/" target="_blank" rel="noopener">官方文档 push</a></p>
<h2 id="容器操作">容器操作</h2>
<h3 id="容器启停">容器启停</h3>
<p>我们可以用这样的方式从之前的镜像启动一个容器：</p>
<pre><code class="language-bash">docker run -d --name some-redis redis
</code></pre>
<p><code>docker run</code> 的用法为 <code>docker run [选项] 镜像 [命令] [参数...]</code>，其中：</p>
<p><code>--name</code> 指定容器的名称， <code>-d</code> 指定后台运行，其他常用参数包括 <code>-i</code> 交互式操作，<code>-t</code> 使用终端（<code>it</code> 一般同时使用），<code>--rm</code> 容器退出后随之将其删除，完整参数列表可以通过 <code>--help</code> 或者 <a href="https://docs.docker.com/engine/reference/commandline/run/" target="_blank" rel="noopener">在线文档 docker run</a> 查看</p>
<p>由于我们是在后台运行，使用 <code>docker container ls</code> 来查看容器相关情况，如果要查看停止的进程，后面需要增加参数 <code>-a</code>：</p>
<pre><code class="language-bash">docker container ls

# 会看到类似如下内容
CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES
77b2dc01fe0f  redis:v2  redis-server redis.conf 'while tr  2 minutes ago  Up 1 minute        agitated_wright
</code></pre>
<p>使用 <code>docker container stop</code> 来结束容器的运行：</p>
<pre><code class="language-bash">docker container stop 77b2dc01fe0f
</code></pre>
<p>类似的，使用 <code>docker container start | restart | stop</code> 可以控制容器的启停，
使用 <code>docker container rm</code> 来删除指定容器。</p>
<h3 id="数据管理">数据管理</h3>
<p>之前提到过，随着容器的销毁，容器内的数据也会一同丢失。为了保存数据，Docker 提供了两种方式（还有一种 tmpfs mountsb 不常用到）：</p>
<h4 id="方式-1数据卷推荐">方式 1：数据卷（推荐）</h4>
<p>数据卷 <code>volume</code> 是一个可供一个或多个容器使用的特殊目录，它不依赖于 Unix 文件系统，也拥有独立于容器的生命周期。</p>
<p>创建一个数据卷:</p>
<pre><code class="language-bash">docker volume create my-vol
</code></pre>
<p>查看数据卷及具体信息：</p>
<pre><code class="language-bash"># 查看所有的数据卷
docker volume ls

# 会看到类似如下内容
local               my-vol

# -----------------------------------

# 查看具体卷的信息
docker volume inspect my-vol

# 会看到类似如下内容
[
    {
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: {},
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,
        &quot;Name&quot;: &quot;my-vol&quot;,
        &quot;Options&quot;: {},
        &quot;Scope&quot;: &quot;local&quot;
    }
]
</code></pre>
<p>在用 docker run 的时候，增加 <code>--mount</code> 参数来使用数据卷, 还是以启动 redis 为例，这里我们启动 redis 并且开启 aof 持久化：</p>
<pre><code class="language-bash">docker run -d \
    --name redis \
    --mount source=my-vol,target=/data \
    # -v my-vol:/data \
    redis \
    redis-server --appendonly yes
</code></pre>
<p>在这里 redis 产生的数据（<code>/data</code> 目录下）被挂载到数据卷 <code>my-vol</code> 中。</p>
<p>我们也可以使用 <code>-v</code> 或者 <code>--volume</code> 语法，但是 <a href="https://docs.docker.com/storage/volumes/#choose-the--v-or---mount-flag" target="_blank" rel="noopener">官方建议</a> 尽量使用 <code>--mount</code>。</p>
<p>同样使用 <code>inspect</code> 语法，我们可以查看 redis 容器的信息：</p>
<pre><code class="language-bash">docker inspect redis

# 会看到类似如下内容
&quot;Mounts&quot;: [
    {
        &quot;Type&quot;: &quot;volume&quot;,
        &quot;Name&quot;: &quot;my-vol&quot;,
        &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,
        &quot;Destination&quot;: &quot;/data&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Mode&quot;: &quot;&quot;,
        &quot;RW&quot;: true,
        &quot;Propagation&quot;: &quot;&quot;
    }
],
</code></pre>
<h4 id="方式-2绑定主机目录">方式 2：绑定主机目录</h4>
<p>我们也可以直接将容器的数据挂载 <code>bind mount</code> 到宿主机的目录或文件 （而非由 Docker 创建的数据卷）, 以当前目录 <code>$(pwd)</code> 为例：</p>
<pre><code class="language-bash">docker run -d \
    --name redis \
    --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/data \
    redis \
    redis-server --appendonly yes
</code></pre>
<p>挂载单独文件的方法类似。</p>
<p>需要注意，本地目录必须存在，否则会报错。</p>
<h4 id="区别">区别</h4>
<p><img src="/media/types-of-mounts-volume.png" alt="types of mounts volume"></p>
<p>Volumes 是由 Docker 创建和管理，存储在宿主机固定位置（在 linux 上是 / var/lib/docker/volumes/）。 <strong>非 Docker 应用程序不能改动这一位置的数据。</strong> 一个数据卷可以同时被挂载到几个容器中。即使没有正在运行的容器使用这个数据卷，它依然不会清除。可以通过 <code>docker volume prune</code> 清除不再使用的数据卷。</p>
<p>Bind mounts 的数据可以存放在宿主机的任何地方。 <strong>非 Docker 应用程序可以改变这些数据。</strong></p>
<h3 id="使用网络">使用网络</h3>
<h4 id="端口映射">端口映射</h4>
<p><code>docker run</code> 的时候使用 <code>-P</code>(&ndash;publish-all) 参数，随机映射一个 49000~49900 的端口到内部容器开放的网络端口。</p>
<p>或者使用 <code>-p ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>(&ndash;publish) 来指定具体端口映射：</p>
<pre><code class="language-bash">docker run -d \
    --name some-redis \
    -p 6379:6379 \
    -p 127.0.0.1::16379/udp
    -p 127.0.0.1:80:80
    redis
</code></pre>
<p>这里我们分别将容器的 6379 端口映射到宿主机 <strong>任意 ip 的 6379 端口</strong> ，容器的 16379 udp 端口映射到宿主机的 <strong>任意端口</strong> ，容器的 80 端口映射到宿主机 <strong>对应的 80 端口</strong> 。</p>
<p>使用 <code>docker port</code> 可以查看对应容器的全部端口映射。</p>
<h4 id="容器互联">容器互联</h4>
<p>简单的容器互联可以通过 <code>--link</code> 实现，但是 <strong>官方未来可能会删除这个参数</strong> ，所以不展开。</p>
<p>最新的方式是搭建 docker 网络实现容器互联，先创建一个新的 Docker 网络：</p>
<pre><code class="language-bash">docker network create -d bridge my-net
</code></pre>
<p>这里的 <code>-d</code> 参数指定网络类型，常用的只有 bridge，其他的可能会在 Swarm 用到, 如果不知道 Swarm 是什么就不用在意。</p>
<p>以 redis 客户端 / 服务端为例，分别在启动的时候将之加入 <code>my-net</code> 网络：</p>
<pre><code class="language-bash">docker run -d \
    --name redis-server \
    --network my-net \
    redis

docker run -it \
    --rm \
    --name redis-client \
    --network my-net \
    redis redis-cli -h redis-server

</code></pre>
<p>可以看到成功进入 redis-cli 客户端，我们可以尝试 <code>info</code>/<code>keys *</code> 或者其他命令查看 redis 服务端运行情况。</p>
<h2 id="延申">延申</h2>
<h3 id="容器编排">容器编排</h3>
<p>面临一组容器配合使用的情况，例如一个包括负载均衡——网站后台——数据库的 Web 系统，我们可以使用 Docker 提供的 <a href="https://github.com/docker/compose" target="_blank" rel="noopener">Compose</a> 完成统一配置管理。它将提供相同功能的容器定义为服务 <code>service</code>——以方便复用；将完整的容器组合组成项目 <code>project</code> 以方便统一管理。所有的配置通过一个 yml 文件即可实现。</p>
<h3 id="nvidia-docker">Nvidia Docker</h3>
<p>对使用 GPU 的容器，Docker 提供 <a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="noopener">Nvidia Docker</a> 以发挥 GPU 的运算性能。</p>
<p>基本要求如下：</p>
<ul>
<li>GNU/Linux x86_64 with kernel version &gt; 3.10</li>
<li>Docker &gt;= 1.12</li>
<li>NVIDIA GPU with Architecture &gt; Fermi (2.1)</li>
<li>NVIDIA drivers ~= 361.93 (untested on older versions)</li>
</ul>
<p>详细安装使用见 <a href="https://github.com/NVIDIA/nvidia-docker/wiki/Installation-%28version-2.0%29" target="_blank" rel="noopener">官方项目 Wiki</a></p>

          </div>

          



          
          
          <div class="article-widget">
            
<div class="post-nav">
  
  
  
  <div class="post-nav-item">
    <div class="meta-nav">下一页</div>
    <a href="/topic/docker/ecology/" rel="prev">Docker -02- 进阶生态</a>
  </div>
  
</div>

          </div>
          
        </div>

        <div class="body-footer">
          <p>最近更新于 Dec 5, 2018</p>

          





          
<section id="comments">
    <div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js">
</script>
<script>
    var gitalk = new Gitalk({
        clientID: '95c7518c2e13947a88a9',
        clientSecret: '4e3889bd58252b6e96476a7660b463f6ac69f510',
        repo: 'szthanatos.github.io',
        owner: 'szthanatos',
        admin: 'szthanatos',
        id: location.pathname,      
        distractionFreeMode: false  
    })
    gitalk.render('gitalk-container')
</script>
</section>


          


  
  



        </div>

      </article>

      <footer class="site-footer">

  

  

  
  <p class="powered-by">
    © 2021 szthanatos
  </p>
  

  
  





  
  
  
  

  
  
    
  
  
    
  

  

  
  <p class="powered-by copyright-license-text">
    本站内容均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际许可协议</a> 进行许可。
  </p>
  

  <p class="powered-by footer-license-icons">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0" rel="noopener noreferrer" target="_blank" aria-label="Creative Commons">
      <i class="fab fa-creative-commons fa-2x" aria-hidden="true"></i>
      <i class="fab fa-creative-commons-by fa-2x" aria-hidden="true"></i>
      
        <i class="fab fa-creative-commons-nc fa-2x" aria-hidden="true"></i>
      
      
        <i class="fab fa-creative-commons-sa fa-2x" aria-hidden="true"></i>
      
    </a>
  </p>




  <p class="powered-by">
    
    
    
      
      
      
      
      
      
      由<a href="https://wowchemy.com/?utm_campaign=poweredby" target="_blank" rel="noopener">Wowchemy</a>支持发布——免费<a href="https://github.com/wowchemy/wowchemy-hugo-modules" target="_blank" rel="noopener">开源</a>网站，为创作者赋能。
    
  </p>
</footer>


    </main>
  </div>
</div>

  </div>

  <div class="page-footer">
    
    
  </div>

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">引用</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> 复制
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> 下载
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

      

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.1.0/instantpage.min.js" integrity="sha512-1+qUtKoh9XZW7j+6LhRMAyOrgSQKenQ4mluTR+cvxXjP1Z54RxZuzstR/H9kgPXQsVB8IW7DMDFUJpzLjvhGSQ==" crossorigin="anonymous"></script>

      
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      

      
      

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js" integrity="sha512-TDKKr+IvoqZnPzc3l35hdjpHD0m+b2EC2SrLEgKDRWpxf2rFCxemkgvJ5kfU48ip+Y+m2XVKyOCD85ybtlZDmw==" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/python.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/go.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/javascript.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/typescript.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/powershell.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/properties.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/sql.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/dockerfile.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/yaml.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/toml.min.js"></script>
        
      

    

    
    
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js" integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin="anonymous"></script>
    <script>
      anchors.add();
    </script>
    

    
    
    
      
      <script id="search-hit-fuse-template" type="text/x-template">
        <div class="search-hit" id="summary-{{key}}">
          <div class="search-hit-content">
            <div class="search-hit-name">
              <a href="{{relpermalink}}">{{title}}</a>
              <div class="article-metadata search-hit-type">{{type}}</div>
              <p class="search-hit-description">{{snippet}}</p>
            </div>
          </div>
        </div>
      </script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
      
    

    
    

    
    
    
    

    
    <script src="/js/bootstrap.bundle.min.6aed84840afc03ab4d5750157f69c120.js"></script>

    
    
      
      
      
      
      
      
      
    

    
    
    
    
    
    
    
    
      
      
    
    
    <script src="/zh/js/wowchemy.min.c01dc0f474cb5aa17a63e06eb00111fe.js"></script>

    <script>
    ((window.gitter = {}).chat = {}).options = {
        room: 'szthanatos\-github\-io/community'
    };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>
<style>
    .gitter-chat-embed {
        top: 70px;
    }
</style>


</body>
</html>
